<html>
<head>
<title>Struts User's Guide</title>
</head>
<body bgcolor="white">

<div align="center">
<h1>Struts User's Guide</h2>
<h3>$Id: users_guide.html,v 1.12 2001/01/10 07:35:18 craigmcc Exp $</h3>
</div>

<h2>0. Deprecation Note</h2>

<p><strong>ALL OF THE INFORMATION IN THIS DOCUMENT IS DEPRECATED, BECAUSE IT IS
SPECIFIC TO STRUTS 0.5.  BE SURE TO REFER TO THE STRUTS 1.0 VERSION OF THE
USER'S GUIDE, WHICH IS AVAILABLE AS PART OF THE STRUTS 1.0 RELEASE
DOCUMENTATION.</strong></p>

<h2>1. Introduction</h2>


<h3>1.1 The Model-View-Controller (MVC) Design Pattern</h3>

<p><b>FIXME</b> - Need a general introduction to the pattern.</p>


<h3>1.2 Mapping MVC Concepts to Struts Components</h3>

<p>The <i>Struts</i> architecture implements the concepts of the
Model-View-Controller design pattern by mapping them to web application
components and concepts, as outlined in the following diagram:</p>

<hr><div align="center">
<img src="model2.gif">
</div><hr>

<p>Each major component of this architecture will be discussed in more
detail below.</p>


<h3>1.3 The Model:  System State and Business Logic JavaBeans</h3>

<p>The <i>Model</i> portion of an MVC-based system can be subdivided into
concepts -- the internal state of the system, and the actions that can be
taken to change that state.  In grammatical terms, we might think about
state information as <i>nouns</i> (things) and actions as <i>verbs</i>
(changes to the state of those things).</p>

<p>Generally, your application will represent the internal state of the
system as a set of one or more JavaBeans, with properties that represent
the details of the state.  Depending on your application's complexity,
these beans may be self contained (and know how to save their state
information persistently somehow), or they may be facades that know
how to retrieve information from external sources (such as a database)
when it is requested.  Entity Enterprise JavaBeans (EJBs) are also commonly
used to represent internal state.</p>

<p>Large-scale applications will often represent the business logic actions
that are possible in a system as methods that can be called on the beans
maintaining the state information.  For example, you might have a shopping
cart bean, stored in session scope for each current user, with properties
that represent the current set of items that the user has decided to
purchase.  This bean might also have a <code>checkOut()</code> method
that authorizes the user's credit card, and sends the order to the
warehouse to be picked and shipped.  Other systems will represent the
available actions separately, perhaps as Session Enterprise JavaBeans
(EJBs).</p>

<p>In some smaller scale applications, on the other hand, the available
actions might be embedded within the <code>Action</code> classes that are
part of the Controller role.  This is appropriate when the logic is very
simple, or where reuse of the business logic in other environments is not
contemplated.  The Struts framework supports any of these approaches, but
recommends separating the business logic ("what to do") from the role that
<code>Action</code> classes play ("deciding what to do").</p>


<h3>1.4 The View:  JSP Pages and Presentation Components</h3>

<p>The <i>View</i> portion of a Struts-based application is generally
constructed using JavaServer Pages (JSP) technology.  JSP pages can
contain static HTML (or XML) text called "template text", plus the
ability to insert dynamic content based on the interpretation (at page
request time) of special action tags.  The JSP environment includes a
set of standard action tags, such as <code>&lt;jsp:useBean&gt;</code>
whose purpose is described in the JavaServer Pages Specification.  In
addition, there is a standard facility to define your own tags, which
are organized into "custom tag libraries."</p>

<p>Struts includes an extensive custom tag library that facilitates
creating user interfaces that are fully internationalized, and that
interact gracefully with <code>ActionForm</code> beans that are part
of the <i>Model</i> portion of the system.  The use of these tags is
discussed in detail later.</p>

<p>In addition to JSP pages and the action and custom tags they contain,
it is often necessary for business objects to be able to render
themselves in HTML (or XML), based on their current state at request time.
The rendered output from such objects can be easily included in a
resulting JSP page by using the <code>&lt;jsp:include&gt;</code>
standard action tag.</p>


<h3>1.5 The Controller:  ActionServlet and ActionMapping</h3>

<p>The <i>Controller</i> portion of the application is focused on receiving
requests from the client (typically a user running a web browser), deciding
what business logic function is to be performed, and then delegating
responsibility for producing the next phase of the user interface to
an appropriate View component.  In Struts, the primary component of the
controller is a servlet of class <code>ActionServlet</code>.  This servlet
is configured by defining a set of mappings (described by a Java interface
<code>ActionMapping</code>).  Each mapping defines a <code>path</code>
that is matched against the request URI of the incoming request, and the
fully qualified class name of an <code>Action</code> class (that is, a
Java class implementing the <code>Action</code> interface) which is
responsible for performing the desired business logic, and then dispatching
control to the appropriate View component to create the response.</p>

<p>Struts also supports the ability to use <code>ActionMapping</code>
classes that have additional properties beyond the standard ones required
to operate the framework.  This allows you to store additional information
specific to your application, but still utilize the remaining features of
the framework.  In addition, Struts lets you define logical "names" to which
control should be forwarded so that an action method can ask for the
"Main Menu" page (for example), without knowing what the actual name of the
corresponding JSP page is.  These features greatly assist you in separating
the control logic (what do I do next) with the view logic (what is the name
of the corresponding page).</p>


<h2>2. Building the Model Components</h2>


<h3>2.1 Overview</h3>

<p>The application requirements document that you are using will likely
have focused on the user interface to be created.  However, you should ensure
that the processing required for each submitted request is also clearly
defined.  In general, the developer of the <i>Model</i> components will be
focusing on the creation of JavaBeans classes that support all of the
functional requirements.  The precise nature of the beans required by a
particular application will vary widely depending on those requirements,
but they can generally be classified into several categories discussed
below.  However, a brief review of the concept of "scope" as it relates
to beans is useful first.</p>


<h3>2.2 JavaBeans and Scope</h3>

<p>Within a web-based application, JavaBeans can be stored in (and accessed
from) a number of different collections of "attributes".  Each collection
has different rules for the lifetime of that collection, and the visibility
of the beans stored there.  Together, the rules defining lifetime and
visibility are called the <i>scope</i> of those beans.  The JavaServer
Pages (JSP) Specification defines scope choices using the following terms
(with the equivalent servlet API concept defined in parentheses):</p>
<ul>
<li><b>page</b> - Beans that are visible within a single JSP page,
    for the lifetime of the current request.  (Local variables of
    the <code>service()</code> method)</li>
<li><b>request</b> - Beans that are visible within a single JSP page,
    as well as to any page or servlet that is included in this page,
    or forwarded to by this page.  (Request attributes)</li>
<li><b>session</b> - Beans that are visible to all JSP pages and
    servlets that participate in a particular user session, across one
    or more requests.  (Session attributes)</li>
<li><b>application</b> - Beans that are visible to all JSP pages and
    servlets that are part of a web application.  (Servlet context
    attributes)</li>
</ul>

<p>It is important to remember that JSP pages and servlets in the same
web application share the same sets of bean collections.  For example,
a bean stored as a request attribute in a servlet like this:</p>
<pre>
    MyCart mycart = new MyCart(...);
    request.setAttribute("cart", mycart);
</pre>
<p>is immediately visible to a JSP page which this servlet forwards to,
using a standard action tag like this:</p>
<pre>
    &lt;jsp:useBean id="cart" scope="request"
     class="com.mycompany.MyApp.MyCart"/&gt;
</pre>


<h3>2.3 ActionForm Beans</h3>

<p>The Struts framework generally assumes that you have created an
<code>ActionForm</code> bean (that is, a Java class implementing the
<code>ActionForm</code> interface) for each input form required in your
application.  If you define such beans in your <code>ActionMapping</code>
configuration file (see "Building the Controller Components"), the Struts
controller servlet will automatically perform the following services for
you, before invoking the appropriate <code>Action</code> method:</p>
<ul>
<li>Check in the user's session for an instance of a bean of the
    appropriate class, under the appropriate key.</li>
<li>If there is no such session scope bean available, a new one is
    automatically created and added to the user's session.</li>
<li>For every request parameter whose name corresponds to the name
    of a property in the bean, the corresponding setter method will
    be called.  This operates in a manner similar to the standard
    JSP action <code>&lt;jsp:setProperty&gt;</code> when you use the
    asterisk wildcard to select all properties.</li>
<li>The updated <code>ActionForm</code> bean will be passed to the
    Action Class <code>perform()</code> method when it is called,
    making these values immediately available.</li>
</ul>

<p>When you code your <code>ActionForm</code> beans, keep the following
principles in mind:</p>
<ul>
<li>The <code>ActionForm</code> interface itself requires no specific
    methods to be implemented.  It is used to identify the role these
    particular beans play in the overall architecture.  Typically, an
    <code>ActionForm</code> bean will have only property getter and
    property setter methods, with no business logic.</li>
<li>Generally, there will be very little input validation logic in an
    <code>ActionForm</code> bean.  The primary reason such beans exist
    is to save the most recent values entered by the user for the
    associated form -- even if errors are detected -- so that the same
    page can be reproduced, along with a set of error messages, so the
    user need only correct the fields that are wrong.  Validation
    of user input should be performed within <code>Action</code> classes
    (if it is simple), or appropriate business logic beans.</li>
<li>Define a property (with associated <code>getXxx()</code> and
    <code>setXxx()</code> methods) for each field that is present
    in the form.  The field name and property name must match according
    to the usual JavaBeans conventions.  For example, an input field named
    <code>username</code> will cause the <code>setUsername()</code> method
    to be called.</li>
</ul>

<p>You should note that a "form", in the sense discussed here, does not
necessarily correspond to a single JSP page in the user interface.  It is
common in many applications to have a "form" (from the user's perspective)
that extends over multiple pages.  Think, for example, of the wizard style
user interface that is commonly used when installing new applications.  Struts
encourages you to define a single <code>ActionForm</code> bean that contains
properties for all of the fields, no matter which page the field is actually
displayed on.  Likewise, the various pages of the same form should all be
submitted to the same Action Class.  If you follow these suggestions, the
page designers can rearrange the fields among the various pages, with no
changes required to the processing logic in most cases.</p>


<h3>2.4 System State Beans</h3>

<p>The actual state of a system is normally represented as a set of one or
more JavaBeans classes, whose properties define the current state.  A
shopping cart system, for example, will include a bean that represents the
cart being maintained for each individual shopper, and will (among other
things) include the set of items that the shopper has currently selected
for purchase.  Separately, the system will also include different beans
for the user's profile information (including their credit card and ship-to
addresses), as well as the catalog of available items and their current
inventory levels.</p>

<p>For small scale systems, or for state information that need not be kept
for a long period of time, a set of system state beans may contain all the
knowledge that the system ever has of these particular details.  Or, as is
often the case, the system state beans will represent information that is
stored permanently in some external database (such as a CustomerBean object
that corresponds to a particular row in the CUSTOMERS table), and are
created or removed from the server's memory as needed.  Entity Enterprise
JavaBeans are also used for this purpose in large scale applications.</p>


<h3>2.5 Business Logic Beans</h3>

<p>You should encapsulate the functional logic of your application as
method calls on JavaBeans designed for this purpose.  These methods may
be part of the same classes used for the system state beans, or they may
be in separate classes dedicated to performing the logic.  In the latter
case, you will usually need to pass the system state beans to be manipulated
to these methods as arguments.</p>

<p>For maximum code re-use, business logic beans should be designed and
implemented so that they do <b>not</b> know they are being executed in a
web application environment.  If you find yourself having to import a
<code>javax.servlet.*</code> class in your bean, you
are tying this business logic to the web application environment.  Consider
rearranging things so that your <code>Action</code> classes (part of the
Controller role, as described below) translate all required information
from the HTTP request being processed into property setter calls on your
business logic beans, after which a call to an <code>execute()</code> method
can be made.  Such a business logic class can be reused in environments
other than the web application for which they were initially constructed.</p>

<p>Depending on the complexity and scope of your application, business logic
beans might be ordinary JavaBeans that interact with system state beans
passed as arguments, or ordinary JavaBeans that access a database using
JDBC calls.  For larger applications, these beans will often be stateful
or stateless Enterprise JavaBeans (EJBs) instead.</p>


<h3>2.6 An Aside:  Accessing Relational Databases</h3>

<p>Many web applications will utilize a relational database (accessed through
a JDBC driver) to store the persistent data associated with the application.
Others will use Entity Enterprise JavaBeans for this purpose, which delegates
the decisions for how to maintain persistent state to the EJBs themselves.
If you are using Enterprise JavaBeans for this purpose, follow the client
design patterns described in the Enterprise JavaBeans specification.</p>

<p>For web applications based on direct database access, a common design
problem is how to make an appropriate JDBC Connection object available when
access to the underlying database is required.  There are several possible
approaches to this problem -- the following principles describe a
recommended approach to this issue:</p>
<ul>
<li>Create or acquire a ConnectionPool class, which lets a set of database
    connections be shared among multiple users.  Struts does not (currently)
    include such a class, but many are available.</li>
<li>When the application is initialized, define a servlet with a "load on
    startup" value in the application deployment descriptor.  We will call
    this the <i>startup</i> servlet.  In most cases, there will be no need
    for any requests to be processed by this servlet, so there will not be
    a <code>&lt;servlet-mapping&gt;</code> entry pointing at it.</li>
<li>In the <code>init()</code> method of the startup servlet, configure and
    instantiate an instance of your ConnectionPool class, and store it as
    a servlet context attribute (which is the same as an application scope
    bean from the JSP perspective).  It is usually convenient to configure
    the connection pool based on initialization parameters passed to the
    startup servlet.</li>
<li>In the <code>destroy()</code> method of the startup servlet, include
    logic to gracefully release the connections that have been opened by
    the connection pool.  This method will get called when the servlet
    container shuts down this application.</li>
<li>When an <code>Action</code> class needs to call a method of a business
    logic bean that requires a database connection (such as "insert a new
    customer"), it will the following steps:
    <ul>
    <li>Acquire the connection pool object from the servlet context
        attributes for this web application.</li>
    <li>Call the <code>open()</code> method of the connection pool object
        to give you a connection for use within this <code>Action</code>
        class call.</li>
    <li>Call the appropriate method of your business logic bean, passing the
        database connection object to be used as an argument.</li>
    <li>Call the <code>close()</code> method of the allocated connection,
        which will cause this connection to be returned to the pool for
        later re-use on some other request.</li>
    </ul>
<li>A common programming error is to forget to return the connection to the
    pool, which can ultimately lead to running out of connections.  Be sure
    that your <code>Action</code> class logic always returns the connection,
    even if the business logic bean method throws an exception.</li>
</ul>

<p>Following the design pattern recommended above means that you can code
your business logic classes without having to worry about how they acquire a
JDBC Connection to use -- simply include a Connection argument in any method
call that needs to access the database.  When your business logic class is
utilized within a web application, it will be the responsibility of the
<code>Action</code> class to allocate and release an appropriate connection.
When you use the same business logic class, for example, in a batch job, it
will be the responsibility of that application to provide an appropriate
connection (which will not need to be acquired from a pool, because most
batch jobs run in a single-threaded environment).</p>


<h2>3. Building the View Components</h2>


<h3>3.1 Overview</h3>

<p>This chapter focuses on the task of building the <i>View</i> components
of the application, which will primarily be created using JavaServer Pages
(JSP) technology.  In particular, Struts provides support for building
internationalized applications, as well as for interacting with input forms.
Several other topics related to the View components are briefly discussed.</p>


<h3>3.2 Internationalized Messages</h3>

<p>A few years ago, application developers could count on having to support
only residents of their own country, who are used to only one (or sometimes
two) languages, and one way to represent numeric quantities like dates,
numbers, and monetary values.  However, the explosion of application
development based on web technologies, as well as the deployment of such
applications on the Internet and other broadly accessible networks, have
rendered national boundaries invisible in many cases.  This has translated
(if you will pardon the pun) into a need for applications to support
<i>internationalization</i> (often called "i18n" because 18 is the number of
letters in between the "i" and the "n") and <i>localization</i>.</p>

<p>Struts builds upon the Java platform to provide assistance
for building internationalized and localized applications.  The key concepts
to become familiar with are:</p>
<ul>
<li><b>Locale</b> - The fundamental Java class that supports
    internationalization is <code>java.util.Locale</code>.  Each
    <code>Locale</code> represents a particular choice of country and
    language (plus an optional language variant), and also a set of
    formatting assumptions for things like numbers and dates.</li>
<li><b>ResourceBundle</b> - The <code>java.util.ResourceBundle</code> class
    provides the fundmental tools for supporting messages in multiple
    languages.  See the Javadocs for the <code>ResourceBundle</code> class,
    and the information on Internationalization in the documentation bundle
    for your JDK release, for more information.</li>
<li><b>PropertyResourceBundle</b> - One of the standard implementations of
    <code>ResourceBundle</code> allows you to define resources using the
    same "name=value" syntax used to initialize properties files.  This is
    very convenient for preparing resource bundles with messages that are
    used in a web application, because these messages are generally text
    oriented.</li>
<li><b>MessageFormat</b> - The <code>java.text.MessageFormat</code> class
    allows you to replace portions of a message string (in this case,
    one retrieved from a resource bundle) with arguments specified at
    run time.  This is useful in cases where you are creating a sentence,
    but the words would appear in a different order in different languages.
    The placeholder string <code>{0}</code> in the message is replaced by
    the first runtime argument, <code>{1}</code> is replaced by the second
    argument, and so on.
<li><b>MessageResources</b> - The Struts class
    <code>org.apache.struts.util.MessageResources</code> lets you treat
    a set of resource bundles like a database, and allows you to request
    a particular message string for a particular Locale (normally one
    associated with the current user) instead of for the default Locale
    the server itself is running in.
</ul>

<p>For an internationalized application, follow the steps described in
the Internationalization document in the JDK documentation bundle for your
platform to create a properties file containing the messages for each
language.  An example will illustrate this further.</p>

<p>Assume that your source code is created in package
<code>com.mycompany.mypackage</code>, so it is stored in a directory
(relative to your source directory) named
<code>com/mycompany/mypackage</code>.  To create a resource bundle called
<code>com.mycompany.mypackage.MyResources</code>, you would create the
following files in the <code>com/mycompany/mypackage</code> directory:</p>
<ul>
<li><b>MyResources.properties</b> - Contains the messages in the default
    language for your server.  If your default language is English, you
    might have an entry like this:
    <pre>
	prompt.hello=Hello
    </pre>
<li><b>MyResources_xx.properties</b> - Contains the same messages in the
    language whose ISO language code is "xx" (See the ResourceBundle
    Javadoc page for a link to the current list).  For a French version
    of the message shown above, you would have this entry:
    <pre>
	prompt.hello=Bonjour
    </pre>
    You can have resource bundle files for as many languages as you need.
</ul>

<p>When you configue the controller servlet in the web application
deployment descriptor, one of the things you will need to define in
an initialization parameter is the base name of the resource bundle
for the application.  In the case described above, it would be
<code>com.mycompany.mypackage.MyResources</code>.</p>


<h3>3.3 Forms and FormBean Interactions</h3>

<p>At one time or another, most web developers have built forms using
the standard capabilities of HTML, such as the <code>&lt;input&gt;</code>
tag.  Users have come to expect interactive applications to have certain
behaviors, and one of these expectations relates to error handling -- if
the user makes an error, the application should allow them to fix just what
needs to be changed -- without having to re-enter any of the rest of the
information on the current page or form.</p>

<p>Fulfilling this expectation is tedious and cumbersome when coding with
standard HTML and JSP pages.  For example, an input element for a
<code>username</code> field might look like this (in JSP)</p>
<pre>
	&lt;input type="text" name="username"
	 value="&lt;%= loginBean.getUsername() %&gt;">
</pre>
which is difficult to type correctly, confuses HTML developers who are
not knowledgeable about programming concepts, and can cause problems with
HTML editors.  Instead, Struts provides a comprehensive facility for
building forms, based on the Custom Tag Library facility of JSP 1.1.
The case above would be rendered like this using Struts:
<pre>
	&lt;struts:text name="username"/&gt;
</pre>
with no need to explicitly refer to the JavaBean from which the initial
value is retrieved.  That is handled automatically by the framework.</p>


<h4>3.3.1 Building Forms With Struts</h4>

<p>A complete example of a login form will illustrate how Struts
makes dealing with forms much less painful than using straight HTML
and standard JSP facilities.  Consider the following page (from the
example application included with Struts) named <code>logon.jsp</code>:</p>
<pre>
  &lt;%@ page language="java" %&gt;
  &lt;%@ taglib uri="/WEB-INF/struts.tld" prefix="struts" %&gt;

  &lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;&lt;struts:message key="logon.title"/&gt;&lt;/title&gt;
  &lt;body bgcolor="white"&gt;

  &lt;struts:errors/&gt;

  &lt;struts:form action="logon.do" name="logonForm"
   type="org.apache.struts.example.LogonForm"/&gt;
  &lt;table border="0" width="100%"&gt;
    &lt;tr&gt;
      &lt;th align="right"&gt;
        &lt;struts:message key="prompt.username"/&gt;
      &lt;/th&gt;
      &lt;td align="left"&gt;
        &lt;struts:text name="username" size="16"/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th align="right"&gt;
        &lt;struts:message key="prompt.password"/&gt;
      &lt;/th&gt;
      &lt;td align="left"&gt;
        &lt;struts:password name="password" size="16"/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align="right"&gt;
        &lt;struts:submit&gt;
          &lt;struts:message key="button.submit"/&gt;
        &lt;/struts:submit&gt;
      &lt;/td&gt;
      &lt;td align="right"&gt;
        &lt;struts:reset&gt;
          &lt;struts:message key="button.reset"/&gt;
        &lt;/struts:reset&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;/struts:form&gt;

  &lt;/body&gt;
  &lt;/html&gt;
</pre>

<p>The following items illustrate the key features of form handling in Struts,
based on this example:</p>
<ul>
<li>The <code>taglib</code> directive tells the JSP page compiler where to
    find the <i>tag library descriptor</i> for the Struts tag library.  In
    this case, we are using <code>struts</code> as the prefix that identifies
    tags from this library, but any desired prefix can be used.</li>
<li>This page uses several occurrences of the
    <a href="tags.html#message">message</a> tag to look up internationalized
    message strings from a <code>MessageResources</code> object containing
    all the resources for this application.  For this page to work, the
    following message keys must be defined in these resources:
    <ul>
    <li><b>logon.title</b> - Title of the logon page</li>
    <li><b>prompt.username</b> - A "Username:" prompt string</li>
    <li><b>prompt.password</b> - A "Password:" prompt string</li>
    <li><b>button.submit</b> - "Submit" for the button label</li>
    <li><b>button.reset</b> - "Reset" for the button label</li>
    </ul>
    When the user logs on, the application can store a <code>Locale</code>
    object in the user's session.  This <code>Locale</code> will be used
    to select messages in the appropriate language.  This makes it easy to
    implement giving the user an option to switch languages -- simply change
    the stored <code>Locale</code> object, and all messages are switched
    automatically.</li>
<li>The <a href="tags.html#errors">errors</a> tag displays any error
    messages that have been stored by a business logic component, or nothing
    if no errors have been stored.  This tag will be described further
    below.</li>
<li>The <a href="tags.html#form">form</a> tag renders an HTML
    <code>&lt;form&gt;</code> element, based on the specified attributes.
    It also associates all of the fields within this form with a session
    scoped FormBean that is stored under the key <code>logonForm</code>.
    This bean is used to provide initial values for all of the input
    fields that have names matching the property names of the bean.
    If an appropriate bean is not found, a new one will be created
    automatically, using the specified Java class name.</li>
<li>The <a href="tags:html#text">text</a> tag renders an HTML
    <code>&lt;input&gt;</code> element of type "text".  In this case,
    the number of character positions to occupy on the browser's screen
    has been specified as well.  When this page is executed, the current
    value of the <code>username</code> property of the corresponding bean
    (that is, the value returned by <code>getUsername()</code>).
<li>The <a href="tags.html#password">password</a> tag is used similarly.
    The difference is that the browser will echo asterisk characters,
    instead of the input value, as the user types their password.</li>.
<li>The <a href="tags.html#submit">submit</a> and
    <a href="tags.html#reset">reset</a> tags generate the corresponding
    buttons at the bottom of the form.  The text labels for each button
    are created using <a href="tags.html#message">message</a> tags,
    as with the prompts, so that these values are internationalized.</li>
</ul>


<h4>3.3.2 Input Field Types Supported</h4>

<p>Struts defines tags for all of the following types of input fields,
with hyperlinks to the corresponding reference information.</p>
<ul>
<li><a href="tags.html#checkbox">checkboxes</a></li>
<li><a href="tags.html#hidden">hidden</a> fields</li>
<li><a href="tags.html#password">password</a> input fields</li>
<li><a href="tags.html#radio">radio</a> buttons</li>
<li><a href="tags.html#reset">reset</a> buttons</li>
<li><a href="tags.html#select">select</a> lists with embedded</li>
    <a href="tags.html#option">options</a></li>
<li><a href="tags.html#submit">submit</a> buttons</li>
<li><a href="tags.html#text">text</a> input fields</li>
<li><a href="tags.html#textarea">textareas</a></li>
</ul>
<p>In every
case, a field tag must be nested within a <code>form</code> tag, so that
the field knows what bean to use for initializing displayed values.
</p>


<h4>3.3.3 Other Useful Presentation Tags</h4>

<p>There are several other tags in the Struts library that are useful in
creating user interfaces:</p>
<ul>
<li><a href="tags.html#enumerate">enumerate</a> repeats its tag body once
    for each element of a specified collection (which can be an Enumeration,
    a Hashtable, a Vector, or an array of objects).</li>
<li><a href="tags.html#getProperty">getProperty</a> retrieves the specified
    property from the specified bean, and exposes it as a page scope
    bean to the rest of this page.  Among other things, this is a convenient
    way to access a collection to be used by <code>enumerate</code>.</li>
<li><a href="tags.html#ifAttributeExists">ifAttributeExists</a> evaluates
    its tag body only if a specified attribute exists in a specified scope.
    </li>
<li><a href="tags.html#ifAttributeMissing">ifAttributeMissing</a> evaluates
    its tag body only if a specified attribute does not exist in a
    specified scope.</li>
<li><a href="tags.html#ifParameterEquals">ifParameterEquals</a> evaluates
    its tag body only if a specified request parameter has a specified
    value.</li>
<li><a href="tags.html#ifParameterNotEquals">ifParameterNotEquals</a>
    evaluates its tag body only if a specified request parameter does not
    have a specified value, or is not present.</li>
<li><a href="tags.html#ifParameterNotNull">ifParameterNotNull</a>
    evaluates its tag body only if a specified request parameter is included
    in this request, and has a length greater than zero.</li>
<li><a href="tags.html#ifParameterNull">ifParameterNull</a> evaluates its
    tag body only if a specified request parameter is not included in this
    request, or if it is included with zero length.</li>
<li><a href="tags.html#iterate">iterate</a> repeats its tag body once
    for each element of a specified collection (which can be a Collection,
    an Iterator, a Map, or an array of objects.  This tag supercedes the
    <code>enumerate</code> tag on a Java2 environment.
<li><a href="tags.html#link">link</a> generates a hyperlink, and automatically
    applies URL encoding to maintain session state in the absence of
    cookie support.</li>
<li><a href="tags.html#parameter">parameter</a> renders the specified
    request parameter's value, suitably filtered for characters that are
    sensitive in HTML.</li>
<li><a href="tags.html#property">property</a> displays the named bean
    property within a form -- use it instead of <code>text</code> for
    properties that should be read only.</li>
</ul>


<h4>3.3.4 Automatic Form Validation</h4>

<p>In addition to the form and bean interactions described above, Struts
offers an additional facility if your bean knows how to validate the input
fields it has received.  To utilize this feature, have your bean class
implement the <code>ValidatingActionForm</code> interface, rather than the
<code>ActionForm</code> interface.  A ValidatingActionForm adds an additional
method signature:</p>

<pre>
    public String[] validate()
</pre>

<p>for a method that is called by the controller servlet after the bean
properties have been populated, but before the corresponding action class's
<code>perform()</code> method is invoked.  The <code>validate()</code> method
has the following options:</li>
<ul>
<li>Perform the appropriate validations and find no problems -- Return either
    <code>null</code> or a zero-length String array, and the controller servlet
    will proceed to call the <code>perform()</code> method of the appropriate
    <code>Action</code> class.
<li>Perform the appropriate validations and find problems -- Return a String
    array whose contents are the error message keys (into the application's
    <code>MessageResources</code> bundle) that should be displayed.  The
    controller servlet will store this array as a request attribute suitable
    for use by the <code>&lt;struts:errors&gt;</code> tag, and will forward
    control back to the input form (identified by the <code>inputForm</code>
    property for this <code>ActionMapping</code>.
</ul>

<p>As mentioned earlier, this feature is entirely optional.  If your form bean
implements only the <code>ActionForm</code> interface, the controller servlet
will assume that any required validation is done by the action class.</p>


<h3>3.4 Other Presentation Techniques</h3>

<p>Although the look and feel of your application can be completely constructed
based on the standard capabilities of JSP and the Struts custom tag library,
you should consider employing other techniques that will improve component
reuse, reduce maintenance efforts, and/or reduce errors.  Several options
are discussed in the following sections.</p>


<h4>3.4.1 Application-Specific Custom Tags</h4>

<p>Beyond using the custom tags provided by the Struts library, it is easy
to create tags that are specific to the application you are building, to
assist in creating the user interface.  The example application included with
Struts illustrates this principle by creating the following tags unique to
the implementation of this application:</p>
<ul>
<li><code>checkLogon</code> - Checks for the existence of a particular session
    object, and forwards control to the logon page if it is missing.  This is
    used to catch cases where a user has bookmarked a page in the middle of
    your application and tries to bypass logging on, or if the user's session
    has been timed out.</li>
<li><code>linkSubscription</code> - Generates a hyperlink to a details page
    for a Subscription, which passes the required primary key values as
    request attributes.  This is used when listing the subscriptions associated
    with a user, and providing links to edit or delete them.</li>
<li><code>linkUser</code> - Generates a hyperlink to a details page
    for a User, which passes the required primary key values as
    request attributes.</li>
</ul>

<p>The source code for these tags is in the <code>src/example</code> directory,
in package <code>org.apache.struts.example</code>, along with the other Java
classes that are used in this application.</p>


<h4>3.4.2 Page Composition With Includes</h4>

<p>Creating the entire presentation of a page in one JSP file (with custom
tags and beans to access the required dynamic data) is a very common design
approach, and was employed in the example application included with Struts.
However, many applications require the display of multiple logically distinct
portions of your application together on a single page.</p>

<p>For example, a portal application might have some or all of the following
functional capabilities available on the portal's "home" page:</p>
<ul>
<li>Access to a search engine for this portal.</li>
<li>One or more "news feed" displays, with the topics of interest customized
    from the user's registration profile.</li>
<li>Access to discussion topics related to this portal.</li>
<li>A "mail waiting" indicator if your portal provides free email
    accounts.</li>
</ul>

<p>The development of the various segments of this site is easier if you
can divide up the work, and assign different developers to the different
segments.  Then, you can use the <i>include</i> capability of JavaServer Pages
technology to combine the results into a single result page.  There are two
types of <i>include</i> available, depending on when you want the combination
of output to occur:</p>
<ul>
<li>The include <i>directive</i> (<code>&lt;%@ include file="xxxxx"
    %&gt;</code>) is processed when the JSP page is compiled.  It is
    useful when you are including HTML code that will not need to change
    at request time.  It treats the text being included as static text,
    much like the <code>#include</code> directive in C or C++.</li>
<li>The include <i>action</i> (<code>&lt;jsp:include page="xxxxx"
    flush="true" /&gt;</code>) is processed at request time, and is handled
    transparently by the server.  Among other things, that means you
    can conditionally perform the include by nesting it within a tag
    like <a href="tags.html#ifParameterEquals">ifParameterEquals</a>.</li>
</ul>


<h4>3.4.3 Image Rendering Components</h4>

<p>Some applications require dynamically generated images, like the price
charts on a stock reporting site.  Two different approaches are commonly used
to meet these requirements:</p>
<ul>
<li>Render a hyperlink with a URL that executes a servlet request.  The
    servlet will use a graphics library to render the graphical image,
    set the content type appropriately (such as to <code>image/gif</code>),
    and send back the bytes of that image to the browser, which will display
    them just as if it had received a static file.</li>
<li>Render the HTML code necessary to download a Java applet that creates
    the required graph.  You can configure the graph by setting appropriate
    initialization parameters for the applet in the rendered code, or you
    can have the applet make its own connection to the server to receive
    these parameters.</li>
</ul>


<h2>4. Building the Controller Components</h2>


<h3>4.1 Overview</h3>

<p>Now that we understand how to construct the Model and View components
of your application, it is time to focus on the <code>Controller</code>
components.  Struts includes a servlet that implements the primary function
of mapping a request URI to an <code>Action</code> class.  Therefore, your
primary responsibilities related to the Controller are:</p>
<ul>
<li>Write an <code>Action</code> class (that is, an implementation of the
    <code>Action</code> interface) for each logical request
    that may be received.</li>
<li>Write an <code>ActionMapping</code> class (that is, an implementation
    of the <code>ActionMapping</code> interface) that defines the class
    names and other information associated with each possible
    mapping.</li>
<li>Write the action mapping configuration file (in XML) that is used
    to configure the controller servlet.</li>
<li>Update the web application deployment descriptor file (in XML)
    for your application to include the necessary Struts components.</li>
<li>Add the appropriate Struts components to your application.</li>
</ul>


<h3>4.2 Action Classes</h3>

<p>The <code>Action</code> interface defines a single method that must be
implemented by an <code>Action</code> class, as follows:</p>
<pre>
    public ActionForward perform(ActionServlet servlet,
                                 ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response)
      throws IOException, ServletException;
</pre>

<p>The goal of an <code>Action</code> class is to process this request,
and then to return an <code>ActionForward</code> object that identifies
the JSP page (if any) to which control should be forwarded to generate
the corresponding response.  In the <i>Model 2</i> design pattern,
a typical <code>Action</code> class will implement the following
logic in its <code>perform()</code> method:
<ul>
<li>Validate the current state of the user's session (for example, checking
    that the user has successfully logged on).  If the <code>Action</code>
    class finds that no logon exists, the request should be forwarded to
    the JSP page that displays the username and password prompts for
    logging on.  This could occur because a user tried to enter your
    application "in the middle" (say, from a bookmark), or because the
    session has timed out, and the servlet container created a new one.</li>
<li>If validation has not yet occurred (due to the use of a form bean
    that implements the <code>ValidatingActionForm</code> interface),
    validate the form bean properties as necessary.  If a problem is found,
    store the appropriate error message keys as a request attribute, and
    forward control back to the input form so that the errors can be
    corrected.</li>
<li>Perform the processing required to deal with this request (such as
    saving a row into a database).  This can be done by code embedded within
    the <code>Action</code> class itself, but should generally be performed
    by calling an appropriate method of a business logic bean.
<li>Update the server-side objects that will be used to create the next
    page of the user interface (typically request scope or session scope
    beans, depending on how long you need to keep these items available).</li>
<li>Return an appropriate <code>ActionForward</code> object that identifies
    the JSP page to be used to generate this response, based on the newly
    updated beans.  Typically, you will acquire a reference to such an
    object by calling <code>findForward()</code> on either the
    <code>ActionMapping</code> object you received (if you are using a
    logical name local to this mapping), or on the controller servlet
    itself (if you are using a logical name global to the application).</li>
</ul>

<p>Design issues to remember when coding <code>Action</code> classes
include the following:</p>
<ul>
<li>The controller servlet creates only one instance of your
    <code>Action</code> class, and uses it for all requests.  Thus,
    you need to code your <code>Action</code> class so that it operates
    correctly in a multi-threaded environment, just as you must code a
    servlet's <code>service()</code> method safely.</li>
<li>The most important principle that aids in thread-safe coding is to
    use only local variables, not instance variables, in your
    <code>Action</code> class.  Local variables are created on a
    stack that is assigned (by your JVM) to each request thread, so
    there is no need to worry about sharing them.</li>
<li>The beans that represent the Model of your system may throw exceptions
    due to problems accessing databases or other resources.
    You should trap all such exceptions
    in the logic of your <code>perform()</code> method, and log them to the
    application logfile (along with the corresponding stack trace) by
    calling:
    <pre>
	servlet.log("Error message text", exception);
    </pre></li>
<li>As a general rule, allocating scarce resources and keeping them across
    requests from the same user (in the user's session) can cause
    scalability problems.  You should strive to release such resources
    (such as database connections) prior to forwarding control to the
    appropriate View component -- even if a bean method you have called
    throws an exception.</li>
</ul>

<p>In addition, you will want to guard against <code>Action</code> classes
that are too large.  The easiest way for this to happen is to embed your
functional logic in the <code>Action</code> class itself, rather than
coding it in separate business logic beans.  Besides making the
<code>Action</code> class itself hard to understand and maintain, this
approach also makes it harder to re-use the business logic code, because
it is embedded inside a component (the <code>Action</code> class) that
is tied to being executed in a web application environment.</p>

<p>The example application included with Struts stretches this design
principle somewhat, because the business logic itself is embedded in the
<code>Action</code> classes.  This should be considered something of a
bug in the design of the sample application, rather than an intrinsic
feature of the Struts architecture, or an approach to be emulated.</p>


<h3>4.3 The ActionMapping Implementation</h3>

<p>In order to operate successfully, the Struts controller servlet needs
to know several things about how each request URI should be mapped to an
appropriate <code>Action</code> class.  The required knowledge has been
encapsulated in a Java interface named <code>ActionMapping</code>, which
has the following properties:</p>
<ul>
<li><b>actionClass</b> - The fully qualified Java class name of the
    <code>Action</code> class used for this mapping.  The first time
    a particular mapping is used, an instance of this class will be
    created and saved for reuse later.</li>
<li><b>formAttribute</b> - The name of the session scope bean under
    which the current <code>ActionForm</code> for this mapping is stored.
    If this property is not defined, no <code>ActionForm</code> will be
    used.</li>
<li><b>formClass</b> - The fully qualified Java class name of the
    <code>ActionForm</code> class used for this mapping.  If you are
    using the support for form beans, an instance of this class will be
    created and saved (in the current user's session) automatically
    whenever necessary.</li>
<li><b>path</b> - The request URI path that is matched to select this
    mapping.  See below for examples of how matching works.</li>
</ul>

<p>Struts includes a convenient implementation of the
<code>ActionMapping</code> interface, in a class named
<code>ActionMappingBase</code>.  If you do not need to define any
additional properties for your own mappings, feel free to use
this class as your <code>ActionMapping</code> class, configured as
described in the following section.  However, it is also possible to
define an <code>ActionMapping</code> implementation (perhaps extending the
<code>ActionMappingBase</code> class) that contains additional properties.
The controller servlet knows how to configure these custom properties
automatically, because it uses the Struts Digester module to read the
configuration file.</p>

<p>In the example application included with Struts, this feature is used to
define two additional properties:</p>
<ul>
<li><b>failure</b> - The context-relative URI to which control should be
    forwarded if the Action class detects some sort of problem with the
    input fields it received.  This will typically be the name of the
    JSP page from which the request was sent, which will cause the form
    to be redisplayed (with the error messages set by the Action Class
    and the most recent input values from the ActionForm bean).</li>
<li><b>success</b> - The context-relative URI to which control should be
    forwarded if the Action class successfully performs the required
    function.  This will typically be the name of a JSP page that prepares
    the next page of the conversation flow for this application.</li>
</ul>

<p>Using these two extra properties, the <code>Action</code> classes in the
example application are almost totally independent of the actual names of
the JSP pages that are used by the page designers.  The pages can be renamed
(for example) during a redesign, with negligible impact on the
<code>Action</code> classes themselves.  If the names of the "next" JSP
pages were hard coded into the <code>Action</code> classes, all of these
classes would also need to be modified.</p>


<h3>4.4 The Action Mappings Configuration File</h3>

<p>How does the controller servlet learn about the mappings you want?  It
would be possible (but tedious) to write a small Java class that simply
instantiated new <code>ActionMapping</code> instances, and called all of
the appropriate setter methods.  To make this process easier, Struts includes
a Digester module that is capable of reading an XML-based description of
the desired mappings, creating the appropriate objects along the way.
See the <a href="api/index.html">API documentation</a> for more information
about Digester.</p>

<p>The developer's responsibility is to create an XML file named
<code>action.xml</code>, and place it in the WEB-INF directory of your
application.  (Note that no DTD for this file is required, because the
actual attributes used can be different for different users.)  The
outermost XML element must be <code>&lt;action-mappings&gt;</code>, and
within this element are nested zero or more <code>&lt;action&gt;</code>
elements -- one per mapping that you wish to define.</p>

<p>The <code>action.xml</code> file from the example application includes
the following mapping entry for the "log on" function, which we will use
to illustrate the requirements:</p>
<pre>
  &lt;action-mappings&gt;

    &lt;forward name="logon" path="/logon.jsp"/&gt;

    &lt;action   path="/logon"
       actionClass="org.apache.struts.example.LogonAction"
     formAttribute="logonForm"
         formClass="org.apache.struts.example.LogonForm"
         inputForm="/logon.jsp"&gt;
      &lt;forward name="success" path="/mainMenu.jsp"/&gt;
    &lt;/action&gt;

  &lt;/action-mappings&gt;
</pre>

<p>As you can see, this mapping matches the path <code>/logon</code> (actually,
because the example application uses extension mapping, the request URI you
specify in a JSP page would end in <code>/logon.do</code>).  When a request
that matches this path is received, an instance of the <code>LogonAction</code>
class will be created (the first time only) and used.  The controller servlet
will look for a session scoped bean under key <code>logonForm</code>, creating
and saving a bean of the specified class if needed.</p>

<p>This <code>action</code> element also defines a logical name "success",
which is used within the <code>LogonAction</code> class to identify the
page to be used when a user successfully logs on.  Using a logical name like
this allows the action class to be insulated from any changes in the page
names that might occur due to a site redesign.</p>

<p>There is a second <code>forward</code> element that is declared outside
of any <code>action</code>, so it is globally available to all actions.  In
this case, it defines a logical name for the logon page.  In your action
code, when you call <code>mapping.findForward()</code>, Struts first looks at
the locally defined logical names for this action.  If it does not find one,
it then searches the global definitions for you automatically.</p>


<h3>4.5 The Web Application Deployment Descriptor</h3>

<p>The final step in setting up the application is to configure the application
deployment descriptor (stored in file <code>WEB-INF/web.xml</code>) to include
all the Struts components that are required.  Using the deployment descriptor
for the example application as a guide, we see that the following entries need
to be created or modified.</p>


<h4>4.5.1 Configure the Action Servlet Instance</h4>

<p>Add an entry defining the action servlet itself, along with the appropriate
initialization parameters.  Such an entry might look like this:
<pre>
    &lt;servlet&gt;
      &lt;servlet-name&gt;action&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;application&lt;/param-name&gt;
        &lt;param-value&gt;org.apache.struts.example.ApplicationResources&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;config&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/action.xml&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;2&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;mapping&lt;/param-name&gt;
        &lt;param-value&gt;org.apache.struts.example.ApplicationMapping&lt;/param-value&gt;
      &lt;/init-param&gt;
      &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
</pre>

<p>The initialization parameters supported by the controller servlet are
described below, which is copied from the <a href="api/index.html">Javadocs</a>
for the <code>ActionServlet</code> class.  Square brackets describe the
default values that are assumed if you do not provide a value for that
initialization parameter.</p>
<ul>
<li><strong>application</strong> - Java class name of the application
    resources bundle base class.  [NONE].
<li><strong>config</strong> - Context-relative path to the XML resource
    containing our configuration information.  [/WEB-INF/action.xml]
<li><strong>debug</strong> - The debugging detail level for this
    servlet, which controls how much information is logged.  [0]
<li><strong>digester</strong> - The debugging detail level for the Digester
    we utilize in <code>initMapping()</code>, which logs to System.out
    instead of the servlet log.  [0]
<li><strong>forward</strong> - The Java class name of the ActionForward
    implementation to use [org.apache.struts.action.ActionForward]
<li><strong>mapping</strong> - The Java class name of the ActionMapping
    implementation to use [org.apache.struts.action.ActionMappingBase]
<li><strong>nocache</strong> - If set to <code>true</code>, add HTTP headers
    to every response intended to defeat browser caching of any response we
    generate or forward to.  [false]
<li><strong>null</strong> - If set to <code>true</code>, set our application
    resources to return <code>null</code> if an unknown message key is used.
    Otherwise, an error message including the offending message key will
    be returned.  [true]
</ul>


<h4>4.5.2 Configure the Action Servlet Mapping</h4>

<p>There are two common approaches to defining the URLs that will
be processed by the controller servlet -- prefix matching and extension
matching.  An appropriate mapping entry for each approach will be
described below.</p>

<p>Prefix matching means that you want all URLs that start (after the context
path part) with a particular value to be passed to this servlet.  Such an
entry might look like this:</p>
<pre>
    &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;action&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/execute/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>
<p>which means that a request URI to match the <code>/logon</code> path
described earlier might look like this:
<pre>
    http://www.mycompany.com/myapplication/execute/logon
</pre>
<p>where <code>/myapplication</code> is the context path under which your
application is deployed.</p>

<p>Extension mapping, on the other hand, matches request URIs to the action
servlet based on the fact that the URI ends with a period followed by a
defined set of characters.  For example, the JSP processing servlet is mapped
to the <code>*.jsp</code> pattern so that it is called to process every
JSP page that is requested.  To use the <code>*.do</code> extension (which
implies "do something"), the mapping entry would look like this:
<pre>
    &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;action&lt;/servlet-name&gt;
      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>
<p>and a request URI to match the <code>/logon</code> path described
earlier might look like this:
<pre>
    http://www.mycompany.com/myapplication/logon.do
</pre>


<h4>4.5.3 Configure the Struts Tag Library</h4>

<p>Next, you must add an entry defining the Struts tag library.  The entry
should look like this:
<pre>
  &lt;taglib&gt;
    &lt;taglib-uri&gt;/WEB-INF/struts.tld&lt;/taglib-uri&gt;
    &lt;taglib-location&gt;/WEB-INF/struts.tld&lt;/taglib-location&gt;
  &lt;/taglib&gt;
</pre>

<p>which tells the JSP system where to find the tag library descriptor
for this library (in your application's WEB-INF directory, instead of
out on the Internet somewhere).</p>


<h4>4.5.4 Add Struts Components To Your Application</h4>

<p>To use Struts when your application executes, you must copy the
<code>struts.tld</code> file to your <code>WEB-INF</code> directory,
and the <code>struts.jar</code> file to your <code>WEB-INF/lib</code>
directory.</p>

</body>
</html>
