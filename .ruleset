<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="project rulset" include="false">
    <description>Generated by PMD Plugin for Eclipse</description>
    <rule name="ReturnFromFinallyBlock"
        message="Avoid returning from a finally block"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid returning from a finally block - this can
            discard exceptions.       </description>
        <example><![CDATA[
  
public class Bar {
 public String bugga() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //TryStatement[@Finally='true']/Block[position() = last()]//ReturnStatement
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="AvoidReassigningParametersRule"
        message="Avoid reassigning parameters such as &apos;&apos;{0}&apos;&apos;"
        class="net.sourceforge.pmd.rules.AvoidReassigningParametersRule" include="false">
        <description> Reassigning values to parameters is a questionable
            practice.  Use a temporary local variable instead.     </description>
        <example><![CDATA[

public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="OverrideBothEqualsAndHashcodeRule"
        message="Ensure you override both equals() and hashCode()"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Override both public boolean
            Object.equals(Object other), and public int
            Object.hashCode(), or override neither.  Even if you are
            inheriting a hashCode() from a parent class, consider
            implementing hashCode and explicitly delegating to your
            superclass.       </description>
        <example><![CDATA[
  
  // this is bad
  public class Bar {
      public boolean equals(Object o) {
          // do some comparison
      }
  }

  // and so is this
  public class Baz {
      public int hashCode() {
          // return some hash value
      }
  }

  // this is OK
  public class Foo {
      public boolean equals(Object other) {
          // do some comparison
      }
      public int hashCode() {
          // return some hash value
      }
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
      //ClassDeclaration//MethodDeclarator
      [
      (@Image = 'equals'
          and count(FormalParameters/*) = 1
          and not(//MethodDeclarator[count(FormalParameters/*) = 0]
          [@Image = 'hashCode'])
       or
      (@Image='hashCode'
          and count(FormalParameters/*) = 0
          and not(//MethodDeclarator[count(FormalParameters//Type/Name
          [@Image = 'Object']) = 1 or @Image = 'java.lang.Object']
          [@Image = 'equals']))
      )]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="SimplifyBooleanExpressions"
        message="Avoid unnecessary comparisons in boolean expressions"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid unnecessary comparisons in boolean
            expressions - this makes simple code seem complicated.       </description>
        <example><![CDATA[
  
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
//Expression/ConditionalAndExpression/InstanceOfExpression[position()>1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="StringToString"
        message="Avoid calling toString() on String objects; this is unnecessary"
        class="net.sourceforge.pmd.rules.StringToStringRule" include="false">
        <description>     Avoid calling toString() on String objects;
            this is unnecessary     </description>
        <example><![CDATA[

public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="EmptyTryBlock" message="Avoid empty try blocks"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid empty try blocks - what&apos;s the point?       </description>
        <example><![CDATA[
  
  // this is bad
  public void bar() {
      try {
      } catch (Exception e) {
          e.printStackTrace();
      }
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //TryStatement/Block[1][count(*) = 0]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="UnusedFormalParameter"
        message="Avoid unused formal parameters such as &apos;&apos;{0}&apos;&apos;"
        class="net.sourceforge.pmd.rules.UnusedFormalParameterRule" include="false">
        <description> Avoid passing parameters to methods and then not
            using those parameters.     </description>
        <example><![CDATA[

public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="FinalizeShouldBeProtected"
        message="If you override finalize(), make it protected"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>       If you override finalize(), make it
            protected.  Otherwise, subclasses           may not called
            your implementation of finalize.       </description>
        <example><![CDATA[
  
public class Foo {
 public void finalize() {
  // do something
 }
}
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="UnnecessaryReturn"
        message="Avoid unnecessary return statements"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid unnecessary return statements       </description>
        <example><![CDATA[
  
  // this is bad
  public void bar() {
      int x = 42;
      return;
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
//ReturnStatement
 [parent::Statement
  [parent::BlockStatement
   [parent::Block
    [parent::MethodDeclaration/ResultType[@Void='true']
    ]
   ]
  ]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="AvoidDeeplyNestedIfStmts"
        message="Deeply nested if..then statements are hard to read"
        class="net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule" include="false">
        <description>     Deeply nested if..then statements are hard to
            read.     </description>
        <example><![CDATA[

public class Foo {
 public void bar() {
  int x=2;
  int y=3;
  int z=4;
  if (x>y) {
   if (y>z) {
    if (z==x) {
     // this is officially out of control now
    }
   }
  }
 }
}

    ]]></example>
        <priority>4</priority>
        <properties>
            <property name="problemDepth" value="3"/>
        </properties>
    </rule>
    <rule name="UnnecessaryConversionTemporaryRule"
        message="Avoid unnecessary temporaries when converting primitives to Strings"
        class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporaryRule" include="false">
        <description>       Avoid unnecessary temporaries when
            converting primitives to Strings       </description>
        <example><![CDATA[
  
    public String convert(int x) {
      // this wastes an object
      String foo = new Integer(x).toString();
      // this is better
      return Integer.toString(x);
    }
  
      ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="LooseCouplingRule"
        message="Avoid using implementation types like &apos;&apos;{0}&apos;&apos;; use the interface instead"
        class="net.sourceforge.pmd.rules.design.LooseCouplingRule" include="false">
        <description>     Avoid using implementation types (i.e.,
            HashSet); use the interface (i.e, Set) instead     </description>
        <example><![CDATA[

import java.util.*;
public class Bar {

 // should be "private List list"
 private ArrayList list = new ArrayList();

 // should be "public Set getFoo()"
 public HashSet getFoo() {
  return new HashSet();
 }
}


    ]]></example>
        <priority>5</priority>
        <properties/>
    </rule>

    <rule name="AssignmentInOperandRule"
        message="Avoid assigments in operands"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid assigments in operands; this can make code
            more complicated and harder to read.   </description>
        <example><![CDATA[
  
  public class Foo {
   public void bar() {
int x = 2;
if ((x = getX()) == 3) {
 System.out.println("3!");
}
   }
   private int getX() {
return 3;
   }
  }

  
  ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//*[name()='WhileStatement' or name()='IfStatement'][Expression//AssignmentOperator]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="StringInstantiation"
        message="Avoid instantiating String objects; this is usually unnecessary."
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>     Avoid instantiating String objects; this is
            usually unnecessary.     </description>
        <example><![CDATA[

public class Foo {
 private String bar = new String("bar"); // just do a String bar = "bar";
}

    ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                   
    //AllocationExpression[Name/@Image='String'][count(.//Expression) < 2][not(ArrayDimsAndInits)]
                    
               ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="EmptyIfStmt"
        message="Avoid empty &apos;if&apos; statements"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Empty If Statement finds instances where a
            condition is checked but nothing is done about it.     </description>
        <example><![CDATA[
  
    if (absValue < 1) {
       // not good
    }
  
       ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
                    //IfStatement/Statement/Block[count(*) = 0]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="EmptyCatchBlock" message="Avoid empty catch blocks"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Empty Catch Block finds instances where an
            exception is caught,   but nothing is done.  In most
            circumstances, this swallows an exception   which should
            either be acted on or reported.       </description>
        <example><![CDATA[
  
    public void doSomething() {
      try {
        FileInputStream fis = new FileInputStream("/tmp/bugger");
      } catch (IOException ioe) {
          // not good
      }
    }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //TryStatement
    [@Catch='true']
    [FormalParameter/Type/Name[@Image != 'InterruptedException']]
    [FormalParameter/Type/Name[@Image != 'CloneNotSupportedException']]
    /Block[position() > 1]
    [count(*) = 0]
    [../@Finally='false' or following-sibling::Block]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="ConstructorCallsOverridableMethodRule"
        message="Avoid calls to overridable methods during construction"
        class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethodRule" include="false">
        <description>       Calling overridable methods during
            construction poses a risk of invoking methods on an
            incompletely constructed object.  This situation can be
            difficult to discern.       It may leave the sub-class
            unable to construct its superclass or forced to
            replicate the construction process completely within itself,
            losing the ability to call       super().  If the default
            constructor contains a call to an overridable method,
            the subclass may be completely uninstantiable.       </description>
        <example><![CDATA[
  
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name.toUpperCase();
      }
    }
  
      ]]></example>
        <priority>5</priority>
        <properties/>
    </rule>
    <rule name="SignatureDeclareThrowsException"
        message="A signature (constructor or method) shouldn&apos;t have Exception in throws declaration"
        class="net.sourceforge.pmd.rules.strictexception.ExceptionSignatureDeclaration" include="false">
        <description> It is unclear which exceptions that can be thrown
            from the methods. It might be difficult to document and
            understand the vague interfaces. Use either a class derived
            from RuntimeException or a checked exception.       </description>
        <example><![CDATA[
                
public void methodThrowingException() throws Exception {
}
                
      ]]></example>
        <priority>5</priority>
        <properties/>
    </rule>
    <rule name="UnusedPrivateField"
        message="Avoid unused private fields such as &apos;&apos;{0}&apos;&apos;"
        class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule" include="false">
        <description> Unused Private Field detects when a private field
            is declared that is not used by the class.     </description>
        <example><![CDATA[

public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;

  public int addOne() {
    return j++;
  }
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="ForLoopShouldBeWhileLoop"
        message="This for loop could be simplified to a while loop"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>       Some for loops can be simplified to while
            loops - this makes them more concise.       </description>
        <example><![CDATA[
  
  public class Foo {
      void bar() {
          for (;true;) true; // No Init or Update part, may as well be: while (true)
      }
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                
    //ForStatement[count(*) > 1][not(ForInit)][not(ForUpdate)]
                
            ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="SimplifyBooleanReturnsRule"
        message="Avoid unnecessary if..then..else statements when returning a boolean"
        class="net.sourceforge.pmd.rules.SimplifyBooleanReturnsRule" include="false">
        <description> Avoid unnecessary if..then..else statements when
            returning a boolean     </description>
        <example><![CDATA[

public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="AvoidDuplicateLiterals"
        message="The same String literal appears {0} times in this file; the first occurrence is on line {1}"
        class="net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule" include="false">
        <description> Code containing duplicate String literals can
            usually be improved by declaring the String as a constant
            field.     </description>
        <example><![CDATA[

public class Foo {
 private void bar() {
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
 }
 private void buz(String x) {}
}

    ]]></example>
        <priority>5</priority>
        <properties>
            <property name="threshold" value="4"/>
        </properties>
    </rule>
    <rule name="AvoidCatchingThrowable"
        message="A catch statement should never catch throwable since it includes errors"
        class="net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable" include="false">
        <description> This is dangerous because if a java.lang.Error,
            for example OutOfMemmoryError, occurs then it will be
            caught. The container should handle java.lang.Error. If
            application code will catch them, try to log them (which
            will probably fail) and continue silently the situation will
            not be desirable.       </description>
        <example><![CDATA[
                
SimpleDateFormat sdf = null;
try {
    sdf = new SimpleDateFormat("yyyy-MM-dd");
} catch (Throwable th) {  //Should not catch throwable
    th.printStackTrace();
}
                
      ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="UnusedPrivateMethod"
        message="Avoid unused private methods such as &apos;&apos;{0}&apos;&apos;"
        class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule" include="false">
        <description> Unused Private Method detects when a private
            method is declared but is unused.     </description>
        <example><![CDATA[

public class Something {
 private void foo() {} // unused
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="FinalFieldCouldBeStatic"
        message="This final field could be made static"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>       If a final field is assigned to a
            compile-time constant, it could be           made static,
            thus saving overhead in each object       </description>
        <example><![CDATA[
  
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  
      ]]></example>
        <priority>5</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//FieldDeclaration
 [not (ancestor::InterfaceDeclaration)]
  [@Final='true' and @Static='false']
   /VariableDeclarator/VariableInitializer/Expression
    /ConditionalAndExpression/InstanceOfExpression
     /PrimaryExpression/PrimaryPrefix/Literal
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="UseSingletonRule"
        message="All methods are static.  Consider using Singleton instead."
        class="net.sourceforge.pmd.rules.design.UseSingletonRule" include="false">
        <description>     If you have a class that has nothing but
            static methods, consider making it a Singleton     </description>
        <example><![CDATA[

public class MaybeASingleton {
    public static void foo() {
     // etc
    }
    public static void bar() {
     // etc
    }
}

    ]]></example>
        <priority>5</priority>
        <properties/>
    </rule>
    <rule name="UnusedModifier"
        message="Avoid modifiers which are implied by the context"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>      Fields in interfaces are automatically public
            static final, and      methods are public abstract.
            Classes or interfaces nested in an interface are
            automatically public      and static (all nested interfaces
            are automatically static).      For historical reasons,
            modifiers which are implied by the context      are accepted
            by the compiler, but are superfluous.      </description>
        <example><![CDATA[
 
    public interface Foo {
     public abstract void bar(); // both abstract and public are ignored by the compiler
     public static final int X = 0; // public, static, and final all ignored
     public static class Bar {} // public, static ignored
     public static interface Baz {} // ditto
    }
    public class Bar {
     public static interface Baz {} // static ignored
    }
 
     ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
    //UnmodifiedInterfaceDeclaration//MethodDeclaration[@Public = 'true' or @Abstract = 'true']
|   //UnmodifiedInterfaceDeclaration//FieldDeclaration[@Public = 'true' or @Static = 'true' or @Final = 'true']
|   //UnmodifiedInterfaceDeclaration//NestedClassDeclaration[@Public = 'true' or @Static = 'true']
|   //UnmodifiedInterfaceDeclaration//NestedInterfaceDeclaration[@Public = 'true' or @Static = 'true']
|   //UnmodifiedClassDeclaration//NestedInterfaceDeclaration[@Static = 'true']
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="EmptyWhileStmt"
        message="Avoid empty &apos;while&apos; statements"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Empty While Statement finds all instances where
            a while statement   does nothing.  If it is a timing loop,
            then you should use Thread.sleep() for it; if   it&apos;s a
            while loop that does a lot in the exit expression, rewrite
            it to make it clearer.        </description>
        <example><![CDATA[
  
  while (a == b) {
    // not good
  }
  
       ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //WhileStatement/Statement/Block[count(*) = 0]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="EmptySynchronizedBlock"
        message="Avoid empty synchronized blocks"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid empty try blocks - what&apos;s the point?       </description>
        <example><![CDATA[
  
  // this is bad
  public void bar() {
      synchronized (this) {}
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //SynchronizedStatement/Block[1][count(*) = 0]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="UnusedLocalVariable"
        message="Avoid unused local variables such as &apos;&apos;{0}&apos;&apos;"
        class="net.sourceforge.pmd.rules.UnusedLocalVariableRule" include="false">
        <description> Unused Local Variables detects when a variable is
            declared, but not used (except for possibly initial
            assignment)     </description>
        <example><![CDATA[

public int doSomething() {
  int i = 5; // Unused
  int j = 6;
  j += 3;
  return j;
}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="SwitchDensity"
        message="A high ratio of statements to labels in a switch statement.  Consider refactoring."
        class="net.sourceforge.pmd.rules.design.SwitchDensityRule" include="false">
        <description>  A high ratio of statements to labels in a switch
            statement implies that the switch  statement is doing too
            much work.  Consider moving the statements either into new
            methods, or creating subclasses based on the switch
            variable.       </description>
        <example><![CDATA[
 
   public class Foo {
     private int x;
     public void bar() {
       switch (x) {
         case 1: {
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           break;
         }

         case 2: {
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           break;
         }
       }
     }
   }
 
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="minimum" value="10"/>
        </properties>
    </rule>
    <rule name="SwitchStmtsShouldHaveDefault"
        message="Switch statements should have a default label"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>     Switch statements should have a default label.     </description>
        <example><![CDATA[

public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}

    ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //SwitchStatement[not(SwitchLabel[count(*) = 0])]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="ExceptionTypeChecking"
        message="The catch clause shouldn&apos;t check the exception type - catch several exceptions instead"
        class="net.sourceforge.pmd.rules.strictexception.ExceptionTypeChecking" include="false">
        <description> At some places Exception is caught and then a
            check with instanceof is performed. This result in messy
            code. It&apos;s considered better to catch all the specific
            exceptions instead.       </description>
        <example><![CDATA[
                
SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
try {
    returnString = sdf.format(value);
} catch (Exception ex) {
    /* BAD STUFF !!!*/
    if (ex instanceof NumberFormatException) {
        System.out.println("NumberFormat exception!!!");
    }
    if (ex instanceof IllegalArgumentException) {
        System.out.println("illegal argument...!!!");
    }
}
                
      ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="UnnecessaryConstructorRule"
        message="Avoid unnecessary constructors - the compiler will generate these for you"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Unnecessary constructor detects when a
            constructor is not necessary; i.e., when there&apos;s only
            one constructor,   it&apos;s public, has an empty body, and
            takes no arguments.       </description>
        <example><![CDATA[
  
  public class Foo {
   public Foo() {}
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//UnmodifiedClassDeclaration
/ClassBody[count(ClassBodyDeclaration/ConstructorDeclaration)=1]
/ClassBodyDeclaration/ConstructorDeclaration
[@Public='true']
[not(FormalParameters/*)]
[not(BlockStatement)]
[not(NameList)]
[count(ExplicitConstructorInvocation/Arguments/ArgumentList/Expression)=0]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="OnlyOneReturn"
        message="A method should have only one exit point, and that should be the last statement in the method"
        class="net.sourceforge.pmd.rules.design.OnlyOneReturnRule" include="false">
        <description>      A method should have only one exit point, and
            that should be the last statement in the method.      </description>
        <example><![CDATA[
 
 public class OneReturnOnly1 {
  public void foo(int x) {
   if (x > 0) {
    return "hey";   // oops, multiple exit points!
   }
   return "hi";
  }
 }
 
     ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule name="EmptySwitchStatements"
        message="Avoid empty switch statements"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>       Avoid empty switch statements.       </description>
        <example><![CDATA[
  
  public class Foo {
   public void bar() {
    int x = 2;
    switch (x) {
     // once there was code here
     // but it's been commented out or something
    }
   }
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //SwitchStatement[count(*) = 1]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="EmptyFinallyBlock" message="Avoid empty finally blocks"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>   Avoid empty finally blocks - these can be
            deleted.       </description>
        <example><![CDATA[
  
  // this is bad
  public void bar() {
      try {
          int x=2;
      } finally {
      }
  }
  
      ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //TryStatement[@Finally='true']/Block[position() = last()]
      [count(*) = 0]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="BooleanInstantiation"
        message="Avoid instantiating Boolean objects; you can usually invoke Boolean.valueOf() instead."
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>    Avoid instantiating Boolean objects, instead
            use Boolean.valueOf().    </description>
        <example><![CDATA[
   
public class Foo {
 private Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE or Boolean.valueOf(true);
}
   
   ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//AllocationExpression[not (ArrayDimsAndInits)
                       and
                       (Name/@Image='Boolean'
                       or
                       Name/@Image='java.lang.Boolean')]

              ]]></value>
            </property>
        </properties>
    </rule>
    <rule name="JumbledIncrementer"
        message="Avoid modifying an outer loop incrementer in an inner loop for update expression"
        class="net.sourceforge.pmd.rules.XPathRule" include="false">
        <description>      Avoid jumbled loop incrementers - it&apos;s
            usually a mistake, and it&apos;s confusing even if it&apos;s
            what&apos;s intended.      </description>
        <example><![CDATA[
 
 public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
     ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                 
//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
             ]]></value>
            </property>
        </properties>
    </rule>
<rule name="DontImportJavaLang"
            message="Avoid importing anything from the package 'java.lang'"
            class="net.sourceforge.pmd.rules.XPathRule"
            include="false">
         <description>
            
            
            
            
            
    Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    
         
         
         
         
         </description>
         <example>
<![CDATA[





// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}





]]>
         </example>
         <priority>
            4
         </priority>
         <properties>
            <property name="xpath">
               <value>
<![CDATA[





//ImportDeclaration
 [starts-with(Name/@Image, 'java.lang')]
 [not(starts-with(Name/@Image, 'java.lang.ref'))]
 [not(starts-with(Name/@Image, 'java.lang.reflect'))]
                




]]>
               </value>
            </property>
         </properties>
      </rule>
<rule name="JUnitSpelling"
            message="You may have misspelled a JUnit framework method (setUp or tearDown)"
            class="net.sourceforge.pmd.rules.XPathRule"
            include="false">
         <description>
            
            
            
            
            
    Some JUnit framework methods are easy to misspell.
    
         
         
         
         
         </description>
         <example>
<![CDATA[





import junit.framework.*;
public class Foo extends TestCase {
 public void setup() {} // oops, should be setUp
 public void TearDown() {} // oops, should be tearDown
}





]]>
         </example>
         <priority>
            3
         </priority>
         <properties>
            <property name="xpath">
               <value>
<![CDATA[





//MethodDeclarator[(not(@Image = 'setUp') 
 and translate(@Image, 'SETuP', 'setUp') = 'setUp') 
 or (not(@Image = 'tearDown') 
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
              




]]>
               </value>
            </property>
         </properties>
      </rule>
<rule name="ExcessivePublicCountRule"
            message="A high number of public methods and attributes in an object can indicate the class may need to be broken up for exhaustive testing may prove difficult."
            class="net.sourceforge.pmd.rules.ExcessivePublicCountRule"
            include="false">
         <description>
            
            
            
            
            
    A large amount of public methods and attributes declared in an object can indicate the class may need
    to be broken up as increased effort will be required to thoroughly test such a class.
    
         
         
         
         
         </description>
         <example>
<![CDATA[






    public class Foo {
    public String value;
    public Bar something;
    public Variable var;
    //more public attributes
    public void doWork() {}
    public void doMoreWork() {}
    public void doWorkAgain() {}
    public void doWorking() {}
    public void doWorkIt() {}
    public void doWorkingAgain() {}
    public void doWorkAgainAgain() {}
    public void doWorked() {}

    }
    




]]>
         </example>
         <priority>
            3
         </priority>
         <properties>
            <property name="minimum" value="45" type=""/>
         </properties>
      </rule>
<rule name="DoubleCheckedLockingRule"
            message="Double checked locking is not thread safe in Java."
            class="net.sourceforge.pmd.rules.DoubleCheckedLockingRule"
            include="false">
         <description>
            
            
            
            
            
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      
         
         
         
         
         </description>
         <example>
<![CDATA[





  public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }
  




]]>
         </example>
         <priority>
            4
         </priority>
         <properties>
         </properties>
      </rule>
<rule name="JUnitAssertionsShouldIncludeMessageRule"
            message="JUnit assertions should include a message"
            class="net.sourceforge.pmd.rules.junit.JUnitAssertionsShouldIncludeMessageRule"
            include="false">
         <description>
            
            
            
            
            
      JUnit assertions should include a message - i.e., use the three argument version of
          assertEquals(), not the two argument version.
      
         
         
         
         
         </description>
         <example>
<![CDATA[





  public class Foo extends TestCase {
    public void testSomething() {
        assertEquals("foo", "bar");
        // not good!  use the form:
        // assertEquals("Foo does not equals bar", "foo", "bar");
        // instead
    }
  }
  




]]>
         </example>
         <priority>
            4
         </priority>
         <properties>
         </properties>
      </rule>
<rule name="ImportFromSamePackage"
            message="No need to import a type that's in the same package"
            class="net.sourceforge.pmd.rules.ImportFromSamePackageRule"
            include="false">
         <description>
            
            
            
            
            
     No need to import a type that's in the same package.
     
         
         
         
         
         </description>
         <example>
<![CDATA[





 package foo;
 import foo.Buz; // no need for this
 public class Bar{}
 




]]>
         </example>
         <priority>
            3
         </priority>
         <properties>
         </properties>
      </rule>




</ruleset>
