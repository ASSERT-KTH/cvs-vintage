<?xml version="1.0"?>
<document url="./building_controller.xml">

  <properties>
    <author>Craig R. McClanahan</author>
    <author>Mike Schachter</author>
    <author>Ted Husted</author>
    <author>Martin Cooper</author>
    <author>Ed Burns</author>
    <author>Donald Ball</author>
    <author>Eddie Bush</author>
    <author>Yann Cebron</author>
    <author>David Graham</author>
    <title>The Struts User's Guide - Building Controller Components</title>
  </properties>

  <body>
  <chapter name="4. Building Controller Components" href="building_controller">

      <section name="4.1 Overview" href="overview">

        <p>
          Now that we understand how to construct the Model and View components
        of your application, it is time to focus on the <code>Controller</code>
        components.  Struts includes a servlet that implements the primary function
        of mapping a request URI to an <code>Action</code> class.  Therefore, your
        primary responsibilities related to the Controller are:
      </p>

      <ul>
        <li>Write an <code>ActionForm</code> class to mediate between the Model
            and the View, as described in <a href="building_model.html">Building
            Model Components</a>.</li>
        <li>Write an <code>Action</code> class for each logical request that may
            be received (extend <code>org.apache.struts.action.Action</code>).</li>
        <li>Configure a ActionMapping (in XML) for each logical request that may
            be submitted. The XML configuration file is usually named
            <code>struts-config.xml</code>.</li>
        <li>Update the web application deployment descriptor file (in XML)
            for your application to include the necessary Struts components.</li>
        <li>Add the appropriate Struts components to your application.</li>
      </ul>
    </section>

    <section name="4.2 ActionForm Classes" href="action_form_classes">

     <p>
     An ActionForm represents an HTML form that the user interacts with over one
     or more pages.  You will provide properties to hold the state of the form with
     getters and setters to access them.  ActionForms can be stored in either the session (default)
     or request scopes.  If they're in the session it's important to implement the form's reset
     method to initialize the form before each use.  Struts sets the ActionForm's properties from
     the request parameters and sends the validated form to the appropriate Action's execute method.
     </p>

     <p>
        When you code your <code>ActionForm</code> beans, keep the following
        principles in mind:
      </p>

      <ul>
        <li>The <code>ActionForm</code> class itself requires no specific
            methods to be implemented.  It is used to identify the role these
            particular beans play in the overall architecture.  Typically, an
            <code>ActionForm</code> bean will have only property getter and
            property setter methods, with no business logic.</li>
            <li>The ActionForm object also offers a standard validation mechanism.
            If you override a "stub" method, and provide error messages in the
            standard application resource, Struts will automatically validate the
            input from the form (using your method). See "<a
            href="./building_view.html#form_validation">Action Form Validation</a>"
            for details. Of course, you can also ignore the ActionForm validation
            and provide your own in the Action object.</li>

        <li>Define a property (with associated <code>getXxx</code> and
        <code>setXxx</code> methods) for each field that is present in the
        form.  The field name and property name must match according to the
        usual JavaBeans conventions (see the javadoc for the
        <code>java.beans.Introspector</code> class for a start on information
        about this).  For example, an input field named <code>username</code>
        will cause the <code>setUsername</code> method to be called.</li>

        <li>Buttons and other controls on your form can also be defined as properties.
            This can help determine which button or control was selected when the
            form was submitted. Remember, the ActionForm is meant to represent your
            data-entry form, not just the data beans.</li>
        <li>Think of your ActionForm beans as a firewall between HTTP and the Action.
            Use the validate method to ensure all required properties are present, and
            that they contain reasonable values. An ActionForm that fails validation
            will not even be presented to the Action for handling.</li>
        <li>You may also place a bean instance on your form, and use nested property
            references. For example, you might have a "customer" bean on your Action
            Form, and then refer to the property "customer.name" in your JSP view.
            This would correspond to the methods <code>customer.getName()</code> and
            <code>customer.setName(string Name)</code> on your customer bean. See the
            Tag Library Developer Guides for more about nested syntax.</li>
        <li><i>Caution:</i> If you nest an existing bean instance on your form, think
            about the properties it exposes. Any public property on an ActionForm that
            accepts a single String value can be set with a query string. It may be
            useful to place such beans inside a thin "wrapper" that exposes only the
            properties required. This wrapper can also provide a filter to be
            sure runtime properties are not set to inappropriate values.</li>
      </ul>
      </section>

      <section name="4.2.1 DynaActionForm Classes" href="dyna_action_form_classes">

      <p>Maintaining a separate concrete ActionForm class for each form in your struts application is time-consuming. This can be alleviated through the use of DynaActionForm classes. Instead of creating a new ActionForm subclass and new get/set methods for each of your bean's properties, you can list its properties, type, and defaults in the struts configuration file.</p>
      <p>For example, add the following to struts-config.xml for a UserForm bean that stores a user's given and family names:</p>
<pre>
<![CDATA[
<form-bean 
  name="UserForm" 
  type="org.apache.struts.action.DynaActionForm">
  <form-property 
    name="givenName" 
    type="java.lang.String" 
    initial="John"/>
  <form-property 
    name="familyName" 
    type="java.lang.String" 
    initial="Smith"/>
</form-bean>
]]>
</pre>
      <p>The list of types supported by DynaActionForm beans includes:</p>
      <ul>
        <li>java.lang.BigDecimal</li>
        <li>java.lang.BigInteger</li>
        <li>boolean and java.lang.Boolean</li>
        <li>byte and java.lang.Byte</li>
        <li>char and java.lang.Character</li>
        <li>java.lang.Class</li>
        <li>double and java.lang.Double</li>
        <li>float and java.lang.Float</li>
        <li>int and java.lang.Integer</li>
        <li>long and java.lang.Long</li>
        <li>short and java.lang.Short</li>
        <li>java.lang.String</li>
        <li>java.sql.Date</li>
        <li>java.sql.Time</li>
        <li>java.sql.Timestamp</li>
      </ul>
      <p>If you do not supply an initial attribute, numbers will be initialized
      to 0 and objects to null.</p>
      <p>In JSP pages using Struts custom tags, attributes of
      <code>DynaActionForm</code> objects can be referenced just like ordinary
      <code>ActionForm</code> objects.  However, when utilizing the JavaServer
      Pages Standard Tag Library, only properties of ordinary
      <code>ActionForm</code> objects can be directly accessed through the JSTL
      expression language syntax.  However, <code>DynaActionForm</code>
      properties can be accessed through a slightly different syntax.</p>
      <p>In particular, whereas the JSTL EL syntax for referencing a property
      of an <code>ActionForm</code> would be something like:</p>
      <pre>
       ${formbean.prop}</pre>
      <p>The syntax for referencing a property of a <code>DynaActionForm</code>
      would be:</p>
      <pre>
       ${dynabean.map.prop}</pre>
      <p>The <code>map</code> property is a property of
      <code>DynaActionForm</code> which represents the <code>HashMap</code>
      containing the <code>DynaActionForm</code> properties.</p>

     </section>

    <section name="4.2.2 Map-backed ActionForms" href="map_action_form_classes">
      <p>The DynaActionForm classes offer the ability to create ActionForm beans at initialization time, based on a list of properties enumerated in the struts configuration file. However, many HTML forms are generated dynamically at request time. Since the properties of these forms' ActionForm beans are not all known ahead of time, we need a new approach.</p>
      <p>Struts allows you to make one or more of your ActionForm's properties' values a Map instead of a traditional atomic object. You can then store the data from your form's dynamic fields in that Map. Here is an example of a map-backed ActionForm class:</p>
<pre>
<![CDATA[
public FooForm extends ActionForm {

    private final Map values = new HashMap();

    public void setValue(String key, Object value) {
        values.put(key, value);
    }

    public Object getValue(String key) {
        return values.get(key);
    }

}
]]>
</pre>
      <p>In its corresponding JSP page, you can access objects stored in the values map using a special notation: <i>mapname(keyname)</i>. The parentheses in the bean property name indicate that the bean property named <i>mapname</i> is indexed using Strings (probably backed by a Map) and that struts should look for get/set methods that take a String key parameter to find the correct sub-property value. Struts will, of course, use the <i>keyname</i> value from the parentheses when it calls the get/set methods.</p>
      <p>Here is a simple example:</p>
<pre>
<![CDATA[
<html:text property="value(foo)"/>
]]>
</pre>
      <p>This will call the getValue() method on FooForm with a key value of "foo" to find the property value. To create a form with dynamic field names, you could do the following:</p>
<pre>
<![CDATA[
<% for (int i=0; i<10; i++) {
  String name = "value(foo-" + i + ")";
  <html:text property="<%=name%>"/><br/>
%>
]]>
</pre>
      <p>Note that there is nothing special about the name <i>value</i>. Your map-backed property could instead be named <i>property</i>, <i>thingy</i>, or any other bean property name you prefer. You can even have multiple map-backed properties on the same bean.</p>
      <p>In addition to map-backed properties, you can also create list-backed properties. You do so by creating indexed get/set methods on your bean:</p>
<pre>
<![CDATA[
public FooForm extends ActionForm {

    private final List values = new ArrayList();

    public void setValue(int key, Object value) {
        values.set(key, value);
    }

    public Object getValue(int key) {
        return values.get(key);
    }
}
]]>
</pre>
      <p>In your JSP pages, you access individual entries in a list-backed property by using a different special notation: <i>listname[index]</i>. The braces in the bean property name indicate that the bean property named <i>listname</i> is indexed (probably backed by a List), and that struts should look for get/set methods that take an index parameter in order to find the correct sub-property value.</p>
</section>

    <section name="4.3 Action Classes" href="action_classes">

      <p>The <code>Action</code> class defines two methods that could be
        executed depending on your servlet environment:
      </p>

<pre>
public ActionForward execute(ActionMapping mapping,
                             ActionForm form,
                             ServletRequest request,
                             ServletResponse response)
  throw Exception;

public ActionForward execute(ActionMapping mapping,
                             ActionForm form,
                             HttpServletRequest request,
                             HttpServletResponse response)
  throws Exception;
</pre>

      <p>
        Most projects would only use the "HttpServletRequest" version.
      </p>
      <p>
        The goal of an <code>Action</code> class is to process a request, via
        its <code>execute()</code> method, and return an <code>ActionForward</code> object
        that identifies where control should be forwarded (e.g. a JSP) to provide
        the appropriate response. In the <i>MVC/Model 2</i> design pattern,
        a typical <code>Action</code> class will often implement logic like the following
        in its <code>execute()</code> method:
      </p>
      <ul>
        <li>Validate the current state of the user's session (for example, checking
            that the user has successfully logged on).  If the <code>Action</code>
            class finds that no logon exists, the request can be forwarded to
            the JSP page that displays the username and password prompts for
            logging on.  This could occur because a user tried to enter an
            application "in the middle" (say, from a bookmark), or because the
            session has timed out, and the servlet container created a new one.</li>
        <li>If validation is not complete,
            validate the form bean properties as needed.  If a problem is found,
            store the appropriate error message keys as a request attribute, and
            forward control back to the input form so that the errors can be
            corrected.</li>
        <li>Perform the processing required to deal with this request (such as
            saving a row into a database).  This can be done by logic code embedded within
            the <code>Action</code> class itself, but should generally be performed
            by calling an appropriate method of a business logic bean.</li>
        <li>Update the server-side objects that will be used to create the next
            page of the user interface (typically request scope or session scope
            beans, depending on how long you need to keep these items available).</li>
        <li>Return an appropriate <code>ActionForward</code> object that identifies
            the JSP page to be used to generate this response, based on the newly
            updated beans.  Typically, you will acquire a reference to such an
            object by calling <code>findForward()</code> on either the
            <code>ActionMapping</code> object you received (if you are using a
            logical name local to this mapping), or on the controller servlet
            itself (if you are using a logical name global to the application).</li>
      </ul>

      <p>
        Design issues to remember when coding <code>Action</code> classes
        include the following:
      </p>

      <ul>
        <li>The controller servlet creates only one instance of your
            <code>Action</code> class, and uses it for all requests.  Thus,
            you need to code your <code>Action</code> class so that it operates
            correctly in a multi-threaded environment, just as you must code a
            servlet's <code>service()</code> method safely.</li>
        <li>The most important principle that aids in thread-safe coding is to
            use only local variables, not instance variables, in your
            <code>Action</code> class.  Local variables are created on a
            stack that is assigned (by your JVM) to each request thread, so
            there is no need to worry about sharing them.</li>
        <li>The beans that represent the Model of your system may throw exceptions
            due to problems accessing databases or other resources.
            You should trap all such exceptions
            in the logic of your <code>execute()</code> method, and record them in the
            application's log (along with the corresponding stack trace) by
            calling:<br />
            <code>servlet.log("Error message text", exception);</code></li>
        <li>As a general rule, allocating scarce resources and keeping them across
            requests from the same user (in the user's session) can cause
            scalability problems.  You should strive to release such resources
            (such as database connections) prior to forwarding control to the
            appropriate View component -- even if a bean method you have called
            throws an exception.</li>
      </ul>

      <p>
        In addition, you will want to guard against <code>Action</code> classes
        that are too large.  The easiest way for this to happen is to embed your
        functional logic in the <code>Action</code> class itself, rather than
        coding it in separate business logic beans.  Besides making the
        <code>Action</code> class itself hard to understand and maintain, this
        approach also makes it harder to re-use the business logic code, because
        it is embedded inside a component (the <code>Action</code> class) that
        is tied to being executed in a web application environment.
      </p>

      <p>
        An <code>Action</code> can be factored into several local methods, so long as all
        properties needed are passed in the method signatures. The JVM
        handles such properties using the stack, and so they are thread-safe.
      </p>

      <p>
        The example application included with Struts stretches this design
        principle somewhat, because the business logic itself is embedded in the
        <code>Action</code> classes. This should be considered something of a
        bug in the design of the sample application, rather than an intrinsic
        feature of the Struts architecture, or an approach to be emulated.
      </p>

      <p>
        In Struts 1.0, Actions called a <code>perform</code> method instead of the now
        preferred <code>execute</code> method. These methods use the same parameters and
        differ only in which exceptions they throw. The elder <code>perform</code> method
        throws <code>SerlvetException</code> and <code>IOException</code>. The new <code>execute</code> method
        simply throws <code>Exception</code>. The change was to facilitate the Declarative
        Exception handling feature introduced in Struts 1.1.
    </p>
    <p>
        The <code>perform</code> method may still be used in Struts 1.1 but is deprecated.
        The Struts 1.1 method simply calls the new <code>execute</code> method and wraps
        any <code>Exception</code> thrown as a <code>ServletException</code>.
    </p>
    </section>

    <section name="4.4 The ActionServlet" href="action_servlet">
      <p>
        For those of you familiar with MVC architecture, the ActionServlet
        represents the C - the controller.  The job of the controller is to
        process user requests, determine what the user is trying to achieve
        according to the request, pull data from the model (if necessary) to
        be given to the appropriate view, and then select the proper view
        to respond to the user.  The Struts controller delegates most of this
        grunt work to Action classes.
      </p>
      <p>
        In addition to being the controller for your application, the
        ActionServlet instance also is responsible for initialization and
        clean-up of resources.  When the controller initializes, it first
        loads the application con fig corresponding to the "config" init-param.
        It then goes through an enumeration of all <code>init-param</code>
        elements, looking for those elements who's name starts with
        <code>config/</code>.  For each of these elements, Struts loads the
        configuration file specified by the value of that
        <code>init-param</code>, and assigns a "prefix" value
        to that module's ApplicationConfig instance consisting of the piece of
        the <code>init-param</code> name following "config/".  For example, the
        module prefix specified by the <code>init-param config/foo</code> would
        be "foo".  This is important to know, since this is how the
        controller determines which module will be given control of processing
        the request.  To access the module foo, you would use a URL like:
      </p>
      <p>
        <pre>http://localhost:8080/myApp/foo/someAction.do</pre>
      </p>
      <p>
        For each request made of the controller, the method
        <code>process(HttpServletRequest, HttpServletResponse)</code> will be
        called.  This method simply determines which module should service
        the request and then invokes that module's RequestProcessor's
        process method, passing the same request and response.
      </p>
    </section>

    <section name="4.4.1 Request Processor" href="request_processor">
        <p>
          The RequestProcessor is where the majority of the core
          processing occurs for each request.  Let's take a look at the
          helper functions the process method invokes in-turn:
        </p>
        <ul>
          <li><code>processPath</code> Determine the path that invoked us.  This
            will be used later to retrieve an ActionMapping.</li>
          <li><code>processLocale</code> Select a locale for this request, if one
            hasn't already been selected, and place it in the request.</li>
          <li><code>processContent</code> Set the default content type (with optional 
            character encoding) for all responses if requested.</li>
          <li><code>processNoCache</code> If appropriate, set the following response
            headers: "Pragma", "Cache-Control", and "Expires".</li>
          <li><code>processPreprocess</code> This is one of the "hooks" the
            RequestProcessor makes available for subclasses to override.  The
            default implementation simply returns true.  If you subclass
            RequestProcessor and override processPreprocess you should either
            return true (indicating process should continue
            processing the request) or false (indicating you have handled the
            request and the process should return).</li>
          <li><code>processMapping</code> Determine the ActionMapping associated with
            this path.</li>
          <li><code>processRoles</code> If the mapping has a role associated with it,
            ensure the requesting user is has the specified role.  If they do
            not, raise an error and stop processing of the request.</li>
          <li><code>processActionForm</code> Instantiate (if necessary) the
            ActionForm associated with this mapping (if any) and place it
            into the appropriate scope.</li>
          <li><code>processPopulate</code> Populate the ActionForm associated with
            this request, if any.</li>
          <li><code>processValidate</code> Perform validation (if requested) on the
            ActionForm associated with this request (if any).</li>
          <li><code>processForward</code> If this mapping represents a forward,
            forward to the path specified by the mapping.</li>
          <li><code>processInclude</code> If this mapping represents an include,
            include the result of invoking the path in this request.</li>
          <li><code>processActionCreate</code> Instantiate an instance of the class
            specified by the current ActionMapping (if necessary).</li>
          <li><code>processActionPerform</code> This is the point at which your
            action's perform or execute method will be called.</li>
          <li><code>processActionForward</code> Finally, the process method of the
            RequestProcessor takes the ActionForward returned by your
            Action class, and uses to select the next resource (if any).
            Most often the ActionForward leads to the presentation page that
            renders the response. </li>
        </ul>
      </section>

      <section name="4.4.2 Exception Handler" href="exception_handler">
      <p>
      You can define an ExceptionHandler to execute when an Action's execute 
      method throws an Exception.  First, you need to subclass 
      org.apache.struts.action.ExceptionHandler and override the execute method.
      Your execute method should process the Exception and return an ActionForward
      object to tell Struts where to forward to next.  Then you configure your 
      handler in struts-config.xml like this:<br/>
        <pre><![CDATA[
        <global-exceptions>
            <exception 
              key="some.key" 
              type="java.io.IOException" 
              handler="com.yourcorp.ExceptionHandler">
        </global-exceptions>
        ]]></pre>
      <br/>
      That configuration says that com.yourcorp.ExceptionHandler.execute() will be called 
      when any IOException is thrown by an Action.  The key is a key from your message resources
      properties file that can be used to display an error message.
      </p>
      <p>
      You can override global exception handlers by defining a handler inside an action definition.
      </p>
      <p>
      A common use of ExceptionHandlers is to configure one for java.lang.Exception so it's called
      for any exception and log the exception to some data store.
      </p>
      </section>

      <section name="4.4.3 PlugIn Classes" href="plugin_classes">
        <p>
          The <code>PlugIn</code> interface allows applications to easily hook
          into the <code>ActionServlet</code> lifecycle. This interface defines
          two methods, <code>init()</code> and <code>destroy()</code>, which
          are called at application startup and shutdown, respectively. A common
          use of a plugin is to configure or load application-specific data as
          the web application is starting up.
        </p>
        <p>
          At runtime, any resource setup by <code>init</code> would be accessed by Actions
          or business tier classes. The PlugIn interface allows you to setup
          resources, but does not provide any special way to access them. Most
          often, the resource would be stored in application context, under
          a known key, where other components can find it.</p>
        <p>
          PlugIns are configured using &lt;plug-in&gt; elements within the
          Struts configuration file. See <a href="#plugin_config">
          PlugIn Configuration</a> for details.
        </p>
      </section>

    <section name="4.5 The ActionMapping Implementation" href="actionmapping">

      <p>
        In order to operate successfully, the Struts controller servlet needs
        to know several things about how each request URI should be mapped to an
        appropriate <code>Action</code> class.  The required knowledge has been
        encapsulated in a Java interface named <code>ActionMapping</code>, the most
        important properties are as follows:
      </p>

      <ul>
        <li><b>type</b> - Fully qualified Java class name of the
          <code>Action</code> implementation class used by this mapping.</li>
        <li><b>name</b> - The name of the form bean defined in the config file
          that this action will use</li>
        <li><b>path</b> - The request URI path that is matched to select this
            mapping.  See below for examples of how matching works.</li>
        <li><b>unknown</b> - Set to <code>true</code> if this action
          should be configured as the default for this application, to handle
          all requests not handled by another action.  Only one action can be
          defined as a default within a single application.</li>
        <li><b>validate</b> - Set to <code>true</code> if the
          <code>validate()</code> method of the action associated
          with this mapping should be called.</li>
        <li><b>forward</b> - The request URI path to which control is passed
         when his mapping is invoked. This is an alternative to declaring
         a <b>type</b> property. </li>

      </ul>

    </section>

    <section name="4.6 Writing Action Mappings" href="config">

      <p>
        How does the controller servlet learn about the mappings you want?  It
        would be possible (but tedious) to write a small Java class that simply
        instantiated new <code>ActionMapping</code> instances, and called all of
        the appropriate setter methods.  To make this process easier, Struts uses the
        Jakarta-Digester component to parse an XML-based description of
        the desired mappings and create the appropriate objects initialized to the
        appropriate default values.
        See the <a href="http://jakarta.apache.org/commons">Jakarta Commons web site</a>
        for more information about the Digester.
      </p>

      <p>
        The developer's responsibility is to create an XML file named
        <code>struts-config.xml</code> and place it in the WEB-INF directory of your
        application. This format of this document is described by the Document Type Definition (DTD)
        maintained at
        <a href="http://jakarta.apache.org/struts/dtds/struts-config_1_1.dtd">http://jakarta.apache.org/struts/dtds/struts-config_1_1.dtd</a>.
        This chapter covers the configuration elements that you will typically 
        write as part of developing your application.
        There are several other elements that can be placed in the 
        struts-config file to customize your application. 
        See chapter 7 for more about the other elements in the Struts 
        configuration file. 
      </p>
      <p>
        The controller uses an internal copy of this document to parse the configuration;
        an Internet connection is not required for operation.
      </p>

      <p>
        The outermost XML element must be <code>&lt;struts-config&gt;</code>. Inside of
        the &lt;struts-config&gt; element, there are three important elements that are
        used to describe your actions:

        <blockquote>
          <b>&lt;form-beans&gt;</b><br />
            This section contains your form bean definitions.  Form beans are descriptors that
            are used to create ActionForm instances at runtime. You use a &lt;form-bean&gt; element
            for each form bean, which has the following important attributes:
            <ul>
              <li>
                <b>name</b>: A unique identifier for this bean, which will be used
                to reference it in corresponding action mappings. Usually, this
                is also the name of the request or session attribute under which
                this form bean will be stored.
              </li>
              <li>
                <b>type</b>: The fully-qualified Java classname of the ActionForm subclass to use with this form bean.
              </li>
            </ul>
        </blockquote>
        <blockquote>
        <b>&lt;global-forwards&gt;</b><br />
        This section contains your global forward definitions.  Forwards are instances of the ActionForward
        class returned from an ActionForm's execute method.  These map logical names to specific resources (typically
        JSPs), allowing you to change the resource without changing references to it throughout your application.
        You use a &lt;forward&gt; element for each forward definition, which has the following important attributes:
        <ul>
          <li>
            <b>name</b>: The logical name for this forward.  This is used in your ActionForm's execute
            method to forward to the next appropriate resource.  Example: homepage
          </li>
          <li>
            <b>path</b>: The context relative path to the resource.  Example: /index.jsp or /index.do
          </li>
          <li>
            <b>redirect</b>: True or false (default).  Should the ActionServlet redirect to the resource instead of forward?
          </li>
        </ul>
        </blockquote>
        <blockquote>
          <b>&lt;action-mappings&gt;</b><br />
            This section contains your action definitions.  You use an &lt;action&gt; element
            for each of the mappings you would like to define.  Most action elements will
            define at least the following attributes:

            <ul>
              <li>
                <b>path</b>: The application context-relative path to the action
              </li>
              <li>
                <b>type</b>: The fully qualified java classname of your Action class
              </li>
              <li>
                <b>name</b>: The name of your &lt;form-bean&gt; element to use with this action
              </li>
            </ul>

            <p>Other often-used attributes include:</p>

            <ul>
              <li>
                <b>parameter</b>: A general-purpose attribute often used by "standard" Actions to pass a required property.
              </li>
              <li>
                <b>roles</b>: A comma-delimited list of the user security roles that can access this mapping.
              </li>
            </ul>

            <p>For a complete description of the elements that can be used with the action element, see the
            <a href="http://jakarta.apache.org/struts/dtds/struts-config_1_1.dtd">Struts Configuration DTD</a> and the
            <a href="../api/org/apache/struts/action/ActionMapping.html">ActionMapping documentation</a>.</p>

          </blockquote>

      </p>
      </section>

      <section name="4.6.1 ActionMapping Example" href="action_mapping_example">

      <p>
        The <code>struts-config.xml</code> file from the example application includes
        the following mapping entry for the "log on" function, which we will use
        to illustrate the requirements.  Note that the entries for all the other actions
        are left out:
      </p>

<pre><![CDATA[
<struts-config>
  <form-beans>
    <form-bean
      name="logonForm"
      type="org.apache.struts.example.LogonForm" />
 </form-beans>
 <global-forwards
      type="org.apache.struts.action.ActionForward" />
    <forward 
      name="logon" 
      path="/logon.jsp"
      redirect="false" />
  </global-forwards>
  <action-mappings>
    <action
      path="/logon"
      type="org.apache.struts.example.LogonAction"
      name="logonForm"
      scope="request"
      input="/logon.jsp"
      unknown="false"
      validate="true" />
  </action-mappings>
</struts-config>
]]></pre>

      <p>
        First the form bean is defined.  A basic bean of class "<code>org.apache.struts.example.LogonForm</code>"
        is mapped to the logical name "<code>logonForm</code>".  This name is used as a session or request attribute
        name for the form bean.
      </p>
      <p>
        The "<code>global-forwards</code>" section is used to create logical name mappings for commonly used
        jsp pages.  Each of these forwards is available through a call to your action mapping instance,
        i.e. <code>mapping.findForward("logicalName")</code>.
      </p>
      <p>
        As you can see, this mapping matches the path <code>/logon</code> (actually,
        because the example application uses extension mapping, the request URI you
        specify in a JSP page would end in <code>/logon.do</code>).  When a request
        that matches this path is received, an instance of the <code>LogonAction</code>
        class will be created (the first time only) and used.  The controller servlet
        will look for a session scoped bean under key <code>logonForm</code>, creating
        and saving a bean of the specified class if needed.
      </p>
      <p>
        Optional but very useful are the local "<code>forward</code>" elements. In the example
        application, many actions include a local "success" and/or "failure" forward as
        part of an Action mapping.
      </p>
<pre><![CDATA[
<!-- Edit mail subscription -->
<action    
  path="/editSubscription"
  type="org.apache.struts.example.EditSubscriptionAction"
  name="subscriptionForm"
  scope="request"
  validate="false">
  <forward name="failure" path="/mainMenu.jsp"/>
  <forward name="success" path="/subscription.jsp"/>
  </action>
]]></pre>

      <p>Using just these two extra properties, the <code>Action</code> classes in the example
        application are almost totally independent of the actual names of the JSP pages
        that are used by the page designers. The pages can be renamed (for example) during
        a redesign, with negligible impact on the <code>Action</code> classes themselves.
        If the names of the "next" JSP pages were hard coded into the <code>Action</code>
        classes, all of these classes would also need to be modified. Of course, you can define
        whatever local forward properties makes sense for your own application.
      </p>
      
      <p>
      The Struts configuration file includes several other elements that you 
      can use to customize your application. 
      See chapter 7 for details.
      </p>

      </section>

      <section name="4.7.4.3 Using Actions for Pages" href="module_config-use_actions">
        <p>
          Fronting your pages with actions is <i>essential</i> when using modules,
          since doing so is the only way you involve the controller in the request -- and
          you want to!  The controller puts the application configuration in the request,
          which makes available all of your module-specific configuration data (including
          which plug-ins you are using, message resources, datasources, etc).
        </p>
        <p>
           The simplest way to do this is to use the <code>forward</code> property of the ActionMapping:
        </p>
<pre>
&lt;action path="/view" forward="/view.jsp"/>
</pre>
      </section>

     <section name="4.7.4.4 Switching Modules" href="module_config-switching">
       <p>
        There are two basic methods to switching from one module to another.
         You can either use a forward (global or local) and specify the
         contextRelative attribute with a value of true, or you can use
         the built-in <code>org.apache.struts.actions.SwitchAction</code>.
       </p>
       <p>
         Here's an example of a global forward:
       </p>
       <p>
<pre>
   ...
   &lt;struts-config&gt;
     ...
     &lt;global-forwards&gt;
       &lt;forward name="toModuleB"
		   contextRelative="true"
		   path="/moduleB/index.do"
		   redirect="true"/&gt;
       ...
     &lt;/global-forwards&gt;
     ...
   &lt;/struts-config&gt;
 </pre>
       </p>
       <p>
         You could do the same thing with a local forward declared in an
         ActionMapping:
       </p>
       <p>
<pre>
   ...
   &lt;struts-config&gt;
     ...
     &lt;action-mappings&gt;
       ...
       &lt;action ... &gt;
	 &lt;forward name="success"
		     contextRelative="true"
		     path="/moduleB/index.do"
		     redirect="true"/&gt;
      &lt;/action&gt;
       ...
     &lt;/action-mappingss&gt;
     ...
   &lt;/struts-config&gt;
 </pre>
       </p>
       <p>
         Finally, you could use <code>org.apache.struts.actions.SwitchAction
         </code>, like so:
       </p>
       <p>
 <pre>
...
&lt;action-mappings&gt;
&lt;action path="/toModule"
	  type="org.apache.struts.actions.SwitchAction"/&gt;
...
&lt;/action-mappingss&gt;
...
</pre> 
      </p>
       <p>
         Now, to change to ModuleB, we would use a URI like this:
       </p>
      <p>
        <code>http://localhost:8080/toModule.do?prefix=moduleB&amp;page=index.do</code>
      </p>
      <p>
        That's all there is to it!  Happy module-switching!
      </p>
      </section>

      <section name="4.8 Commons Logging Interface" href="logging">
      <p>
        Struts doesn't configure logging itself -- it's all done by
        commons-logging under the covers. The default algorithm is a search:
      </p>
      <ul>
        <li>
           If Log4J is there, use it.
        </li>
        <li>
           If JDK 1.4 is there, use it.
        </li>
        <li>
           Otherwise, use SimpleLog.
        </li>
      </ul>
      <p>
        The commons-logging interface is an <i>ultra-thin</i> bridge to
        many different logging implementations.  The intent is to remove
        compile- and run-time dependencies on any single logging
        implementation.  For more information about the currently-supported
        implementations, please refer to the
        <a href="http://jakarta.apache.org/commons/logging/api/index.html">
        the description for the org.apache.commons.logging package</a>.
      </p>
      <p>
        Because Struts uses commons-logging and, therefore, includes the
        necessary JAR files for <b>you</b> to use commons-logging, you've
        probably had the occassional fleeting thought, <i>"Should I use
        commons-logging?"</i> The answer (surprise!) depends on the
        requirements for your particular project. If one of your requirements
        is the ability to easily change logging implementations with zero
        impact on your application, then commons-logging is a very good option.
      </p>
      <p>
        <i>"Great!  What do I do to get started using commons-logging in
        my own code?"</i>
      </p>
      <p>
        Using commons-logging in your own code is very simple - all you need
        are two imports and a declaration for a logger.  Let's take a look:
      </p>
      <p>
<pre>
  package com.foo;
  ...
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
  ...
  public class Foo {
    ...
    private static Log log = LogFactory.getLog(Foo.class);
   ...
   public void setBar(Bar bar)
   {
     if (log.isTraceEnabled())
       log.trace("Setting bar to " + bar);

     this.bar = bar;
   }
   ...
  }
</pre>
      </p>
      <p>
        The general idea is to instantiate a single logger per class and to
        use a name for the logger which reflects where it's being used.  The
        example is constructed with the class itself.  This gives the
        logger the name of com.foo.Foo.  Doing things this way lets you
        easily see where the output is coming from, so you can quickly
        pin-point problem areas.  In additon, you are able to enable/disable
        logging in a very fine-grained way.
       </p>
       <p>
        For examples of using logging in Struts classes, see the
        Action classes in the Struts MailReader example application.
       </p>

      <p>
      Next: <a href="building_apps.html">Building Applications</a>
      </p>
      </section>

  </chapter>
  </body>
</document>
