<!doctype article public "-//OASIS//DTD DocBook V3.1//EN" [ <!entity header system "header.sgml">]>

<article lang="en">
  <!-- DocBook file was created in July, the first, 2002 by Guillaume Riviere (Guillaume.Riviere@inria.fr)
  See http://www.objectweb.org/ for more information -->
  <artheader>
    <title>
      Product Features Specification
    </title>
    <author>
      <firstname>Riviere</firstname>
      <othername>Guillaume</othername>
      <affiliation>
	<orgname>INRIA</orgname>
	<address><email>Guilllaume.Riviere@inrialpes.fr</email></address>
      </affiliation>
    </author>
    <date>
      July, the 1th, 2002
    </date>
  </artheader>
  <sect1>
    <title>
      Document Header
    </title>
    <variablelist>
      <varlistentry>
	<term>
	  License:
	</term>
	<listitem>
	  <para>All this documentation is under <abbrev>GNU FDL</abbrev> &lsqb;1&rsqb;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Version:
	</term>
	<listitem>
	  <para>0.0.1</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Status:
	</term>
	<listitem>
	  <para>Draft</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Author:
	</term>
	<listitem>
	  <para>Guillaume Riviere</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Date:
	</term>
	<listitem>
	  <para>July, the 1th, 2002</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Contributors:</term>
	<listitem>
	  <para>No contributors for the moment</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Abstract:
	</term>
	<listitem>
	  <para>This document is the Product Features Specification for the ObjectWeb CAROL Library</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	  Version 0.0.1 modifications summary:
	</term>
	<listitem>
	  <para>Document Creation</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
  <sect1>
    <title>
      Executive summary
    </title>
    <sect2>
      <title>
	Justifications and objectives
      </title>
      <para>The objectives of this library is to provide a <abbrev>RMI</abbrev> and <abbrev>JNDI</abbrev> abstraction based on the <abbrev>RMI-IDL</abbrev> Specification. This library allow a JAVA Server to use only the <abbrev>RMI IIOP API</abbrev> for object export on several <abbrev>RMI</abbrev> architecture (<abbrev>JEREMIE</abbrev>, <abbrev> JRMP</abbrev>, <abbrev>IIOP</abbrev>, ...). This library also allow a JAVA Server to use only the <abbrev>JNDI API</abbrev> for object binding on several name services (Jeremie registry, CosNaming, rmiregistry, ...). With <abbrev>CAROL</abbrev> Library, a Java server is <abbrev>RMI</abbrev> independent and can use several <abbrev>RMI</abbrev> architecture at runtime. The architecture and documentation of <abbrev>CAROL</abbrev> provide simple "plug and play" development method to add a specific <abbrev>RMI</abbrev> architecture without server code modifications. There is 3 <abbrev>RMI</abbrev> architecture provided with <abbrev>CAROL</abbrev>: <abbrev>JRMP</abbrev>, <abbrev>IIOP</abbrev> and <abbrev>JEREMIE</abbrev>. <abbrev>CAROL</abbrev> use standard configuration files (<filename>orb.properties</filename> and <filename>jndi.properties</filename>) with internal extensions</para>
    </sect2>
    <sect2>
      <title>
	Product License
      </title>
      <para>All the carol Library is under the <abbrev>LGPL</abbrev> License inside org.objectweb package</para>
      <para>see the <ulink url="http:/www.gnu.org/copyleft/lesser.html">Lesser GNU Public License</ulink></para>
    </sect2>
    <sect2>
      <title>
	Objectives not meat by this product
      </title>
      <para>The purpose of this library is no to provide a specific RPC implementation, This Library did not define or specify a new RPC.. This library use only the standard <abbrev>RMI IIOP</abbrev> and <abbrev>JNDI API</abbrev>. This library did not use or define specific <abbrev>API</abbrev>. This library only extends <abbrev>JDK 1.4 RMI JRMP</abbrev> for context propagation and <abbrev>JDK 1.4 IIOP</abbrev> InitialContextFactory for Resources binding in a CosNaming. This Library can only use <abbrev>RMI IIOP</abbrev> "like" <abbrev>RPC</abbrev>. </para>
    </sect2>
    <sect2>
      <title>
	Relationship with other products
      </title>
      <para>CAROL is design to use: 
	<itemizedlist>
	  <listitem>
	    <para><abbrev>JEREMIE</abbrev> <ulink url="http:/www.objectweb.org/jonathan">ObjectWeb-JONATHAN</ulink></para>
	  </listitem>
	  <listitem>
	    <para>Any <abbrev>RMI IIOP</abbrev> implementation using the <ulink url="http://cgi.omg.org/cgi-bin/doc?ptc/2001-03-04">PortableInterceptor specification</ulink></para>
	  </listitem>
	  <listitem>
	    <para>Any <abbrev>RMI JRMP</abbrev> implementation with our custom <classname>UnicastRemoteObject</classname> for "PortableInterceptor like" context propagation</para>
	    </listitem>
	</itemizedlist>
      </para>
      <para>CAROL is design to be use by: <itemizedlist>
	  <listitem>
	    <para><ulink url="http://www.objectweb.org/jonas">ObjectWeb-JOnAS</ulink> EJB Server</para>
	  </listitem>
	  <listitem>
	    <para><ulink url="http://www.objectweb.org/jotm">ObjectWeb-JOTM</ulink> Transaction Manager</para>
	  </listitem>
	</itemizedlist>
      </para>
      
    </sect2>
    <sect2>
      <title>
	Risks
      </title>
      <para>The identified risks of this architecture are: 
	<itemizedlist>
	  <listitem>
	    <para>The integration difficulty of this library in JOnAS is the GENIC integration and the configuration integration</para>
	  </listitem>
	  <listitem>
	    <para>The standard files <filename>orb.properties</filename> and <filename>jndi.properties</filename> will be more complicated</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>
      Standard convention and Exception
    </title>
    <abstract>
      <para>This section describe the standards used by <abbrev>CAROL</abbrev>: <itemizedlist>
	  <listitem>
	    <para><abbrev>RMI IIOP</abbrev>: The <abbrev>RMI</abbrev> base on the <abbrev>CORBA IIOP</abbrev></para>
	  </listitem>
	  <listitem>
	    <para><abbrev>JNDI</abbrev>: The Java Naming Directory Interface</para>
	  </listitem>
	  <listitem>
	    <para>Portable Interceptor: The standard <abbrev>CORBA</abbrev> Context propagation</para>
	  </listitem>
	</itemizedlist>
	There is also a description of the <abbrev>CAROL</abbrev> exceptions to those standards</para>
    </abstract>
    <sect2>
      <title><abbrev>RMI IIOP</abbrev> Standard convention</title>
      <abstract>
	<para>this section describe the <ulink url="http://java.sun.com/j2se/1.4/docs/guide/rmi-iiop/index.html"><abbrev>RMI IIOP</abbrev></ulink> standard </para>
      </abstract>
      <sect3>
	<title><abbrev>RMI IIOP</abbrev> developer mechanism</title>
	<para>The <abbrev>IIOP</abbrev> personality of<abbrev> RMI</abbrev> is a standard simplify way for exporting JAVA Remote Object through <abbrev>CORBA</abbrev>. <abbrev>RMI IIOP</abbrev> is an abstarction for simplify the <abbrev>CORBA</abbrev> mechanism. An <abbrev>RMI IIOP</abbrev> object is: 
	  <itemizedlist>
	    <listitem>
	      <para>The object accessible remote methods are specify in the remote object remote interface</para>
	    </listitem>
	    <listitem>
	      <para>The object remote interface have to extends the <classname>java.rmi.Remote</classname> Interface</para>
	    </listitem>
	    <listitem>
	      <para>The remote object have to be compile with both java compiler (javac, jikes ...) and <abbrev>RMI IIOP</abbrev> compiler (rmic -iiop, david rmic, ...)</para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>At Runtime the remote object have to be export by <classname>javax.rmi.PortableRemoteObject</classname> (<abbrev>PRO</abbrev>). This export can be made by the  <abbrev>PRO</abbrev> constructor (the remote object can extends <abbrev>PRO</abbrev> or with the static export method of <abbrev>PRO</abbrev>. This Object have also to be bind in a names service (CosNaming, <abbrev>LDAP</abbrev>, ...) to be access by remote clients.
	</para>
      </sect3>
      <sect3>
	<title><abbrev>RMI IIOP</abbrev> architecture overview</title>
	<para>The <abbrev>RMI IIOP</abbrev> architecture is base on a delegation model. This delegation can be configure in the <abbrev>JVM</abbrev> by system properties. Those system properties are:
	  <variablelist>
	    <varlistentry>
	      <term>javax.rmi.CORBA.PortableRemoteObjectClass</term>
	      <listitem>
		<para>This <abbrev>RMI IIOP</abbrev> system properties define the delegation class for <classname>javax.rmi.PortableRemoteObject</classname> methods delegation. If this properties null, the default sun class is used. This is a very important properties because it permise to set our own <classname>PortableRemoteObjectDelegate</classname> class in the JVM. This is the entry point of <abbrev>RMI IIOP</abbrev> <abbrev>JVM</abbrev> configuration.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>javax.rmi.CORBA.UtilClass</classname></term>
	      <listitem>
		<para>This <abbrev>RMI IIOP</abbrev> system properties define the delegation class for <classname>javax.rmi.CORBA.Util</classname> methods delegation. If this properties null, the default sun class is used.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>javax.rmi.CORBA.StubClass</classname></term>
	      <listitem>
		<para>This <abbrev>RMI IIOP</abbrev> system properties define the delegation class for <classname>javax.rmi.CORBA.Stub</classname> methods delegation. If this properties null, the default sun class is used.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>org.omg.CORBA.ORBClass</classname></term>
	      <listitem>
		<para>This <abbrev>CORBA</abbrev> system properties define class for the <abbrev>CORBA</abbrev> ORB class. If this properties null, the default sun class is used.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>org.omg.CORBA.ORBSingletonClass</classname></term>
	      <listitem>
		<para>This <abbrev>CORBA</abbrev> system properties define class for the <abbrev>CORBA</abbrev> ORB Singleton class. If this properties null, the default sun class is used.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  The schema behind show the separation between the <abbrev>RMI IIOP</abbrev> Server, The <abbrev>RMI IIOP</abbrev> provider configuration and the <abbrev>CORBA</abbrev> provider configuration:
	</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="img/rmi-iiop.jpg" format="jpg" align="center">
	  </imageobject>
	</mediaobject>
	<para>So, with this RMI architecture we can use, by <abbrev>JVM</abbrev> configuration, any <abbrev>RMI IIOP</abbrev> provider and <abbrev>CORBA</abbrev> Provider</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Java Naming Directory Interface (<abbrev>JNDI</abbrev>) Standard convention</title>
<abstract>
	<para>this section describe the <ulink url="http://java.sun.com/j2se/1.4/docs/guide/jndi/index.html"><abbrev>JNDI</abbrev></ulink> standard convention</para>
      </abstract>
      <sect3>
	<title><abbrev>JNDI</abbrev> developer mechanism</title>
	<para>The <abbrev>JNDI</abbrev> is a standard Java convention for name service abstraction. Those specification provide:
	  <itemizedlist>
	    <listitem>
	      <para><abbrev>API</abbrev> : Application Programming Interface, a simple way for a Java server to interact with a name service (like a rmiregistry or a CosNaming) </para>
	    </listitem>
	    <listitem>
	      <para><abbrev>SPI</abbrev> : Service Provider Interface, a layer interface for adding "plug and play" name service</para>
	    </listitem>
	  </itemizedlist>
	</para
	<para>A Java server developer can use the <abbrev>JNDI</abbrev> API  facilities for name service interaction. This <abbrev>API</abbrev> is primarily the <classname>javax.naming.InitialContext </classname> interface. The server <abbrev>JNDI</abbrev> configuration use the <filename>jndi.properties</filename>. A server using CAROL have to only use the <abbrev>JNDI API</abbrev> to contact the several name service.</para>
	<para>The <abbrev>JNDI SPI</abbrev> provide way to "plug" a name service to a <abbrev>JVM</abbrev>. CAROL use this <abbrev>SPI</abbrev> to provide a multi name service using a multi jndi configuration. This <abbrev>SPI</abbrev> is configure by the file <filename>jndi.properties</filename></para>
      </sect3>
      <sect3>
	<title><abbrev>JNDI</abbrev> architecture overview</title>
	<para>The <abbrev>JNDI</abbrev> atchitecture is based on a delegation with factory model. This factory for delegate objects can be configure into the <abbrev>JVM</abbrev> by system properties. Those system properties are:
	<variablelist>
	  <varlistentry>
	    <term><classname>java.naming.factory.initial</classname></term>
	    <listitem>
	      <para>This property set the factory class name for the <classname>InitialContext</classname> factory. The standard <classname>javax.naming.InitialContext</classname> is in fact a delegation to a context build by this factory</para>
	    </listitem> 
	  </varlistentry>
	  <varlistentry>
	    <term><classname>java.naming.provider.url</classname></term>
	    <listitem>
	      <para>This property set the runtime location of the name service</para>
	    </listitem>	
	  </varlistentry>
	  <varlistentry>
	    <term><classname>java.naming.factory.url.pkgs</classname></term>
	    <listitem>
	      <para>This property set the package name of the specific classes for managing name service call with special address header (like rmi://java:comp/env)</para>
	    </listitem>	
	  </varlistentry>
	</variablelist>
	  The schema behind show the separation between the <abbrev>JNDI API</abbrev>, The <abbrev>JNDI SPI</abbrev> and the Java server using those features:
	</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="img/jndi.jpg" format="jpg" align="center">
	  </imageobject>
	</mediaobject>
	<para>So, with <abbrev>JNDI</abbrev> architecture a server can use, by <abbrev>JVM</abbrev> configuration, any name service provider</para>
      </sect3>
    </sect2>
    <sect2>
      <title>PortableInterceptor Standard convention</title>
      <abstract>
	<para>this section describe the <ulink url="http://cgi.omg.org/cgi-bin/doc?ptc/2001-03-04"><abbrev>PortableInterceptor</abbrev></ulink> standard convention</para>
      </abstract>
      <sect3>
	<title>Portable Interceptor developer mechanism</title>
	<para>The Portable Interceptor is a standard convention for method call interception in a <abbrev>CORBA</abbrev> BUS. the specification provide:<variablelist>
	    <varlistentry>
	      <term><classname>ORBInitializer</classname> interface:</term>
	      <listitem>
		<para>This interface provide a simple way for ORB Interceptor initialization. This interface define methods:
		  <programlisting>pre_init(ORBInfo orbi);</programlisting><programlisting>post_init(ORBInfo orbi);</programlisting> In those methods the ORBInitializer implementation can make (for example) <programlisting>orbi.add_client_request(my_client_interceptor);</programlisting><programlisting>orbi.add_server_request(my_server_interceptor);</programlisting> to set his own client or server interceptor in the <abbrev>CORBA</abbrev> bus. This ORBInitilizer his set in the <abbrev>CORBA</abbrev> BUS <abbrev>JVM</abbrev> by the a system properties (see behind)</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>ClientRequestInterceptor</classname> interface:</term>
	      <listitem>
		<para>This interface provide a simple way for ORB Interceptions on the server side interception. In this interface there is methods like :
		  <programlisting>send_request(ClientInfo ci);</programlisting><programlisting>receive_reply(ClientInfo ci);</programlisting> In those methods the Client Request Interceptor implementation can make (for example) <programlisting>ci.add_service_context(my_context);</programlisting> to set his own client context handle by method call in the <abbrev>CORBA</abbrev> bus. This Client Interceptor is set by the ORBInitilizer class</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>ServerRequestInterceptor</classname> interface:</term>
	      <listitem>
		<para>This interface provide a simple way for ORB Interceptions on the server side. In this interface ther is methods like :
		  <programlisting>receive_request(ServerInfo si);</programlisting><programlisting>sebd_reply(ServerInfo si);</programlisting> In those methods the Server Request Interceptor implementation can make (for example) <programlisting>si.get_service_context(my_context);</programlisting> to get the client context handle by method call in the <abbrev>CORBA</abbrev> bus. This Server Interceptor is set by the ORBInitilizer class</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
      <sect3>
	<title>Portable Interceptor architecture overview</title>
	<para>The Portable Interceptor architecture is base on a instantiation model. This instantiation can be configure in the <abbrev>JVM</abbrev> by system properties and Initializer classes. Those system properties are:
	  <variablelist>
	    <varlistentry>
	      <term><classname>org.omg.PortableInterceptor.ORBInitializerClass.org.objectweb.orb.Initializer1</classname></term>
	      <listitem>
		<para>Where <classname>org.objectweb.orb</classname> is the package location of my <classname>Initializer1</classname> ORBInitializer.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><classname>org.omg.PortableInterceptor.ORBInitializerClass.org.objectweb.orb.Initializer2</classname></term>
	      <listitem>
		<para>A <abbrev>JVM</abbrev> accept several initializer. All those initializers methods where call at the <abbrev>ORB</abbrev> initialization state, but there is no specifications about the order of those initializations</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  The schema behind show the general mechanism of an <abbrev>ORB</abbrev> with server and client interceptors:
	</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="img/pi.jpg" format="jpg" align="center">
	  </imageobject>
	</mediaobject>
	<para>So, with this RMI architecture we can use, by <abbrev>JVM</abbrev> configuration, any <abbrev>RMI IIOP</abbrev> provider and <abbrev>CORBA</abbrev> Provider</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>
      Product functionality
    </title>
    <sect2>
      <title>CAROL Requested features</title>
      <abstract>
	<para>This section describe the request features for the CAROL Library. The specification document explain how CAROL technically resolve all those request features </para>
      </abstract>
      <sect3>
	<title>Server <abbrev>RMI</abbrev> provider independence</title>
	<para>The CAROL library have to identify and provide the general way to make a server "<abbrev>RMI</abbrev> provider independent. Independent mean: 
	  <itemizedlist>
	    <listitem>
	      <para>Provide a standard configuration mechanism for all <abbrev>RMI</abbrev> provider <abbrev>JVM</abbrev> instantiation</para>
	    </listitem>
	    <listitem>
	      <para>Provide "provider independent" <abbrev>RMI</abbrev> server development mechanism (<abbrev>API</abbrev>)</para>
	    </listitem>
	    <listitem>
	      <para>Provide the library interface for adding new <abbrev>RMI</abbrev> Provider classes (<abbrev>SPI</abbrev>)</para>
	    </listitem>	    
	  </itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>Server <abbrev>RMI</abbrev> architecture independence</title>
	<para>The CAROL library have to identify and provide the general way to make a server "<abbrev>RMI</abbrev> architecture independent (IIOP, JRMP ...). Independent mean: 
	  <itemizedlist>
	    <listitem>
	      <para>Provide a standard configuration mechanism for all <abbrev>RMI</abbrev> architecture</para>
	    </listitem>
	    <listitem>
	      <para>Provide "architecture independent" <abbrev>RMI</abbrev> server development mechanism (<abbrev>API</abbrev>)</para>
	    </listitem>
	    <listitem>
	      <para>Provide the library interface for adding new <abbrev>RMI</abbrev> architecture (<abbrev>SPI</abbrev>)</para>
	    </listitem>	    
	  </itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>Server <abbrev>Multi RMI</abbrev> architecture</title>
	<para>The CAROL library have to identify and provide the general way to make a server "<abbrev>Multi RMI</abbrev>" accessible. Multi RMI accessible mean:
	  <itemizedlist>
	    <listitem>
	      <para>Provide a standard configuration mechanism for <abbrev>Multi RMI</abbrev> support </para>
	    </listitem>
	    <listitem>
	      <para>Provide library (Multi PortableRemoteObjectDelegate) for remote object multi export/unexport </para>
	    </listitem>
	    <listitem>
	      <para>Provide <abbrev>JNDI</abbrev> SPI which can support mutli name service</para>
	    </listitem>
	    <listitem>
	      <para>Provide Library for <abbrev>Multi RMI</abbrev> management</para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>CAROL Basic SPI</title>
	<para>The CAROL library have to provide his SPI for: 
	  <itemizedlist>
	    <listitem>
	      <para>JEREMIE: the ObjectWeb-Jonathan RMI Like</para>
	    </listitem>
	    <listitem>
	      <para>DAVID: The ObjectWeb-Jonathan RMI IIOP</para>
	    </listitem>
	    <listitem>
	      <para>Sun RMI-JRMP: The jdk >1.2 RMI JRMP </para>
	    </listitem>
	    <listitem>
	      <para>Sun RMI-IIOP: The jdk >1.4 RMI IIOP</para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>    
    </sect2>
    <sect2> 
      <title>CAROL Requested Documentation</title>
      <abstract>
	<para>This section describe the request documentation for the CAROL Library.</para>
      </abstract>
      <sect3>
	<title>The CAROL Specification</title>
	<para>This document is the technical specification of CAROL. It's compose of coding architecture aspects of CAROL </para>
      </sect3>
      <sect3>
	<title>The CAROL user guide</title>
	<para>This document is for CAROL Library user. It's compose of configuration methods to plug/active a/some RMI Provider and integration methods for CAROL use in a Java Server</para>
      </sect3>
      <sect3>
	<title>The CAROL developer guide</title>
	<para>This document id for CAROL developer. It's compose of methods to plug a new RMU Architecture is CAROL</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>
      Functional relationship with other products
    </title>
    <sect2>
      <title>Products used by CAROL/CAROL Requirements</title>
      <abstract>
	<para>This section describe the "use" relation between CAROL and other products. This section list also the version of those products</para>
      </abstract>
      <sect3>
	<title>ObjectWeb products</title>
	<para>The Carol library provide mechanism for using DAVID and JEREMIE Object web project. CAROL need a >3.0 version of Jonathan</para>
      </sect3>
      <sect3>
	<title>Other products</title>
	<para>The Carol library provide mechanism for using RMi JRMP (jdk >1.2) and RMI IIOP (j2se >1.4)</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Products using CAROL/CAROL Requirements</title>
      <abstract>
	<para>This section describe the "is use by" relation between CAROL and other products. This section list also the version of those products</para>
      </abstract>
      <sect3>
	<title>ObjectWeb products</title>
	<para>The Carol library will be integrate in JOTM and in JOnAS (>2.5)</para>
      </sect3>
    </sect2>
  </sect1>
</article>
