# JavaCore Configurable Options
#
# Recognized options are listed below,
# optionName = possibleValue1(valueIndex1)| [possibleValue2(valueIndex2)]
# or
# optionName = type(min,max)[value]
#
# component default value are between [ ]

### debugLocalVariable = Generate(0) | [Do not generate(1)]
###      When generated, this attribute will enable local variable names to be displayed 
###      in debugger, only in place where variables are definitely assigned 
###      (.class file is then bigger)
org.eclipse.jdt.internal.compiler.Compiler.debugLocalVariable = 0

### debugLineNumber = [Generate(0)] | Do not generate(1)
###      When generated, this attribute will enable source code highlighting in debugger 
###      (.class file is then bigger).
org.eclipse.jdt.internal.compiler.Compiler.debugLineNumber = 0

### debugSourceFile = [Generate(0)] | Do not generate(1)
###      When generated, this attribute will enable the debugger to present the 
###      corresponding source code.
org.eclipse.jdt.internal.compiler.Compiler.debugSourceFile = 0

### codegenUnusedLocal = Preserve(0) | [Optimize out(1)]
###      Unless requested to preserve unused local variables (i.e. never read), the 
###      compiler will optimize them out, potentially altering debugging
org.eclipse.jdt.internal.compiler.Compiler.codegenUnusedLocal = 0

### codegenTargetPlatform = [1.1(0)] | 1.2(1)
###      Generate .class files either backward compatible with JVM 1.1 or only executable 
###      on JVM 1.2 and later
org.eclipse.jdt.internal.compiler.Compiler.codegenTargetPlatform = 0

### problemUnreachableCode = [Error(0)] | Warning(1) | Ignore(2)
###      Unreachable code can either be reported as an error or a warning
org.eclipse.jdt.internal.compiler.Compiler.problemUnreachableCode = 0

### problemInvalidImport = [Error(0)] | Warning(1) | Ignore(2)
###      An import statement that cannot be resolved might either be reported 
###      either as an error or as a warning
org.eclipse.jdt.internal.compiler.Compiler.problemInvalidImport = 0

### problemOverridingPackageDefaultMethod = Error(0) | [Warning(1)] | Ignore(2)
###      A package default method is not visible in a different package, and thus 
###      cannot be overriden. When enabling this option, the compiler will signal 
###      such scenarii.
org.eclipse.jdt.internal.compiler.Compiler.problemOverridingPackageDefaultMethod = 1

### problemMethodWithConstructorName = Error(0) | [Warning(1)] | Ignore(2)
###      Naming a method with a constructor name is generally considered poor 
###      style programming. When enabling this option, the compiler will signal such 
###      scenarii
org.eclipse.jdt.internal.compiler.Compiler.problemMethodWithConstructorName = 1

### problemDeprecation = Error(0) | [Warning(1)] | Ignore(2)
###      When enabled, the compiler will signal use of deprecated API.
org.eclipse.jdt.internal.compiler.Compiler.problemDeprecation = 1

### problemHiddenCatchBlock = Error(0) | [Warning(1)] | Ignore(2)
###      Locally to a try statement, some catch blocks may hide others 
###      (e.g. 	try {	throw new java.io.CharConversionException();
###                 } catch (java.io.CharConversionException e) {
###                 } catch (java.io.IOException e) {}). 
###      When enabling this option, the compiler will issue a warning for hidden catch 
###      blocks corresponding to checked exceptions
org.eclipse.jdt.internal.compiler.Compiler.problemHiddenCatchBlock = 1

### problemUnusedLocal = Error(0) | [Warning(1)] | Ignore(2)
###      When enabled, the compiler will issue a warning for unused local variables 
###      (i.e. variables never read from)
org.eclipse.jdt.internal.compiler.Compiler.problemUnusedLocal = 2

### problemUnusedParameter = Error(0) | [Warning(1)] | Ignore(2)
###      When enabled, the compiler will issue a warning for unused method parameters 
###      (i.e. parameters never read from)
org.eclipse.jdt.internal.compiler.Compiler.problemUnusedParameter = 2

### problemSyntheticAccessEmulation = Error(0) | Warning(1) | [Ignore(2)]
###      When enabled, the compiler will issue a warning whenever it emulates access 
###      to a non-accessible member of an enclosing type
org.eclipse.jdt.internal.compiler.Compiler.problemSyntheticAccessEmulation = 2

### problemNonExternalizedStringLiteral = Error(0) | Warning(1) | [Ignore(2)]
###      When enabled, the compiler will issue a warning for non externalized String literal 
org.eclipse.jdt.internal.compiler.Compiler.problemNonExternalizedStringLiteral = 1

### problemAssertIdentifier = Error(0) | [Warning(1)] | Ignore(2)
###      When enabled, the compiler will issue a warning whenever 'assert' is used as
###      an identifier (reserved keyword in 1.4)
org.eclipse.jdt.internal.compiler.Compiler.problemAssertIdentifier = 2

### computeJavaBuildOrder = Compute(0)| [Ignore(1)]
###     When enabled, the build order is automatically reflecting the classpath on each
###     classpath change action. It can still be modified manually afterwards.
org.eclipse.jdt.core.JavaCore.computeJavaBuildOrder = 1

### newlineOpeningBrace = Insert(0) | [Do not insert(1)]
###    When Insert, a new line is inserted before an opening brace, otherwise nothing
###    is inserted
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineOpeningBrace=1

### newlineControlStatement.possibleValues = Insert(0) | [Do not insert(1)]
###    When Insert, a new line is inserted between } and else, catch, finally
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineControlStatement=1

### newlineClearAll.possibleValues = Clear(0) | [Preserve one(1)]
###    When Clear, all blank lines are removed. When Preserve one, only one is kept
###    and all others removed.
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineClearAll=1

### newlineElseIf.possibleValues = [Yes(0)] | No(1)
###    When Yes, a blank line is inserted between a else and a if when they are contiguous
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineElseIf=0

### newlineEmptyBlock.possibleValues = [Insert(0)] | Do not insert(1)
###    When insert, a line break is inserted between contiguous { and }, if } is not followed
###    by a keyword.
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineEmptyBlock=0

### lineSplit.possibleValues = int(1,no)[80]
###    Enable splitting of long lines (exceeding the configurable length). Length of 0 will
###    disable line splitting
org.eclipse.jdt.internal.formatter.CodeFormatter.lineSplit=80

### tyleCompactAssignment.possibleValues = Compact(0) | [Normal(1)]
###    Assignments can be formatted asymmetrically, e.g. 'int x= 2;', when Normal, a space
###    is inserted before the assignment operator
org.eclipse.jdt.internal.formatter.CodeFormatter.styleCompactAssignment=1

### tabulationChar.possibleValues = [Tab(0)] | Spaces(1)
###    Either choose to indent with tab characters or spaces
org.eclipse.jdt.internal.formatter.CodeFormatter.tabulationChar=0

### tabulationSize.possibleValues = int(0,no)[4]
###    Tabulation size in term of space characters
org.eclipse.jdt.internal.formatter.CodeFormatter.tabulationSize=4


