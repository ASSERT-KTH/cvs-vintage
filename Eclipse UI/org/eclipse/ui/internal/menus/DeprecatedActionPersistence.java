/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 ******************************************************************************/

package org.eclipse.ui.internal.menus;

import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.eclipse.core.commands.Category;
import org.eclipse.core.commands.Command;
import org.eclipse.core.commands.ParameterizedCommand;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IRegistryChangeEvent;
import org.eclipse.core.runtime.IRegistryChangeListener;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.bindings.Binding;
import org.eclipse.jface.bindings.BindingManager;
import org.eclipse.jface.bindings.Scheme;
import org.eclipse.jface.bindings.keys.IKeyLookup;
import org.eclipse.jface.bindings.keys.KeyBinding;
import org.eclipse.jface.bindings.keys.KeyLookupFactory;
import org.eclipse.jface.bindings.keys.KeySequence;
import org.eclipse.jface.bindings.keys.KeyStroke;
import org.eclipse.jface.contexts.IContextIds;
import org.eclipse.jface.menus.SActionSet;
import org.eclipse.jface.menus.SReference;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.commands.ICommandImageService;
import org.eclipse.ui.commands.ICommandService;
import org.eclipse.ui.internal.IWorkbenchConstants;
import org.eclipse.ui.internal.commands.CommonCommandPersistence;
import org.eclipse.ui.internal.util.BundleUtility;
import org.eclipse.ui.menus.IMenuService;

/**
 * <p>
 * A static class for reading actions from the registry. Actions were the
 * mechanism in 3.1 and earlier for contributing to menus and tool bars in the
 * Eclipse workbench. They have since been replaced with commands.
 * </p>
 * <p>
 * This class is not intended for use outside of the
 * <code>org.eclipse.ui.workbench</code> plug-in.
 * </p>
 * <p>
 * <strong>EXPERIMENTAL</strong>. This class or interface has been added as
 * part of a work in progress. There is a guarantee neither that this API will
 * work nor that it will remain the same. Please do not use this API without
 * consulting with the Platform/UI team.
 * </p>
 * 
 * @since 3.2
 */
public final class DeprecatedActionPersistence extends CommonCommandPersistence {

	/**
	 * The name of the accelerator attribute, which is a (very old) attempt to
	 * binding an accelerator to a command.
	 */
	private static final String ATTRIBUTE_ACCELERATOR = "accelerator"; //$NON-NLS-1$

	/**
	 * The name of the definitionId attribute, which is a reference to a command
	 * identifier on actions.
	 */
	private static final String ATTRIBUTE_DEFINITION_ID = "definitionId"; //$NON-NLS-1$

	/**
	 * The name of the tooltip attribute, which equates to the description for a
	 * command.
	 */
	private static final String ATTRIBUTE_TOOLTIP = "tooltip"; //$NON-NLS-1$

	/**
	 * The prefix that all auto-generated identifiers start with. This makes the
	 * identifier recognizable as auto-generated, and further helps ensure that
	 * it does not conflict with existing identifiers.
	 */
	private static final String AUTOGENERATED_PREFIX = "AUTOGEN:::"; //$NON-NLS-1$

	/**
	 * The name of the deprecated action element.
	 */
	private static final String ELEMENT_ACTION = "action"; //$NON-NLS-1$

	/**
	 * The name of the <code>org.eclipse.ui.actionSets</code> extension point.
	 */
	private static final String EXTENSION_ACTION_SETS = PlatformUI.PLUGIN_ID
			+ '.' + IWorkbenchConstants.PL_ACTION_SETS;

	/**
	 * The index of the action set elements in the indexed array.
	 * 
	 * @see DeprecatedActionPersistence#read(ICommandService, BindingManager,
	 *      ICommandImageService, IMenuService)
	 */
	private static final int INDEX_ACTION_SETS = 0;

	/**
	 * Extracts any key bindings from the action. If such a binding exists, it
	 * is added to the binding manager.
	 * 
	 * @param element
	 *            The action from which the binding should be read; must not be
	 *            <code>null</code>.
	 */
	private static final void convertActionToBinding(
			final IConfigurationElement element, final Command command,
			final BindingManager bindingManager) {
		// Figure out which accelerator text to use.
		String acceleratorText = readOptionalFromRegistry(element,
				ATTRIBUTE_ACCELERATOR);
		if (acceleratorText == null) {
			final String label = readOptionalFromRegistry(element,
					ATTRIBUTE_LABEL);
			if (label != null) {
				acceleratorText = Action.extractAcceleratorText(label);
			}
		}

		// If there is some accelerator text, generate a key sequence from it.
		if (acceleratorText != null) {
			final IKeyLookup lookup = KeyLookupFactory.getSWTKeyLookup();
			final int acceleratorInt = Action
					.convertAccelerator(acceleratorText);
			final int modifierMask = lookup.getAlt() | lookup.getCommand()
					| lookup.getCtrl() | lookup.getShift();
			final int modifierKeys = acceleratorInt & modifierMask;
			final int naturalKey = acceleratorInt & ~modifierMask;
			final KeyStroke keyStroke = KeyStroke.getInstance(modifierKeys,
					naturalKey);
			final KeySequence keySequence = KeySequence.getInstance(keyStroke);

			final Scheme activeScheme = bindingManager.getActiveScheme();
			final ParameterizedCommand parameterizedCommand = new ParameterizedCommand(
					command, null);

			final Binding binding = new KeyBinding(keySequence,
					parameterizedCommand, activeScheme.getId(),
					IContextIds.CONTEXT_ID_WINDOW, null, null, null,
					Binding.SYSTEM);
			bindingManager.addBinding(binding);
		}
	}

	/**
	 * Determine which command to use. This is slightly complicated as actions
	 * do not have to have commands, but the new architecture requires it. As
	 * such, we will auto-generate a command for the action if the definitionId
	 * is missing or points to a command that does not yet exist. All such
	 * command identifiers are prefixed with AUTOGENERATED_COMMAND_ID_PREFIX.
	 * 
	 * @param element
	 *            The action element from which a command must be generated;
	 *            must not be <code>null</code>.
	 * @param primaryId
	 *            The primary identifier to use when auto-generating a command;
	 *            must not be <code>null</code>.
	 * @param secondaryId
	 *            The secondary identifier to use when auto-generating a
	 *            command; must not be <code>null</code>.
	 * @param commandService
	 *            The command service in which the command should be defined;
	 *            must not be <code>null</code>.
	 * @param warningsToLog
	 *            The collection of warnings logged while reading the extension
	 *            point; must not be <code>null</code>.
	 * @return the identifier of the command; <code>null</code> if an error
	 *         occurred.
	 */
	private static final Command convertActionToCommand(
			final IConfigurationElement element, final String primaryId,
			final String secondaryId, final ICommandService commandService,
			final List warningsToLog) {
		String commandId = readOptionalFromRegistry(element,
				ATTRIBUTE_DEFINITION_ID);
		Command command = null;
		if (commandId != null) {
			command = commandService.getCommand(commandId);
		}

		String label = null;
		if ((commandId == null) || (!command.isDefined())) {
			if (commandId == null) {
				commandId = AUTOGENERATED_PREFIX + primaryId + '/'
						+ secondaryId;
			}

			// Read the label attribute.
			label = readRequiredFromRegistry(element, ATTRIBUTE_LABEL,
					warningsToLog, "Actions require a label"); //$NON-NLS-1$
			if (label == null) {
				return null;
			}

			/*
			 * Read the tooltip attribute. The tooltip is really the description
			 * of the command.
			 */
			final String tooltip = readOptionalFromRegistry(element,
					ATTRIBUTE_TOOLTIP);

			// Define the command.
			command = commandService.getCommand(commandId);
			final Category category = commandService.getCategory(null);
			final String name = Action.removeAcceleratorText(Action
					.removeMnemonics(label));
			command.define(name, tooltip, category, null);
		}

		return command;
	}

	/**
	 * Extracts any image definitions from the action. These are defined as
	 * image bindings on the given command with an auto-generated style.
	 * 
	 * @param element
	 *            The action element from which the images should be read; must
	 *            not be <code>null</code>.
	 * @param command
	 *            The command to which the images should be bound; must not be
	 *            <code>null</code>.
	 * @param commandImageService
	 *            The service with which the images need to be registered; must
	 *            not be <code>null</code>.
	 * @return The image style used to define these images; may be
	 *         <code>null</code>.
	 */
	private static final String convertActionToImages(
			final IConfigurationElement element, final Command command,
			final ICommandImageService commandImageService) {
		final String commandId = command.getId();

		// Read the icon attributes.
		final String icon = readOptionalFromRegistry(element, ATTRIBUTE_ICON);
		final String disabledIcon = readOptionalFromRegistry(element,
				ATTRIBUTE_DISABLED_ICON);
		final String hoverIcon = readOptionalFromRegistry(element,
				ATTRIBUTE_HOVER_ICON);

		// Check if at least one is defined.
		if ((icon == null) && (disabledIcon == null) && (hoverIcon == null)) {
			return null;
		}

		final String style = commandImageService.generateUnusedStyle(commandId);

		// Bind the images.
		if (icon != null) {
			final URL iconURL = BundleUtility
					.find(element.getNamespace(), icon);
			commandImageService.bind(commandId,
					ICommandImageService.TYPE_DEFAULT, style, iconURL);
		}
		if (disabledIcon != null) {
			final URL disabledIconURL = BundleUtility.find(element
					.getNamespace(), disabledIcon);
			commandImageService.bind(commandId,
					ICommandImageService.TYPE_DISABLED, style, disabledIconURL);
		}
		if (hoverIcon != null) {
			final URL hoverIconURL = BundleUtility.find(element.getNamespace(),
					hoverIcon);
			commandImageService.bind(commandId,
					ICommandImageService.TYPE_HOVER, style, hoverIconURL);
		}

		return style;
	}

	/**
	 * Reads the actions, and defines all the necessary subcomponents in terms
	 * of the command architecture. For each action, there could be a command, a
	 * command image binding, a handler and a menu item.
	 * 
	 * @param primaryId
	 *            The identifier of the primary object to which this action
	 *            belongs. This is used to auto-generate command identifiers
	 *            when required. The <code>primaryId</code> must not be
	 *            <code>null</code>.
	 * @param elements
	 *            The action elements to be read; must not be <code>null</code>.
	 * @param warningsToLog
	 *            The collection of warnings while parsing this extension point;
	 *            must not be <code>null</code>.
	 * @param commandService
	 *            The command service for the workbench; must not be
	 *            <code>null</code>.
	 * @param bindingManager
	 *            The binding manager for the workbench; must not be
	 *            <code>null</code>.
	 * @param commandImageService
	 *            The command image service for the workbench; must not be
	 *            <code>null</code>.
	 * @return References to the created menu elements; may be <code>null</code>,
	 *         and may be empty.
	 */
	private static final SReference[] readActions(final String primaryId,
			final IConfigurationElement[] elements, final List warningsToLog,
			final ICommandService commandService,
			final BindingManager bindingManager,
			final ICommandImageService commandImageService) {
		final Collection references = new ArrayList(elements.length);
		for (int i = 0; i < elements.length; i++) {
			final IConfigurationElement element = elements[i];

			/*
			 * We might need the identifier to generate the command, so we'll
			 * read it out now.
			 */
			final String id = readRequiredFromRegistry(element, ATTRIBUTE_ID,
					warningsToLog, "Actions require an id"); //$NON-NLS-1$
			if (id == null) {
				continue;
			}

			// Try to break out the command part of the action.
			final Command command = convertActionToCommand(element, primaryId,
					id, commandService, warningsToLog);
			if (command == null) {
				continue;
			}

			// Add the handler.
			// TODO Read the class.
			// TODO Read the enablesFor.

			// Add a binding if necessary.
			convertActionToBinding(element, command, bindingManager);

			// Add the image bindings.
			/* final String imageStyle = */convertActionToImages(element,
					command, commandImageService);

			// Read the menu element.
			// TODO Read the id.
			// TODO Read the menubarPath.
			// TODO Read the toolbarPath.
			// TODO Read the style.
			// TODO Read the state.
			// TODO Read the pulldown.

			// Create the menu item.

			references.add(new SReference(SReference.TYPE_ITEM, id));
		}

		return (SReference[]) references.toArray(new SReference[references
				.size()]);
	}

	/**
	 * Reads the deprecated actions from an array of elements from the action
	 * sets extension point.
	 * 
	 * @param configurationElements
	 *            The configuration elements in the extension point; must not be
	 *            <code>null</code>, but may be empty.
	 * @param configurationElementCount
	 *            The number of configuration elements that are really in the
	 *            array.
	 * @param commandService
	 *            The command service to which the command should be added; must
	 *            not be <code>null</code>.
	 * @param bindingManager
	 *            The binding manager to which the bindings should be added;
	 *            must not be <code>null</code>.
	 * @param commandImageService
	 *            The command image service to which the images should be added;
	 *            must not be <code>null</code>.
	 * @param menuService
	 *            The menu service to which the menu elements should be added;
	 *            must not be <code>null</code>.
	 */
	private static final void readActionSetsFromRegistry(
			final IConfigurationElement[] configurationElements,
			final int configurationElementCount,
			final ICommandService commandService,
			final BindingManager bindingManager,
			final ICommandImageService commandImageService,
			final IMenuService menuService) {
		// TODO Do I need to undefine things here?

		final List warningsToLog = new ArrayList(1);

		for (int i = 0; i < configurationElementCount; i++) {
			final IConfigurationElement configurationElement = configurationElements[i];

			// Read the action set identifier.
			final String id = readRequiredFromRegistry(configurationElement,
					ATTRIBUTE_ID, warningsToLog, "Action sets need an id"); //$NON-NLS-1$
			if (id == null)
				continue;

			// Read the label.
			final String label = readRequiredFromRegistry(configurationElement,
					ATTRIBUTE_LABEL, warningsToLog, "Actions set need a label", //$NON-NLS-1$
					id);

			// Read the description.
			final String description = readOptionalFromRegistry(
					configurationElement, ATTRIBUTE_DESCRIPTION);

			// Read whether the action set should be visible by default.
			final boolean visible = readBooleanFromRegistry(
					configurationElement, ATTRIBUTE_VISIBLE, false);

			// Read its child elements.
			final IConfigurationElement[] actionElements = configurationElement
					.getChildren(ELEMENT_ACTION);
			final SReference[] references = readActions(id, actionElements,
					warningsToLog, commandService, bindingManager,
					commandImageService);
			if ((references == null) || (references.length == 0)) {
				addWarning(warningsToLog,
						"Action sets require one or more actions", //$NON-NLS-1$
						configurationElement.getNamespace(), id);
			}

			// TODO Read out the menus and groups.

			// Define the action set.
			final SActionSet actionSet = menuService.getActionSet(id);
			actionSet.define(label, description, visible, references);
		}

		logWarnings(
				warningsToLog,
				"Warnings while parsing the action sets from the 'org.eclipse.ui.actionSets' extension point"); //$NON-NLS-1$
	}

	/**
	 * Constructs a new instance of <code>DeprecatedActionPersistence</code>.
	 */
	public DeprecatedActionPersistence() {
		// Does nothing.
	}

	/**
	 * <p>
	 * Reads all of the actions from the deprecated extension points. Actions
	 * have been replaced with commands, command images, handlers, menu elements
	 * and action sets.
	 * </p>
	 * 
	 * @param commandService
	 *            The command service which is providing the commands for the
	 *            workbench; must not be <code>null</code>.
	 * @param bindingManager
	 *            The binding manager which should be populated with bindings
	 *            from actions; must not be <code>null</code>.
	 * @param commandImageService
	 *            The command image service which should be populated with the
	 *            images from the actions; must not be <code>null</code>.
	 * @param menuService
	 *            The menu service which should be populated with the values
	 *            from the registry; must not be <code>null</code>.
	 */
	public final void read(final ICommandService commandService,
			final BindingManager bindingManager,
			final ICommandImageService commandImageService,
			final IMenuService menuService) {
		// Create the extension registry mementos.
		final IExtensionRegistry registry = Platform.getExtensionRegistry();
		int actionSetCount = 0;
		final IConfigurationElement[][] indexedConfigurationElements = new IConfigurationElement[5][];

		// Read the actionSets extension point.
		final IConfigurationElement[] actionSetsExtensionPoint = registry
				.getConfigurationElementsFor(EXTENSION_ACTION_SETS);
		for (int i = 0; i < actionSetsExtensionPoint.length; i++) {
			final IConfigurationElement configurationElement = actionSetsExtensionPoint[i];
			final String name = configurationElement.getName();

			// Check if it is a handler submission or a command definition.
			if (ELEMENT_ACTION_SET.equals(name)) {
				addElementToIndexedArray(configurationElement,
						indexedConfigurationElements, INDEX_ACTION_SETS,
						actionSetCount++);
			}
		}

		// TODO Sort the editorActions extension point.

		// TODO Sort the popupMenus extension point.

		// TODO Sort the viewActions extension point.

		readActionSetsFromRegistry(
				indexedConfigurationElements[INDEX_ACTION_SETS],
				actionSetCount, commandService, bindingManager,
				commandImageService, menuService);
		// TODO Read other extension points from the registry.

		/*
		 * Adds listener so that future registry changes trigger an update of
		 * the command manager automatically.
		 */
		if (!listenersAttached) {
			registry.addRegistryChangeListener(new IRegistryChangeListener() {
				public final void registryChanged(
						final IRegistryChangeEvent event) {
					// TODO Determine if something changed.

					/*
					 * At least one of the deltas is non-zero, so re-read all of
					 * the bindings.
					 */
					Display.getDefault().asyncExec(new Runnable() {
						public void run() {
							read(commandService, bindingManager,
									commandImageService, menuService);
						}
					});
				}
			}, PlatformUI.PLUGIN_ID);

			listenersAttached = true;
		}
	}
}
