<?xml version='1.0' encoding='UTF-8' ?>

<!--
This is the XML DTD for the jbosscmp-jdbc deployment descriptor.
  <!DOCTYPE jbosscmp-jdbc PUBLIC
      "-//JBoss//DTD JBOSSCMP-JDBC 3.0//EN"
      "http://www.jboss.org/j2ee/dtd/jbosscmp-jdbc_3_0.dtd">
-->

<!--
The root element of JBossCMP-JDBC configuration files.
-->
<!ELEMENT jbosscmp-jdbc (defaults, enterprise-beans?, relationships?,
         dependent-value-classes?, type-mappings?)>

<!--
The optional defaults elements contains the default values for 
entities, and relationships.
-->
<!ELEMENT defaults (datasource?, type-mapping?, create-table?, remove-table?,
         read-only?, time-out?, select-for-update?, pk-constraint?,
         fk-constraint?, preferred-relation-mapping?, read-ahead?)>


<!--
The optional datasource element contains the jndi-name used to lookup
the datasource.  All database connections used by an entity or relation table are obtained from the datasource. 
-->
<!ELEMENT datasource (#PCDATA)>



<!--
Should the persistence manager attempt to create tables if they are 
not present?

The create-table element must be one of the two following:
         <create-table>true</create-table>
         <create-table>false</create-table>
-->
<!ELEMENT create-table (#PCDATA)>


<!--
Should the persistence manager attempt to remove tables during shutdown?

The remove-table element must be one of the two following:
         <remove-table>true</remove-table>
         <remove-table>false</remove-table>
-->
<!ELEMENT remove-table (#PCDATA)>


<!--
Is the entity or cmp-field read-only?

The read-only element must be one of the two following:
         <read-only>true</read-only>
         <read-only>false</read-only>
-->
<!ELEMENT read-only (#PCDATA)>


<!--
Specifies the ammount of time that a read-only field is considered
valid (milliseconds).
-->
<!ELEMENT time-out (#PCDATA)>


<!--
Should select statements the SELECT ... FOR UPDATE syntax?

The select-for-update element must be one of the two following:
         <select-for-update>true</select-for-update>
         <select-for-update>false</select-for-update>
-->
<!ELEMENT select-for-update (#PCDATA)>


<!--
Should a foreign key constraint be added for this relationship role?

The fk-constraint element must be one of the two following:
         <fk-constraint>true</fk-constraint>
         <fk-constraint>false</fk-constraint>
-->
<!ELEMENT fk-constraint (#PCDATA)>


<!--
Should a primary key constraint be added when creating tables?

The pk-constraint element must be one of the two following:
         <pk-constraint>true</pk-constraint>
         <pk-constraint>false</pk-constraint>
-->
<!ELEMENT pk-constraint (#PCDATA)>


<!--
Specifies the preferred mapping style for relationships.

The preferred-relation-mapping element must be one of the two following:
   <preferred-relation-mapping>foreign-key</preferred-relation-mapping>
   <preferred-relation-mapping>relation-table</preferred-relation-mapping>
-->
<!ELEMENT preferred-relation-mapping (#PCDATA)>

<!--
The read-ahead element can use either #PCDATA (true/false) or a 
strategy, limit, and cache-size element, but not both.  This 
is a problem for most parsers, because it has mixed types.
We should change this synatx.
-->

<!--
Specifies the read ahead strategy.

The read-ahead element must be one of the following:
         <read-ahead>true</read-ahead>

         <read-ahead>false</read-ahead>
         
         <read-ahead>
            <strategy>none</strategy>
         </read-ahead>

         <read-ahead>
            <strategy>on-load</strategy>
            <limit>255</limit>
            <cache-size>1000</cache-size>
         </read-ahead>
-->
<!ELEMENT read-ahead ANY>

<!--
Specifies the strategy used to read-ahead data in queries.

The strategy element must be one of the two following:
         <strategy>none</strategy>
         <strategy>on-load</strategy>
-->
<!ELEMENT strategy (#PCDATA)>


<!--
Specifies the number of entities that will be read in a single 
read-ahead load query. This is effectively the page size. 
-->
<!ELEMENT limit (#PCDATA)>


<!--
Specifies the number of simultaneous queries that can be served by 
the cache for an entity. 
-->
<!ELEMENT cache-size (#PCDATA)>


<!--
The enterprise-beans element contains the entity elements that will 
be configured.
-->
<!ELEMENT enterprise-beans (entity+)>


<!--
The entity element contains the configuration of an entity
-->
<!ELEMENT entity (ejb-name, datasource?, type-mapping?, create-table?, 
         remove-table?, read-only?, time-out?, select-for-update?, 
         pk-constraint?, read-ahead?, table-name?, cmp-field*, 
         eager-load?, lazy-load-groups*, query*)>

<!--
Name of the entity being configured.  This must match an entity declared
in the ejb-jar.xml file.
-->
<!ELEMENT ejb-name (#PCDATA)>


<!--
This is the name of the table that will hold data for this entity. 
Each entity instance will be stored in one row of this table. 
-->
<!ELEMENT table-name (#PCDATA)>


<!--
The cmp-field element contains the configuration of a cmp-field.
-->
<!ELEMENT cmp-field (field-name, read-only?, time-out?, 
         column-name?, ((jdbc-type, sql-type) | (property+))? )>


<!--
Name of the cmp-field being configured.  This must match a cmp-field 
declared for this entity in the ejb-jar.xml file.
-->
<!ELEMENT field-name (#PCDATA)>


<!--
The name of the column that will hold the data for this field.
-->
<!ELEMENT column-name (#PCDATA)>


<!--
This is the JDBC type that is used when setting parameters in a JDBC
PreparedStatement or loading data from a JDBC ResultSet for this 
cmp-field. The valid types are defined in java.sql.Types. 
-->
<!ELEMENT jdbc-type (#PCDATA)>
 

<!--
This is the SQL type that is used in create table statements for 
this field. Valid sql-types are only limited by your database vendor. 
-->
<!ELEMENT sql-type (#PCDATA)>


<!--
The property element contains the configuration of a dependent
value class property of a cmp-field that is the type of a dependent
value class.
-->
<!ELEMENT property (property-name, column-name?, 
         (jdbc-type, sql-type)?)>


<!--
Name of the property being configured. In a dependent-value-class
element this must match a JavaBean property of the class. In a
cmp-field element this must match a flattened propety of the
dependent-value-class field type.
-->
<!ELEMENT property-name (#PCDATA)>


<!--
Contains the fields that are eager loaded for this entity.
-->
<!ELEMENT eager-load (field-name*)>


<!--
Contains the groups of lazy load fields.
-->
<!ELEMENT lazy-load-groups (lazy-load-group+)>


<!--
A group of fields that will be lazy loaded together.
-->
<!ELEMENT lazy-load-group (description, field-name+)>


<!--
Descriptive text.
-->
<!ELEMENT description (#PCDATA)>


<!--
The query element contains the configuration of a query.
-->
<!ELEMENT query (description, query-method, declared-sql?)>


<!--
The query method that being configured.  This must match a 
query-method declared for this entity in the ejb-jar.xml file.
-->
<!ELEMENT query-method (method-name, method-params)>


<!-- 
The name of the query method that is being configured.
-->
<!ELEMENT method-name (#PCDATA)>


<!--
The method-parameters contains the parameters of the method that is
being configured. Method parameters must be in the same order as the
method and have the same type.
-->
<!ELEMENT method-params (method-param*)>


<!--
The java class of one parameter for a query.

An example follows:
   <method-param>java.lang.String</method-param>
-->
<!ELEMENT method-param (#PCDATA)>


<!--
Explicitly declared sql fragments.
-->
<!ELEMENT declared-sql (select?, from?, where?, order?)>

<!--
Delcares what is to be selected.  This element is only allowed
for ejbSelect methods.
-->
<!ELEMENT select (distinct?, ejb-name, field-name?)>


<!--
Delared additional SQl to append to the generated from clause.

Example:  <from>, FullAddressEJB as a</from>
-->
<!ELEMENT from (#PCDATA)>

<!-- 
If the empty distinct element is present, the SELECT DISTINCT 
syntax will be used. This syntax is used by default for ejbSelect
methods that return a java.util.Set.
-->
<!ELEMENT distinct EMPTY>


<!--
Declares the where clause for the query.

Example: <where>TITLE={0} OR ARTIST={0} OR TYPE={0} OR NOTES={0}</where>
-->
<!ELEMENT where (#PCDATA)>


<!--
Declares the order clause for the query.

Example: <order>TITLE</order>
-->
<!ELEMENT order (#PCDATA)>


<!--
The relationships element contains the ejb-relation elements that will 
be configured.
-->
<!ELEMENT relationships (ejb-relation+)>


<!--
The ejb-relation element contains the configuration of an
ejb-relation.
-->
<!ELEMENT ejb-relation (ejb-relation-name, 
         (foreign-key-mapping | table-mapping))>


<!--
Name of the ejb-relation being configured.  This must match an 
ejb-relation declared in the ejb-jar.xml file.
-->
<!ELEMENT ejb-relation-name (#PCDATA)>


<!--
Specifies that the ejb-relation should be mapped with foreign-keys.
This mapping is not available for many-to-many relationships.
-->
<!ELEMENT foreign-key-mapping
         (ejb-relationship-role, ejb-relationship-role)?>


<!--
The ejb-rejationship-role element contains the configuration of an
ejb-relationship-role.
-->
<!ELEMENT ejb-relationship-role (ejb-relationship-role-name,
         fk-constraint, (foreign-key-fields | table-key-fields))>


<!--
Name of the ejb-relationship-role being configured.  This must match
an ejb-relationship-role declared for this ejb-relation in the 
ejb-jar.xml file.
-->
<!ELEMENT ejb-relationship-role-name (#PCDATA)>


<!--
Contains the foreign key fields.
-->
<!ELEMENT foreign-key-fields (foreign-key-field*)>

<!--
The foreign-key-field element declared the configuration of a foreign
key. The field-name element must match the field-name of one of the 
primary key fields of the related element. This is similar to the 
REFERANCES clause of a SQL foreign key declaration. 
-->
<!ELEMENT foreign-key-field (field-name, 
         ((column-name, (jdbc-type, sql-type)?) | (property*))
         )>


<!--
Specifies that the ejb-relation should be mapped with a 
relation-table. This is the only mapping available for many-to-many
relationships.
-->
<!ELEMENT table-mapping (table-name?, datasource?, create-table?, 
         remove-table?, select-for-update?, pk-constraint?,
         (ejb-relationship-role, ejb-relationship-role)?)>


<!--
Contains the table key fields.
-->
<!ELEMENT table-key-fields (table-key-field+)>


<!--
The table-key-field element declared the configuration of a table
key. The field-name element must match the field-name of one of the 
primary key fields of this element.
-->
<!ELEMENT table-key-field (field-name, 
         ((column-name, (jdbc-type, sql-type)?) | (property*))
         )>


<!--There is a problem.  The table/foreign key mapping choice is 
correlated with the table-key-fields/foreign-key-fields choices in
ejb-relationship-role,-->


<!--
Contains the known dependene value classes.
-->
<!ELEMENT dependent-value-classes (dependent-value-class+)>


<!--
The dependent-value-class element contains the configuration of a
dependent value class.
-->
<!ELEMENT dependent-value-class (description, class, property+)>


<!--
Name of the java class to which the dependent value class configuration 
applies.
-->
<!ELEMENT class (#PCDATA)>


<!--
The type-mappings element contains the java to sql mappings.
-->
<!ELEMENT type-mappings (type-mapping+)>

<!--
The type-mapping element contains a named java to sql mapping.
This includes both type mapping and function mapping.


Should be:
<!ELEMENT type-mapping (name, (function-mapping, mapping)+)>
-->
<!ELEMENT type-mapping ANY>

<!--
Name of the type-mapping.
-->
<!ELEMENT name (#PCDATA)>

<!--
Specifies the mapping from a java type to a jdbc and a sql type.
-->
<!ELEMENT mapping (java-type, jdbc-type, sql-type)>

<!-- 
Specifies the java class type to be mapped.
-->
<!ELEMENT java-type (#PCDATA)>

<!--
Specifies the mapping from an EJB-QL function to a sql function.
-->
<!ELEMENT function-mapping (function-name, function-sql)>

<!--
The name of the function to be mapped.
-->
<!ELEMENT function-name (#PCDATA)>

<!--
The sql to which the function is mapped.  The sql can contain
parameters specified with a question mark followed by the base one
parameter number.  For example, function mapping for concat in Oracle
follows:

<function-mapping>
   <function-name>concat</function-name>
   <function-sql>(?1 || ?2)</function-sql>
</function-mapping>
-->
<!ELEMENT function-sql (#PCDATA)>

