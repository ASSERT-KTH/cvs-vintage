options {LOOKAHEAD=10; STATIC=true;}
PARSER_BEGIN(ValidWhenParser)
/*
 *  The Apache Software License, Version 1.1
 *
 *  Copyright (c) 1999 The Apache Software Foundation.  All rights
 *  reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *  notice, this list of conditions and the following disclaimer in
 *  the documentation and/or other materials provided with the
 *  distribution.
 *
 *  3. The end-user documentation included with the redistribution, if
 *  any, must include the following acknowlegement:
 *  "This product includes software developed by the
 *  Apache Software Foundation (http://www.apache.org/)."
 *  Alternately, this acknowlegement may appear in the software itself,
 *  if and wherever such third-party acknowlegements normally appear.
 *
 *  4. The names "The Jakarta Project", "Struts", and "Apache Software
 *  Foundation" must not be used to endorse or promote products derived
 *  from this software without prior written permission. For written
 *  permission, please contact apache@apache.org.
 *
 *  5. Products derived from this software may not be called "Apache"
 *  nor may "Apache" appear in their names without prior written
 *  permission of the Apache Group.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 *  ====================================================================
 *
 *  This software consists of voluntary contributions made by many
 *  individuals on behalf of the Apache Software Foundation.  For more
 *  information on the Apache Software Foundation, please see
 *  <http://www.apache.org/>.
 */

package org.apache.struts.validator.validwhen;

import java.io.InputStream;
import java.io.StringReader;
import org.apache.commons.validator.ValidatorUtil;

/**
 *  <p>
 *
 *  This class contains the parser that is used to evaluate
 *  expressions used in the <code>validwhen</code> validation rule.
 *  file.</p>
 *
 *
 *@author     James Turner
 *@since      Struts 1.1
 */

public class ValidWhenParser {

    static Object form;
     static int index;
    static String value;

    private static final int LESS_EQUAL=0;
    private static final int LESS_THAN=1;
    private static final int EQUAL=2;
    private static final int GREATER_THAN=3;
    private static final int GREATER_EQUAL=4;
    private static final int NOT_EQUAL=5;

    static java.util.Stack argStack = new java.util.Stack();

    private static ValidWhenParser parser = null;

    /**
     *  <p>
     *
     *  Evaluates the <code>expression</code> relative to the current
     *  <code>form</form>, <code>indexVal</code> and </code>valueVal</code>
     *
     *@param  exp      A string containing the validation test
     *@param  formVal  The bean with values for the form
     *@param  indexVal The index of the field being validated
     *@param  valueVal The value of the field being validated
     *@return          True if meets stated requirements, False otherwise
     */
    public synchronized static boolean evaluateExpression(String exp, Object formVal, int indexVal, String valueVal) 
	throws ParseException {
	

	StringReader stream = new StringReader(exp);
	if (parser == null) {
		parser = new ValidWhenParser(stream);
	} else {
		ReInit(stream);
	}
	form = formVal;
	index = indexVal;
        value = valueVal;

	try {
	    switch (Expression()) {
	    case 1:
		return ((Boolean) argStack.pop()).booleanValue();
	    default:
		throw new ParseException();
	    }
	} catch (ParseException x) {
	    x.printStackTrace();
	    throw x;
	}
    }

    private static boolean evaluateComparison (Object v1, Object compare, Object v2) {
        boolean intCompare = true;
	if ((v1 == null) || (v2 == null)) {
		if (String.class.isInstance(v1)) {
			if (((String) v1).length() == 0) {
				v1 = null;
			}
		}
		if (String.class.isInstance(v2)) {
			if (((String) v2).length() == 0) {
				v2 = null;
			}
		}
		switch (((Integer)compare).intValue()) {
		case LESS_EQUAL:
		case GREATER_THAN:
		case LESS_THAN:
		case GREATER_EQUAL:
			return false;
		case EQUAL:
		    return (v1 == v2);
		case NOT_EQUAL:
		    return (v1 != v2);
		}
	}
        if (!Integer.class.isInstance(v1) &&
	    !Integer.class.isInstance(v2)) {
	    intCompare = false;
	}
	if (intCompare) {
	    try {
		int v1i = 0, v2i = 0;
		if (Integer.class.isInstance(v1)) {
		    v1i = ((Integer)v1).intValue();
		} else {
		    v1i = Integer.parseInt((String) v1);
		}
		if (Integer.class.isInstance(v2)) {
		    v2i = ((Integer)v2).intValue();
		} else {
		    v2i = Integer.parseInt((String) v2);
		}
		switch (((Integer)compare).intValue()) {
		case LESS_EQUAL:
		    return (v1i <= v2i);

		case LESS_THAN:
		    return (v1i < v2i);

		case EQUAL:
		    return (v1i == v2i);

		case GREATER_THAN:
		    return (v1i > v2i);

		case GREATER_EQUAL:
		    return (v1i >= v2i);

		case NOT_EQUAL:
		    return (v1i != v2i);
		}
	    } catch (NumberFormatException ex) {};
	}
	String v1s = "", v2s = "";

	if (Integer.class.isInstance(v1)) {
	    v1s = ((Integer)v1).toString();
	} else {
	    v1s = (String) v1;
	}

	if (Integer.class.isInstance(v2)) {
	    v2s = ((Integer)v2).toString();
	} else {
	    v2s = (String) v2;
	}

	int res = v1s.compareTo(v2s);
	switch (((Integer)compare).intValue()) {
	case LESS_EQUAL:
	    return (res <= 0);

	case LESS_THAN:
	    return (res < 0);

	case EQUAL:
	    return (res == 0);

	case GREATER_THAN:
	    return (res > 0);

	case GREATER_EQUAL:
	    return (res >= 0);

	case NOT_EQUAL:
	    return (res != 0);
	}
	return true;
    }

}

PARSER_END(ValidWhenParser)

SKIP :
{
  " "
| "\t"
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* > |

 < STRING_LITERAL: (["'"] (~["'"])* ["'"]) > |
 < NULL: "null" >
}

TOKEN :
{
   < OR: "or" | "OR" > |
   < AND: "and" | "AND" > |
   < LBRACKET: "[" > |
   < RBRACKET: "]" >
}

TOKEN :
{
	< EOL: "\n" >
}

TOKEN :
{
	< THIS: "*this*" >
}


TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: (<LETTER>|".") (<LETTER>|<DIGIT>|".")* > 
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

void Integer() :
{}
{
	<INTEGER_LITERAL> {
		argStack.push(token.image);
	}
}

void Identifier() :
{}
{
	<IDENTIFIER> {
		argStack.push(token.image);
	}
}

int one_line() :
{}
{
    Expression() <EOL>
	{ return 1; }
}

void Field() : {}
{

 Identifier() <LBRACKET> <RBRACKET> Identifier() {
	String fieldNamePost = (String) argStack.pop();
	String fieldNamePre = (String) argStack.pop();

	argStack.push(ValidatorUtil.getValueAsString(form, fieldNamePre + "[" + index + "]" + fieldNamePost));
}
|
 Identifier() <LBRACKET> Integer() <RBRACKET> Identifier() {
	String fieldNamePost = (String) argStack.pop();
	String fieldIndex = (String) argStack.pop();
	String fieldNamePre = (String) argStack.pop();
	argStack.push(ValidatorUtil.getValueAsString(form, fieldNamePre + "[" + fieldIndex + "]" + fieldNamePost));
}
|
 Identifier() <LBRACKET> Integer() <RBRACKET> {
	String fieldIndex = (String) argStack.pop();
	String fieldName = (String) argStack.pop();
	argStack.push(ValidatorUtil.getValueAsString(form, fieldName + "[" + fieldIndex + "]"));
}
|  Identifier() <LBRACKET> <RBRACKET>  {
	String fieldName = (String) argStack.pop();
	
	argStack.push(ValidatorUtil.getValueAsString(form, fieldName + "[" + index + "]"));
}

|
	Identifier() {
	String fieldName = (String) (String) argStack.pop();
	argStack.push(ValidatorUtil.getValueAsString(form, fieldName));
	}
}

void Literal() : {}
{
	Integer() {
	   try {
		String value = (String) argStack.pop();
	    	int x = Integer.parseInt(value);
	    	argStack.push(new Integer(x));
	    } catch (NumberFormatException ee) {
		argStack.push(new Integer(0));
	    }
}
| <STRING_LITERAL> {
  argStack.push(token.image.substring(1, token.image.length()-1));
}
| <NULL> {
  argStack.push(null);
}
| <THIS> {
    argStack.push(value);
}
}

void Comparator() : {}
{
   ">" { argStack.push(new Integer(GREATER_THAN)); } |
">="  { argStack.push(new Integer(GREATER_EQUAL)); } |
"<"  { argStack.push(new Integer(LESS_THAN)); } |
"<="  { argStack.push(new Integer(LESS_EQUAL)); } |
"=="  { argStack.push(new Integer(EQUAL)); } |
"!=" { argStack.push(new Integer(NOT_EQUAL)); }
}

void Value() : {}
{
	Field() | Literal()
}

int Expression() : {}
{
   "(" JoinedExpression() ")" { return 1; } |
   "(" ComparisonExpression() ")" { return 1; }
}

void JoinedExpression() : {}
{
   Expression() <AND> Expression() {
   Boolean v1 = (Boolean) argStack.pop();
   Boolean v2 = (Boolean) argStack.pop();
   argStack.push(new Boolean(v1.booleanValue() && v2.booleanValue()));
} |
   Expression() <OR> Expression() {
   Boolean v1 = (Boolean) argStack.pop();
   Boolean v2 = (Boolean) argStack.pop();
   argStack.push(new Boolean(v1.booleanValue() || v2.booleanValue()));
} 
}

void ComparisonExpression(): {}
{
	Value() Comparator() Value() {
	    Object v2 = argStack.pop();
	    Object comp = argStack.pop();
            Object v1 = argStack.pop();
            argStack.push(new Boolean(evaluateComparison(v1, comp, v2)));
	}
}       
