/*
 * @(#)Tag.java	1.27 99/08/18
 * 
 * Copyright (c) 1999 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the confidential and proprietary information of Sun
 * Microsystems, Inc. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Sun.
 * 
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
 * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR ANY DAMAGES
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
 * THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 * CopyrightVersion 1.0
 */
 
package javax.servlet.jsp.tagext;

import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;
import javax.servlet.*;
import java.io.Writer;
import java.util.Hashtable;

/**
 * Actions in a Tag Library are defined through subclasses of Tag.
 */

public abstract class Tag {
    /**
     * Return value for doStartTag() and doAfterBody():
     * (re)evaluate the inner body of the tag.
     */
    public final static int EVAL_BODY = 0;

    /**
     * Return value for doStartTag() and doAfterBody():
     * skip the inner body of the tag.
     */
    public final static int SKIP_BODY = 1;

    /**
     * Return value for doEndTag():
     * continue evaluating the page
     */
    public final static int EVAL_PAGE = 10;

    /**
     * Return value for doEndTag():
     * skip the remaining evaluation of the page
     */
    public final static int SKIP_PAGE = 11;


    /**
     * Find the instance of a given class type that is closest to a given
     * instance.
     * This class is used for coordination among cooperating tags.
     *
     * @param the subclass of Tag or interface to be matched
     * @return the nearest ancestor that implements the interface
     * or is an instance of the class specified
     */

    public static final Tag findAncestorWithClass(Tag from, Class klass) {
	boolean isInterface = false;

	if (from == null ||
	    klass == null ||
	    (!Tag.class.isAssignableFrom(klass) &&
	     !(isInterface = klass.isInterface()))) {
	    return null;
	}

	for (;;) {
	    Tag tag = from.getParent();

	    if ((isInterface && klass.isInstance(tag)) ||
	        klass.equals(tag.getClass()))
		return tag;
	    else
		from = tag;
	}
    }

    /**
     * Default constructor, all subclasses are required to only define
     * a public constructor with the same signature, and to call the
     * superclass constructor.
     *
     * This constructor is called by the code generated by the JSP
     * translator.
     *
     * @param libraryPrefix The namespace prefix used for this library.
     * For example "jsp:".
     * @param tagName The name of the element or yag, for example "useBean"
     */

    public Tag(String libraryPrefix, String tagName) {
	this.libraryPrefix = libraryPrefix;
	this.tagName       = tagName;
    }


    /**
     * initialize() and release() are unlikely to be redefined by most
     * tag library authors.
     */

    /**
     * Initialize a Tag instance so it can be (re)used.
     *
     * A freshly created tag instance has to be prepared by invoking
     * this method before invoking doStartTag().  A tag instance that has
     * been used and released by invoking release(), must be reinitialized
     * by invoking this method.
     * <p>
     * Extreme care should be taken if this method is to be modified
     * or interposed as it maintains invariants that are global to the
     * whole page, specifically the parent Tag link list. 
     * initialize() is not frequently changed or interposed by the Tag
     * author.
     *
     * @param parent the parent extension tag for this tag or null
     * @param tagData  attribute data for this tag instance
     * @param pc  PageContext for this tag instance.
     */

    public void initialize(Tag parent, TagData tagData, PageContext pc) {
	this.parent      = parent;
	this.tagData     = tagData;
	this.pageContext = pc;
    	this.tagId       = tagData == null ? null : tagData.getId();
	this.previousOut = pc.getOut();
    }

    /**
     * Release a Tag instance so it can be (re)used.
     * <p>
     * Extreme care should be taken if this method is to be modified
     * or interposed as it maintains invariants that are global to the
     * whole page, specifically the parent Tag link list. 
     * initialize() is not frequently changed or interposed by the Tag
     * author.
     */

    public void release() {
	values      = null;
	parent      = null;
	tagId       = null;
	pageContext = null;
	tagData     = null;
	previousOut = null;
	bodyOut     = null;
	
    }

    /**
     * doStartTag(), doEndTag() are most basic.
     * setBodyOut(), doBeforeBody(), and doAfterBody() deal with body
     * 
     * In many cases not all of them are redefined.
     */

    // Actions for basic start/end processing.

    /**
     * Process the start tag for this instance.
     *
     * The doStartTag() method assumes that initialize() has been
     * invoked before.
     *
     * When this method is invoked, the body has not yet been invoked.
     *
     * @returns EVAL_BODY if the tag wants to process body, SKIP_BODY if it
     * does ont want to process it.
     */

    public int doStartTag() throws JspException {
	return SKIP_BODY;
    }
	      
    /**
     * Process the end tag. This method will be called on all Tag objects.
     * Returns an indication of whether the rest of the page should be
     * evaluated or skipped.
     *
     * All instance state associated with this instance must be reset.
     * The release() method should be called after this invocation.
     *
     * @return SKIP_PAGE if the rest of the page should be skipped, and
     * EVAL_PAGE if the evaluation of the page should continue.
     */

    public int doEndTag() throws JspException {
	return EVAL_PAGE;
    }


    // Actions related to body evaluation

    /**
     * Set the BodyJspWriter.
     * It will be invoked at most once per action invocation.
     * Will not be invoked if there is no body evaluation.
     *
     * Frequently it is not redefined by Tag author.
     *
     * @param b the BodyJspWriter
     */
    public void setBodyOut(BodyJspWriter b) {
	this.bodyOut = b;
    }


    /**
     * Actions before some body is to be evaluated.
     *
     * Not invoked in empty tags or in tags returning false in doStartTag()
     * This method is invoked before every body evaluation.
     * The companion method doAfterBody() is invoked after every body
     * evaluation.
     * The triple "doBeforeBody() -- BODY -- doAfterBody()" is invoked
     * initially if doStartTag() returned EVAL_BODY, and it is repeated as long
     * as the doAfterBody() evaluation returns EVAL_BODY.
     *
     * The method re-invocations may be lead to different actions because
     * there might have been some changes to shared state, or because
     * of external computation.
     *
     * @returns whether additional evaluations of the body are desired
     * @seealso #doAfterBody
     */

    public void doBeforeBody() throws JspError {
    }

    /**
     * Actions after some body has been evaluated.
     *
     * Not invoked in empty tags or in tags returning false in doStartTag()
     * This method is invoked after every body evaluation.
     * The companion method doBeforeBody() is invoked before every body
     * evaluation.
     * The triple "doBeforeBody() -- BODY -- doAfterBody()" is invoked
     * initially if doStartTag() returned EVAL_BODY, and it is repeated as long
     * as the doAfterBody() evaluation returns EVAL_BODY.
     *
     * The method re-invocations may be lead to different actions because
     * there might have been some changes to shared state, or because
     * of external computation.
     *
     * @returns whether additional evaluations of the body are desired
     * @seealso #doBeforeBody
     */

    public int doAfterBody() throws JspError {
 	return SKIP_BODY;
    }

    /**
     * Methods to access state
     */

    /**
     * @return the parent extension tag instance or null
     */

    public Tag getParent() {
	return parent;
    }

    /**
     * @return the value of the id or null
     */

    public String getTagId() {
	return tagId;
    }

    /**
     * @return the library prefix being used with this tag
     */

    public String getLibraryPrefix() {
	return libraryPrefix;
    }

    /**
     * @return the tag name 
     */

    public String getTagName() {
	return tagName;
    }

    /**
     * return the immmutable TagData for this tag
     *
     * @return the TagData for this Tag
     */

    public TagData getTagData() {
	return tagData;
    }

    /**
     * return the PageContext for this tag
     *
     * @return the PageContext for this Tag
     */

    public PageContext getPageContext() {
	return pageContext;
    }

    /**
     * set a user defined value on the Tag
     * 
     * @param key the name of the user defined value
     * @param value the value to be associated
     * 
     */
 
    public void setValue(String key, Object value) { 
	if (values == null) values = new Hashtable();

	values.put(key, value);
    }

    /**
     * @return the value associated with the key
     */

    public Object getValue(String key) {
	return values == null ? null : values.get(key);
    }

    /**
     * @return the value of the "out" JspWriter prior to pushing
     * a BodyJspWriter
     */

    protected final JspWriter getPreviousOut() {
	return previousOut;
    }

    /**
     * @return the value of the current "out" JspWriter
     */

    protected final BodyJspWriter getBodyOut() {
	return bodyOut;
    }


    // private fields

    private String        libraryPrefix;
    private String        tagName;
    private Tag           parent;
    private String        tagId;
    private JspWriter     previousOut;
    private Hashtable     values;
    
    // protected fields
    protected BodyJspWriter bodyOut;
    protected PageContext pageContext;
    protected TagData     tagData;
}
