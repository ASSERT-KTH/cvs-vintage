<?xml version="1.0"?>
<document url="./building_model.xml">

  <properties>
    <author>Craig R. McClanahan</author>
    <author>Mike Schachter</author>
    <title>The Struts Framework Project</title>
  </properties>
  
  <body>  
  <chapter name="Building Model Components" href="building_model">
  
  		<section name="2.1 Overview" href="building_model_overview">
  			
  			<p>The application requirements document that you are using will likely
				have focused on the user interface to be created.  However, you should ensure
				that the processing required for each submitted request is also clearly
				defined.  In general, the developer of the <i>Model</i> components will be
				focusing on the creation of JavaBeans classes that support all of the
				functional requirements.  The precise nature of the beans required by a
				particular application will vary widely depending on those requirements,
				but they can generally be classified into several categories discussed
				below.  However, a brief review of the concept of "scope" as it relates
				to beans is useful first.
			</p>
		</section>
		
		<section name="2.2 JavaBeans and Scope" href="building_model_javabeans">
		
			<p>
				Within a web-based application, JavaBeans can be stored in (and accessed
				from) a number of different collections of "attributes".  Each collection
				has different rules for the lifetime of that collection, and the visibility
				of the beans stored there.  Together, the rules defining lifetime and
				visibility are called the <i>scope</i> of those beans.  The JavaServer
				Pages (JSP) Specification defines scope choices using the following terms
				(with the equivalent servlet API concept defined in parentheses):
			</p>
				
			<ul>
				<li><b>page</b> - Beans that are visible within a single JSP page,
				    for the lifetime of the current request.  (Local variables of
				    the <code>service()</code> method)</li>
				<li><b>request</b> - Beans that are visible within a single JSP page,
				    as well as to any page or servlet that is included in this page,
				    or forwarded to by this page.  (Request attributes)</li>
				<li><b>session</b> - Beans that are visible to all JSP pages and
				    servlets that participate in a particular user session, across one
				    or more requests.  (Session attributes)</li>
				<li><b>application</b> - Beans that are visible to all JSP pages and
				    servlets that are part of a web application.  (Servlet context
				    attributes)</li>
			</ul>
				
			<p>
				It is important to remember that JSP pages and servlets in the same
				web application share the same sets of bean collections.  For example,
				a bean stored as a request attribute in a servlet like this:
			</p>
				
			<pre>
				 MyCart mycart = new MyCart(...);
				 request.setAttribute("cart", mycart);
			</pre>
			
			<p>
				is immediately visible to a JSP page which this servlet forwards to,
				using a standard action tag like this:
			</p>
				
			<pre>
				&lt;jsp:useBean id="cart" scope="request"
				class="com.mycompany.MyApp.MyCart"/&gt;
			</pre>
		</section>
		
		<section name="2.3 ActionForm Beans" href="building_model_actionform">
			
			<p>
				The Struts framework generally assumes that you have created an
				<code>ActionForm</code> bean (that is, a Java class implementing the
				<code>ActionForm</code> interface) for each input form required in your
				application.  If you define such beans in your <code>ActionMapping</code>
				configuration file (see "Building the Controller Components"), the Struts
				controller servlet will automatically perform the following services for
				you, before invoking the appropriate <code>Action</code> method:
			</p>
				
			<ul>
				<li>Check in the user's session for an instance of a bean of the
				    appropriate class, under the appropriate key.</li>
				<li>If there is no such session scope bean available, a new one is
				    automatically created and added to the user's session.</li>
				<li>For every request parameter whose name corresponds to the name
				    of a property in the bean, the corresponding setter method will
				    be called.  This operates in a manner similar to the standard
				    JSP action <code>&lt;jsp:setProperty&gt;</code> when you use the
				    asterisk wildcard to select all properties.</li>
				<li>The updated <code>ActionForm</code> bean will be passed to the
				    Action Class <code>perform()</code> method when it is called,
				    making these values immediately available.</li>
			</ul>
				
			<p>
				When you code your <code>ActionForm</code> beans, keep the following
				principles in mind:
			</p>
			
			<ul>
				<li>The <code>ActionForm</code> interface itself requires no specific
				    methods to be implemented.  It is used to identify the role these
				    particular beans play in the overall architecture.  Typically, an
				    <code>ActionForm</code> bean will have only property getter and
				    property setter methods, with no business logic.</li>
				<li>Generally, there will be very little input validation logic in an
				    <code>ActionForm</code> bean.  The primary reason such beans exist
				    is to save the most recent values entered by the user for the
				    associated form -- even if errors are detected -- so that the same
				    page can be reproduced, along with a set of error messages, so the
				    user need only correct the fields that are wrong.  Validation
				    of user input should be performed within <code>Action</code> classes
				    (if it is simple), or appropriate business logic beans.</li>
				<li>Define a property (with associated <code>getXxx()</code> and
				    <code>setXxx()</code> methods) for each field that is present
				    in the form.  The field name and property name must match according
				    to the usual JavaBeans conventions.  For example, an input field named
				    <code>username</code> will cause the <code>setUsername()</code> method
				    to be called.</li>
			</ul>
				
			<p>
				You should note that a "form", in the sense discussed here, does not
				necessarily correspond to a single JSP page in the user interface.  It is
				common in many applications to have a "form" (from the user's perspective)
				that extends over multiple pages.  Think, for example, of the wizard style
				user interface that is commonly used when installing new applications.  Struts
				encourages you to define a single <code>ActionForm</code> bean that contains
				properties for all of the fields, no matter which page the field is actually
				displayed on.  Likewise, the various pages of the same form should all be
				submitted to the same Action Class.  If you follow these suggestions, the
				page designers can rearrange the fields among the various pages, with no
				changes required to the processing logic in most cases.
			</p>
		</section>
		
		<section name="2.4 System State Beans" href="building_model_system_state">
			
			<p>
				The actual state of a system is normally represented as a set of one or
				more JavaBeans classes, whose properties define the current state.  A
				shopping cart system, for example, will include a bean that represents the
				cart being maintained for each individual shopper, and will (among other
				things) include the set of items that the shopper has currently selected
				for purchase.  Separately, the system will also include different beans
				for the user's profile information (including their credit card and ship-to
				addresses), as well as the catalog of available items and their current
				inventory levels.
			</p>
				
			<p>
				For small scale systems, or for state information that need not be kept
				for a long period of time, a set of system state beans may contain all the
				knowledge that the system ever has of these particular details.  Or, as is
				often the case, the system state beans will represent information that is
				stored permanently in some external database (such as a CustomerBean object
				that corresponds to a particular row in the CUSTOMERS table), and are
				created or removed from the server's memory as needed.  Entity Enterprise
				JavaBeans are also used for this purpose in large scale applications.
			</p>
		</section>
		
		<section name="2.5 Business Logic Beans" href="building_model_business_logic">
			
			<p>
				You should encapsulate the functional logic of your application as
				method calls on JavaBeans designed for this purpose.  These methods may
				be part of the same classes used for the system state beans, or they may
				be in separate classes dedicated to performing the logic.  In the latter
				case, you will usually need to pass the system state beans to be manipulated
				to these methods as arguments.
			</p>
				
			<p>
				For maximum code re-use, business logic beans should be designed and
				implemented so that they do <b>not</b> know they are being executed in a
				web application environment.  If you find yourself having to import a
				<code>javax.servlet.*</code> class in your bean, you
				are tying this business logic to the web application environment.  Consider
				rearranging things so that your <code>Action</code> classes (part of the
				Controller role, as described below) translate all required information
				from the HTTP request being processed into property setter calls on your
				business logic beans, after which a call to an <code>execute()</code> method
				can be made.  Such a business logic class can be reused in environments
				other than the web application for which they were initially constructed.
			</p>
				
			<p>
				Depending on the complexity and scope of your application, business logic
				beans might be ordinary JavaBeans that interact with system state beans
				passed as arguments, or ordinary JavaBeans that access a database using
				JDBC calls.  For larger applications, these beans will often be stateful
				or stateless Enterprise JavaBeans (EJBs) instead.
			</p>
		</section>
		
		<section name="2.6 An Aside:  Accessing Relational Databases" href="building_model_databases">
			
			<p>
				Many web applications will utilize a relational database (accessed through
				a JDBC driver) to store the persistent data associated with the application.
				Others will use Entity Enterprise JavaBeans for this purpose, which delegates
				the decisions for how to maintain persistent state to the EJBs themselves.
				If you are using Enterprise JavaBeans for this purpose, follow the client
				design patterns described in the Enterprise JavaBeans specification.
			</p>
				
			<p>
				For web applications based on direct database access, a common design
				problem is how to make an appropriate JDBC Connection object available when
				access to the underlying database is required.  There are several possible
				approaches to this problem -- the following principles describe a
				recommended approach to this issue:
			</p>
			
			<ul>
				<li>Create or acquire a ConnectionPool class, which lets a set of database
				    connections be shared among multiple users.  Struts does not (currently)
				    include such a class, but many are available.</li>
				<li>When the application is initialized, define a servlet with a "load on
				    startup" value in the application deployment descriptor.  We will call
				    this the <i>startup</i> servlet.  In most cases, there will be no need
				    for any requests to be processed by this servlet, so there will not be
				    a <code>&lt;servlet-mapping&gt;</code> entry pointing at it.</li>
				<li>In the <code>init()</code> method of the startup servlet, configure and
				    instantiate an instance of your ConnectionPool class, and store it as
				    a servlet context attribute (which is the same as an application scope
				    bean from the JSP perspective).  It is usually convenient to configure
				    the connection pool based on initialization parameters passed to the
				    startup servlet.</li>
				<li>In the <code>destroy()</code> method of the startup servlet, include
				    logic to gracefully release the connections that have been opened by
				    the connection pool.  This method will get called when the servlet
				    container shuts down this application.</li>
				<li>When an <code>Action</code> class needs to call a method of a business
				    logic bean that requires a database connection (such as "insert a new
				    customer"), it will the following steps:
				    
				    <ul>
					    <li>
					    	Acquire the connection pool object from the servlet context
					        attributes for this web application.
					    </li>
					    <li>
					    	Call the <code>open()</code> method of the connection pool object
					    	to give you a connection for use within this <code>Action</code>
					    	class call.
					    </li>
					    <li>
					    	Call the appropriate method of your business logic bean, passing the
					    	database connection object to be used as an argument.
					    </li>
					    <li>
					    	Call the <code>close()</code> method of the allocated connection,
					    	which will cause this connection to be returned to the pool for
					    	later re-use on some other request.
					    </li>
				    </ul>
				</li>
				    
				<li>
					A common programming error is to forget to return the connection to the
					pool, which can ultimately lead to running out of connections.  Be sure
					that your <code>Action</code> class logic always returns the connection,
					even if the business logic bean method throws an exception.
				</li>
			</ul>
				
			<p>
				Following the design pattern recommended above means that you can code
				your business logic classes without having to worry about how they acquire a
				JDBC Connection to use -- simply include a Connection argument in any method
				call that needs to access the database.  When your business logic class is
				utilized within a web application, it will be the responsibility of the
				<code>Action</code> class to allocate and release an appropriate connection.
				When you use the same business logic class, for example, in a batch job, it
				will be the responsibility of that application to provide an appropriate
				connection (which will not need to be acquired from a pool, because most
				batch jobs run in a single-threaded environment).
			</p>
		</section>
	</chapter>
	</body>
</document>