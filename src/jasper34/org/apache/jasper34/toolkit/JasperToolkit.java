/* Generated by Together */

package org.apache.jasper34.toolkit;

import java.util.*;
import javax.servlet.jsp.JspFactory;
import org.apache.Constants;

/**
    Base class for Jasper adapter toolkits.  Acts as the 
    default Factory and configuration 
    class for access to default behavior, properties and 
    services used by Jasper adapter implementations.
    <p>
    The design philosophy for using a base class instead of an
    interface is to allow the addition of future common services 
    to toolkit subclasses without having to redefine the interface. 
    <p>
    JasperToolkit provides factory methods for generating such services as:
    the base JspFactory implementation used by the JSP pages, the JspMangler
    implementation, cache storage containers, the JspCompiler, etc.  By
    using the toolkit's factory methods to access these services, each
    service is easy to replace/upgrade in the future as needed.
    <p>
    In addition, JasperToolkit provides access to configuration properties using the
    following order of precedence:
    <ol>
    <li>System Properties set via the -D java command line option.</li>
    <li>Properties read from a user-specified (via -D option) resource
        file.</li>
    <li>Properties read from the resource file:
        "org/apache/jasper34/resources/Toolkit.properties".</li>
    </ol>
    <p>
    Some of JasperToolkit's default methods re-use the objects they create 
    for repeated use.  This is discussed in the documentation for the
    particular factory method where relevant.  This is especially notable
    for the createToolkit() method which will only create one instance of a
    toolkit per <i>name</i> requested.  In most cases, though, 
    such optimization or life-cycle issues are handled by the 'getXXXX' methods
    rather than the create factory methods.  It is expected that optimizations and 
    life-cycle management will often be overridden or handled by subclasses
    and calling code.
    <p>
    Finally, JasperToolkit also provides a factory method for creating
    subclass implementations of JasperToolkit.  This latter mechanism is used so
    that particular implementations of Jasper can instantiate appropriate
    factories for the services particular to the implementation.  For
    example, JspServlet requires certain life-cycle services, such as
    a class loader, that is not necessary for other Jasper implementors
    such as JspC.  By using createToolkit(), instead of direct instantiation,
    the implementation allows easy replacement/upgrade of essentially all
    behavior and services as needed.
    <p>
    To make use of the 
    {@link org.apache.jasper34.toolkit.JasperToolkit#createToolkit 
    createToolkit()}
    method, a subclass of JasperToolkit should obey the following rules:
    <ol>
    <li>The subclass must provide a public constructor that receives
        a String <i>name</i> parameter (see below) and
        a single arbitrary Object parameter for initialization, but 
        should be able to accept a null value for the initialization 
        parameter.  JasperToolkit provides this constructor already.</li>
    <li>Although it should not rely too heavily on statics, each toolkit
        should be written as if it might be a singleton, since JasperToolkit
        will re-use the same instance for each toolkit name requested.  The
        basic consequence is that some JasperToolkit subclass methods may need
        to be made thread-safe.  Note that by using different toolkit 
        <i>names</i>, the same class may be instantiated more than once, so
        these are not true singletons.</li>
    <li>The subclass should be registered with a <i>name</i> via configuration
        properties or Jasper configuration resource file.
    </ol>
    To register a subclass with a particular name, a configuration property
    of the following form should be entered, either as a System property
    via -D at the command line or as a property in either the user-specified
    or the default toolkit resource file:
    <pre>
    * org.apache.jasper34.toolkit.toolkit.<i>name</i> = <i>name of class</i>
    </pre>
    For example, the entry:
    <pre>
    * org.apache.jasper34.toolkit.toolkit.JspServletToolkit =  \
    *                       org.apache.jasper34.servlet.JspServletToolkit
    </pre>
    would allow creation of a JspServletToolkit instance with the call:
    <pre>
    * JasperToolkit tk = JasperToolkit.createToolkit(
    *                                    "JspServletToolkit",config);
    * JspServletToolkit jstk = (JspServletToolkit)tk;
    * JspMangler mangler = jstk.createJspMangler(jspUri,scratchDir);
    * //etc...
    </pre>
    This allows the toolkit implementation for a Jasper adapter to
    be easily replaced by simply specifying the configuration property.
    <p>
    In a similar manner, the following properties can be set to indicate
    an alternate class to use for the following services:
    <ul>
        <li>org.apache.jasper34.toolkit.toolkit.XXXX</li>
        <li>org.apache.jasper34.toolkit.jspfactory.XXXX</li>
        <li>org.apache.jasper34.toolkit.pagehandler.XXXX</li>
        <li>org.apache.jasper34.toolkit.requesthandler.XXXX</li>
        <li>org.apache.jasper34.toolkit.jspcompiler.XXXX</li>
        <li>org.apache.jasper34.toolkit.javacompiler.XXXX</li>
        <li>org.apache.jasper34.toolkit.jspmangler.XXXX</li>
        <li>org.apache.jasper34.toolkit.modificationchecker.XXXX</li>
        <li>org.apache.jasper34.toolkit.cache.XXXX
    </ul>
    where XXXX = the name of the Jasper implementation passed to the
    create method.  If no name (null) is passed to a create method, then
    the name 'default' is assumed.  In each case, the class specified by the 
    property <b>must</b> implement the interface returned by the factory and
    fullfill any requirements described by the factory methods documentation
    regarding the particular service, notably for initialization.  
    See documentation below on the relevant service factory and property 
    name constants for details.
    <p>
    Where it is impossible to make an implementation of a particular service
    fit the requirements of a particular factory, then a subclass of this
    JasperToolkit class itself (via createToolkit() as above) can be used to
    provide an amended initialization contract for the desired service. 
    <p>
    While the factory (create) methods of this JasperToolkit base class 
    always take an implementation <i>name</i> parameter, calling code will
    generally find it more useful to invoke the <i>getXXX()</i> methods which will 
    insert the <i>name</i> used for the current toolkit's creation and manage
    object reuse where appropriate.  For example:
    <pre>
    * JasperToolkit tk = JasperToolkit.createToolkit("JspServlet");
    * // ...
    * ModificationChecker mc = tk.getModificationChecker(srcFile,tgtFile);
    *
    </pre>
    <p>
    @author Mel Martinez
    @see org.apache.jasper34.toolkit.JspPageHandler
    @see org.apache.jasper34.toolkit.JspRequestHandler
*/
public class JasperToolkit{

    //***** static fields and methods *********

    /**
        name of configuration property to set to specify a 
        different default JasperToolkit implementation to return
        from the createToolkit() method with a null toolkit
        name.  Example:
        <pre>
        * org.apache.jasper.toolkit.toolkit.default = \
        *                          com.foo.MyJasperToolkit
        </pre>
        The default value is this class.
    */
    public static final String DEFAULT_JASPER_TOOLKIT_PROPERTY=
                "org.apache.jasper.toolkit.toolkit.default";
                
    /** storage for previously created Toolkits */
    private static Hashtable toolkits = new Hashtable();
    
    /**
        name of property to set to override which resource file
        to be read in by Jasper for default configuration data.
        The path should be expressed as a "/" (forward slash)-delimited
        path to the resource file reachable from an entry within the
        classpath.  Example:
        <pre>
        * org.apache.jasper.resources.toolkit_properties = \
        *                      com/foo/resources/MyJSPConfig.properties
        </pre>
        Prior to this, DefaultToolkit will <b>always</b> read in the default
        org/apache/jasper34/resources/Toolkit.properties resource.
    */
	public static String JASPER_TOOLKIT_RESOURCE_PROPERTY =
        "org.apache.jasper.resources.toolkit_properties";

    /**
        deployer-specified resource file to read in after reading
        in the default org.apache.jasper.resources.Toolkit.properties
        resource.
    */
    private static String JASPER_TOOLKIT_RESOURCE;

    static{
        String s = System.getProperty(JASPER_TOOLKIT_RESOURCE_PROPERTY);
        if(s!=null && !s.equals("")){
        	JASPER_TOOLKIT_RESOURCE = s;
        }

    }

    /**
        stores loaded configuration properties from the resource
        files.
    */
    private static Properties toolkitResource;

	/**
        retrieves the named configuration property.  Looks first inside
        the System.getProperty() command for the property. If not found,
        look inside the user-specified JASPER_TOOLKIT_RESOURCE property
        file.  Finally, if still not found, look inside the resource file:
        "org/apache/jasper34/resources/Toolkit.properties".

        @param <b>propertyName</b> name of property to look for.
        @return found property value or null if not found.
    */
    public static String getProperty(String propertyName){
        String s =  System.getProperty(propertyName);
        if(s==null){
            if(toolkitResource == null){
            	toolkitResource = new Properties();
                ClassLoader cl = DefaultToolkit.class.getClassLoader();
                InputStream is =
                    cl.getResourseAsStream(
                    	"org/apache/jasper34/resources/Toolkit.properties");
                if(is!=null){
                    try{
                        toolkitResource.load(is);
                    }catch(IOException ioe){
                        System.err.println(
                            "JasperToolkit: "+
                            "error loading resource file: "+ioe);
                    }
                }
                is = cl.getResourseAsStream(JASPER_TOOLKIT_RESOURCE);
                if(is!=null){
                    try{
                        toolkitResource.load(is);
                    }catch(IOException ioe){
                        System.err.println(
                            "JasperToolkit: "+
                            "error loading specified resource file: "+ioe);
                    }
                }
            }
            s = toolkitResource.getProperty(propertyName);
        }
        return s;
    }

    /**
        for the given <i>name</i> and <i>service</i>, calculates
        the corresponding toolkit property name of form:
        <pre>
        * org.apache.jasper34.toolkit.<i>service</i>.<i>name</i>
        </pre>
        and then returns the corresponding property value
        retrieved via the {@link #getProperty getProperty()} method.
    */
    private static String getToolkitProperty(String name,String service){
        StringBuffer propertyName = new StringBuffer(64);
        propetyName.append("org.apache.jasper34.toolkit.");
        propertyName.append(service).append(".");
        propertyName.append(name==null?"default":name);
        return getProperty(propertyName);     
    }
    
    /**
        creates an instance of a JasperToolkit subclass as indicated
        by <i>name</i>.  If <i>name</i> is null, returns an instance
        of the subclass indicated by the JASPER_DEFAULT_TOOLKIT property
        or simply a JasperToolkit if the latter has not been set.
        <p>
        This method uses a 'psuedo-Singleton' pattern on each toolkit <i>name</i>
        requested - it will re-issue the same instance on subsequent
        requests for the given name instead of generating a new instance.
        Note - the same <i>class</i> can be used with different names, in which
        case multiple instances of the particular <i>class</i> will be
        created.
        <p>
        Except in the default, or null, case, the class of the toolkit 
        that is instantiated and returned is determined by the configuration
        property:
        <pre>
        * org.apache.jasper.toolkit.toolkit.<i>name</i>
        </pre>
        where <i>name</i> is the same as the name passed to this method. The
        class indicated by the property must be a subclass of JasperToolkit,
        and obey the following rules:
        <ol>
        <li>The subclass must provide a public constructor that recieves
            a single arbitrary Object parameter for initialization, but 
            should be able to accept a null value for the initialization 
            parameter.  JasperToolkit provides this constructor already.</li>
        <li>Although it should not rely too heavily on statics, each toolkit
            should be written as if it might be a singleton, since JasperToolkit
            will re-use the same instance for each toolkit name requested.  The
            basic consequence is that some JasperToolkit subclass methods may need
            to be made thread-safe.  Note that by using different toolkit 
            <i>names</i>, the same class may be instantiated more than once, so
            these are not true singletons.</li>
        <li>The subclass should be registered with a name via configuration
            properties or Jasper configuration resource file.</li>
        </ol>
        To register a subclass with a particular name, a configuration property
        of the following form should be entered, either as a System property
        via -D at the command line or as a property in either the user-specified
        or the default toolkit resource file:
        <pre>
        * org.apache.jasper34.toolkit.toolkit.<i>name</i> = <i>name of class</i>
        </pre>
        For example, the entry:
        <pre>
        * org.apache.jasper34.toolkit.toolkit.JspServletToolkit =  \
        *                       org.apache.jasper34.servlet.JspServletToolkit
        </pre>
        would allow creation of a JspServletToolkit instance with the call:
        <pre>
        * JasperToolkit tk = JasperToolkit.createToolkit(
        *                                    "JspServletToolkit",config);
        * JspServletToolkit jstk = (JspServletToolkit)tk;
        * //etc...
        </pre>
        This allows the toolkit implementation for a Jasper adapter to
        be easily replaced by simply specifying the configuration property.
        <p>
        @param <b>name</b> name of Toolkit implementation to instantiate.
        @param <b>initParam</b> Object to pass to init() method of Toolkit.
        @return an instance of a JasperToolkit subclass.
        @throws a RuntimeException if unable to find and instantiate the
                desired toolkit class.
    */
    public static JasperToolkit createToolkit(String name,Object initParam){
        name = name==null?"default":name;
        JasperToolkit tk = null;
        if(toolkits.containsKey(name)){ //did we already create it?
            tk = (JasperToolkit)toolkits.get(name);
        }else{
            String className = getToolkitProperty(name,"toolkit");
            if(className==null){
                className = "org.apache.jasper34.toolkit.JasperToolkit";
            }
            try{
                Class c = Class.forName(className);
                Object[] params = {name,initParam};
                tk = (JasperToolkit)c.newInstance(params);
                toolkits.put(name,tk);
            }catch(Exception e){
                String msg = "Error trying to instantiate Jasper Toolkit! "+e);
                throw new RuntimeException(msg,e);    
            }
        }
        return tk;
    }
    
    /**
        returns an instance of the default toolkit, initialized
        with the indicated <i>params</i>.
        @param <b>params</b> arbitrary initialization parameters.
        @return an instance of the default toolkit, initialized
                with the indicated <i>params</i>.
    */
    public static JasperToolkit createToolkit(Object params){
        return createToolkit(null,params);
    }
    
    //****** instance fields and methods ***********
    
    /** store previously created JspFactorys */
    private Hashtable factories = new Hashtable();
    /** store previously created JspPageHandlers */
    private Hashtable pageHandlers = new Hashtable();
    /** store previously created JspRequestHandlers */
    private Hashtable requestHandlers = new Hashtable();
    /** store previously created JspCompilers */
    private Hashtable compilers = new Hashtable();
    /** store previously created JspManglers */
    private Hashtable manglers = new Hashtable();
    /** store previously created ModificationCheckers */
    private Hashtable checkers = new Hashtable();

    /** name of this toolkit implementation */
    private String name = "default";
    
    /**
        initialization parameter, if any, assigned through
        the JasperToolkit constructor.
    */
    protected Object params = null;
    
    /**
        constructs a JasperToolkit with the
        name "default".
    */
    public JasperToolkit(){
    }
    
    /**
        constructs a JasperToolkit with the indicated
        <i>name</i> and initialization params.
    */
    public JasperToolkit(String name,Object params){
        setName(name);
        this.params = params;
    }
    
    /**
        sets the <i>name</i> of this toolkit instance.
    */
    public void setName(String name){
        this.name = name;
    }
    
    /**
        gets the <i>name</i> of this toolkit instance.
    */
    public String getName(){
        return name;
    }
    
    
	/**
        creates and returns an instance of a JspFactory
        implementation associated with the toolkit configuration
        property 
        <pre>
        * org.apache.jasper34.toolkit.jspfactory.<i>name</i>
        </pre>
        or if not set (or if <i>name</i> == null), then as 
        specified by the configuration property 
        <code> org.apache.jasper34.toolkit.jspfactory.default</code>.
        If not set, or set to an invalid value, this
        method will return an instance of the class
        <code>org.apache.jasper.runtime.JspFactoryImpl</code>
        by default.
        The JspFactory implementation must support a public,
        no-argument constructor.
        @param <b>name</b> implementation name
        @return an instance of a JspFactory implementation.
	*/
	protected JspFactory createJspFactory(String name){
        name = name==null?"default":name;
 		javax.servlet.jsp.JspFactory factory = null;
		String className = getToolkitProperty(name,"jspfactory");
        if(className==null){
            className = "org.apache.jasper.runtime.JspFactoryImpl";
        }
        try{
            Object obj = Class.forName(className).newInstance();
            factory = (javax.servlet.jsp.JspFactory)obj;
        }catch(Exception e){
            factory = new org.apache.jasper.runtime.JspFactoryImpl();
        }
		return factory;
	}


    /**
        returns the default JspFactory instance with the
        same implementation name as this toolkit.
        This method maintains one instance of a JspFactory
        per <i>name</i> and reuses it.
        @return an instance of a JspFactory implementation.
    */
    protected JspFactory getJspFactory(String name){
        name = name==null?"default":name;
 		javax.servlet.jsp.JspFactory factory = 
 		    (javax.servlet.jsp.JspFactory)factories.get(name);
		if(factories==null){
		    factory = createJspFactory(name);
		    factories.put(name,factory);
		}
		return factory;
    }

    /**
        returns the default JspFactory instance with the
        same implementation name as this toolkit.
        This method is equivalent to calling:
        <code>getJspFactory(getName())</code>.
        @return an instance of a JspFactory implementation.
    */
    public JspFactory getJspFactory(){
        return createJspFactory(getName());
    }
       
    /**
        factory for creating an instance of the default JspMangler
        implementation associated with the toolkit configuration
        property 
        <pre>
        * org.apache.jasper34.toolkit.jspmangler.<i>name</i>
        </pre>
        or if not set (or if <i>name</i> == null), then this will
        create an instance of a class as 
        specified by the configuration property 
        <code>org.apache.jasper34.toolkit.jspmangler.default</code>.
        If not set, or set to an invalid value, this
        method will return an instance of the class
        <code>org.apache.jasper34.util.JspManglerImpl</code>
        by default.
        The JspMangler implementation must support a public,
        no-argument constructor.
        @param <b>name</b> implementation name
        @return an instance of a JspMangler implementation.
	*/
	protected JspMangler createJspMangler(String name){
        name = name==null?"default":name;
		String className = getToolkitProperty(name,"jspmangler");
        if(className==null){
            className = "org.apache.jasper34.util.JspManglerImpl";
        }
        JspMangler m = null;
        try{
            Object obj = Class.forName(className).newInstance();
            m = (JspMangler)obj;
        }catch(Exception e){
            m = new JspManglerImpl();
        }
        return m;
    }
    
    /**
        accessor for retrieving an instance of the <i>named</i> JspMangler
        implementation class associated with the indicated <i>jspUri</i> and
        <i>outputDir</i>.  If a JspMangler for the indicated URI and
        output directory already exists, this method will return the
        previous instance.
        @param <b>name</b> implementation name
        @param <b>jspUri</b> String URI path to the JSP file
        @param <b>outputDir</b> String path to output (work) directory
        @return a JspMangler instance
    */
    protected JspMangler getJspMangler(String name, String jspUri, String outputDir){
       name = name==null?"default":name;
       String key = name+jspUri+outputDir;
       JspMangler m = (JspMangler)manglers.get(key);
       if(m==null){
            m = createJspMangler(name);
            m.setJspUri(jspUri);
            m.setOutputDir(outputDir);
            manglers.put(key,m);
       }
       return m;
    }
    

    /**
        accessor for retrieving an instance of the default JspMangler
        implementation class for this toolkit implementation and
        associated with the indicated <i>jspUri</i> and
        <i>outputDir</i>.  If a JspMangler for the indicated URI and
        output directory already exists, this method will return the
        previous instance.
        @param <b>jspUri</b> String URI path to the JSP file
        @param <b>outputDir</b> String path to output (work) directory
        @return a JspMangler instance
    */
    public JspMangler getJspMangler(String jspUri, String outputDir){
        return getJspMangler(getName(),jspUri,outputDir);
    }

    /**
        create an instance of a Cache implementation.  If the
        configuration property:
        <pre>
        * org.apache.jasper34.toolkit.cache.<i>name</i>
        </pre>
        has been set, then this will return
        an instance of the specified class.  Otherwise, or if
        <i>name</i> == null, if the
        Collections API is available, this class will return a
        Cache based on HashMap.  If the Collections API is not
        available, then this class will fallback to a Cache built
        around the Hashtable class.
        
        @param <b>name</b> name of toolkit implementation to use
        @param <b>maxSize</b> maximum size of cache
        @param <b>flushIncrement</b> number of elements to flush
                on cache overflow.
        @return an instance of a Cache.
    */
    protected Cache createCache(String name, int maxSize, int flushIncrement){
        name = name==null?"default":name;
        String className = getToolkitProperty(name,"cache");
        if(className==null){
            className = "org.apache.jasper34.util.MapCache";
        }
        Cache cache = null;
        Class c = null;
        try{
            c = Class.forName(s);
            cache = (Cache)c.newInstance();
        }catch(Exception e){
          // possible ClassDefNotFound, ClassCast, etc.
        }
        if(cache==null){
           try{         //first try Collections - based cache
               c = Class.forName("org.apache.jasper34.util.MapCache");
               cache = (Cache)c.newInstance();
           }catch(Exception e){ 
               // likely cause is no Collections API so
               // fallback to jdk1.1 compatible cache
               cache = new org.apache.jasper34.util.TableCache();
           }
        }
        cache.setMaxSize(maxSize);
        cache.setFlushIncrement(flushIncrement);
    }
    
    
    /**
        create and return an instance of a Cache implementation
        associated with the current toolkit implementation.  Equivalent
        to calling <code>createCache(getName(),maxSize,flushIncrement)</code>.
        
        @param <b>maxSize</b> maximum size of cache
        @param <b>flushIncrement</b> number of elements to flush
                on cache overflow.
        @return an instance of a Cache.
    */
    public Cache createCache(int maxSize,int flushIncrement){
        return createCache(getName(),maxSize,flushIncrement);
    }
    
    /**
        create an instance of a ModificationChecker of class specified
        by the configuration property:
        <pre>
        * org.apache.jasper34.toolkit.modificationchecker.<i>name</i>
        </pre>
        If not set, will default to use the implementation class
        <code>
        org.apache.jasper34.util.PeriodicJspRecursiveModificationChecker
        </code>.
        @param <b>name</b> implementation name
        @return an instance of ModificationChecker
    */
    protected ModificationChecker createModificationChecker(String name){
        name = name==null?"default":name;
		String className = getToolkitProperty(name,"modificationchecker");
        if(className==null){
            className = 
            "org.apache.jasper34.util.PeriodicJspRecursiveModificationChecker";
        }
        ModificationChecker m = null;
        try{
            Object obj = Class.forName(className).newInstance();
            m = (ModificationChecker)obj;
        }catch(Exception e){
            m = new PeriodicJspRecursiveModificationChecker();
        }
        return m;
    }
    
    
    /**
        return an instance of ModificationChecker of a type indicated
        by the implementation <i>name</i>, that compares the relative
        modification dates of <i>source</i> and <i>target</i>.  This 
        method will pool and reuse instances associated with the same
        source/target pair.
        @param <b>name</b> implementation name
        @param <b>source</b> File to compare modification date of
        @param <b>target</b> File to compare <i>source</i> to
        @return an instance of ModificationChecker
    */
    protected ModificationChecker getModificationChecker(String name,
                                                      File source,
                                                      File target){
        name = name==null?"default":name;
        String key = name+source.toString()+target.toString();
        ModificationChecker mc = (ModificationChecker)checkers.get(key);
        if(mc==null){
            mc = createModificationChecker(name,source,target);
            mc.init(source,target);
            checkers.put(key,mc);
        }
        return mc;        
    }
    
    /**
        return an instance of ModificationChecker of a type indicated
        by this toolkit's <i>name</i>, that compares the relative
        modification dates of <i>source</i> and <i>target</i>.  This 
        method will pool and reuse instances associated with the same
        source/target pair.
        @param <b>source</b> File to compare modification date of
        @param <b>target</b> File to compare <i>source</i> to
        @return an instance of ModificationChecker
    */
    public ModificationChecker getModificationChecker(File source, File target){
        return getModificationChecker(getName(),source,target);
    }
    
    
    /**
        creates an instance of a JspPageHandler using the implementation
        indicated by <i>name</i>.
        @param <b>name</b> implemenation name
        @param <b>jspUri</b> String URI to the JSP
        @return a JspPageHandler instance
    */
    protected JspPageHandler createJspPageHandler(String name,
                                                  String jspUri){
        name = name==null?"default":name;
		String className = getToolkitProperty(name,"pagehandler");
        if(className==null){
            className = 
            "org.apache.jasper34.servlet.JspServletPageHandler";
        }
        JspPageHandler jph = null;
        try{
            Object obj = Class.forName(className).newInstance();
            jph = (JspPageHandler)obj;
        }catch(Exception e){
            jph = new JspServletPageHandler();
        }
        jph.init(jspUri);
        return jph;
    }
    
    /**
        creates a JspPageHandler instance using the default implementation
        associated with the current toolkit instance.  Same as calling
        <code>createJspPageHandler(getName(),jspUri)</code>.
        @param <b>jspUri</b> String URI to the JSP
        @return a JspPageHandler instance
    */
    public JspPageHandler createJspPageHandler(String jspUri){
        return createJspPageHandler(getName(),jspUri);
    }
    
    
    /**
        create an instance of a JspCompiler using the <i>name</i>d
        implementation.
        @param <b>name</b> of implementation
        @return an instance of a JspCompiler
    */
    protected JspCompiler createJspCompiler(String name){
        name = name==null?"default":name;
		String className = getToolkitProperty(name,"modificationchecker");
        if(className==null){
            className = 
            "org.apache.jasper34.compiler.JspCompilerImpl";
        }
        JspCompiler jspc = null;
        try{
            Object obj = Class.forName(className).newInstance();
            jspc = (JspCompiler)obj;
        }catch(Exception e){
            jspc = new org.apache.jasper34.compiler.JspCompilerImpl();
        }
        return jspc;
    }
    
    /**
        return an instance of a JspCompiler associated with
        the <i>name</i>d JasperToolkit implementation.  This will
        always return the same instance for a given <i>name</i>.
        @param <b>name</b> of implementation
        @return an instance of a JspCompiler
    */
    public JspCompiler getJspCompiler(String name){
        name = name==null?"default":name;
        JspCompiler jspc = compilers.get(name);
        if(jspc == null){
            jspc = createJspCompiler(name);
            compilers.put(name,jspc);
        }
        return jspc;
    }
    
    /**
        same as <code>getJspCompiler(getName())</code>.
        @return an instance of a JSP Compiler
    */
    public JspCompiler getJspCompiler(){
        return getJspCompiler(getName());
    }


    /**
        create an instance of a JavaCompiler using the <i>name</i>d
        implementation.
        @param <b>name</b> of implementation
        @return an instance of a JavaCompiler
    */
    protected JavaCompiler createJavaCompiler(String name){
    
    }
    
    /**
        return an instance of a JavaCompiler associated with
        the <i>name</i>d JasperToolkit implementation.  This will
        always return the same instance for a given <i>name</i>.
        @param <b>name</b> of implementation
        @return an instance of a JavaCompiler
    */
    public JavaCompiler getJavaCompiler(String name){
        
    }
    
    /**
        return an instance of a JavaCompiler.
    */
    public JavaCompiler getJavaCompiler(){
        return getJavaCompiler(getName());
    }
    
    /**
        return an instance of a ClassLoader
    */
    public ClassLoader createClassLoader(){
        return getClass().getClassLoader();
    }
    
}
