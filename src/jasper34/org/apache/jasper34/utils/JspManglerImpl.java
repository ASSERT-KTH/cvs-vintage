/* Generated by Together */

package org.apache.jasper34.utils;

import org.apache.jasper34.toolkit.JasperToolkit;
import org.apache.jasper34.servlet.JspServlet;

/**
	an implementation of the JspMangler interface for deriving valid
    java class, package, source file and class file names for an indicated Jsp
    URI and output directory.
*/
public class JspManglerImpl implements JspMangler{
 	//set up some caches to avoid rebuilding frequently used names
 	private static JasperToolkit tk = JasperToolkit.getToolkit(null);//get default toolkit
	private static Cache packageNameCache = tk.createCache(CacheDefaults.JSP_CACHE_SIZE);
	private static Cache classNameCache = tk.createCache(CacheDefaults.JSP_CACHE_SIZE);
	private static Cache javaFileNameCache = tk.createCache(CacheDefaults.JSP_CACHE_SIZE);
	private static Cache classFileNameCache = tk.createCache(CacheDefaults.JSP_CACHE_SIZE);

    /** allowed first letters for package and class names */
    public static final String ALLOWED_FIRSTLETTERS=
    	"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    /** allowed letters (after the first) for package and class names */
    public static final String ALLOWED_LETTERS=ALLOWED_FIRSTLETTERS+"0123456789";

    /** reserved java keywords */
    public static final String KEYWORDS =  
        "abstract:boolean:break:byte:"+
        "case:catch:char:class:"+
        "const:continue:default:do:"+
        "double:else:extends:final:"+
        "finally:float:for:goto:"+
        "if:implements:import:"+
        "instanceof:int:interface:"+
        "long:native:new:package:"+
        "private:protected:public:"+
        "return:short:static:super:"+
        "switch:synchronized:this:"+
        "throw:throws:transient:"+ 
        "try:void:volatile:while:" 
    ;

     /**
    	name of property to set the JSP_PACKAGE used to
    	name the top-level of the package hierarchy of
    	java classes generated when parsing/compiling
    	jsp pages.  Set in properties like so:<p>
    	<pre><code>
*		org.apache.jasper.compiler.package_prefix = com.foo
		</code></pre>
		Default value is "jsp_servlet".
    */
    public static final String JSP_PACKAGE_PROPERTY = 
    	"org.apache.jasper.compiler.jsp_package";
    
    /**
    	the top-level package underwhich all java classes
    	generated from jsp files are placed.
    */
    public static final String JSP_PACKAGE;
    
    /**
    	name of property to set the PACKAGE_PREFIX used to
    	munge the names of the package hierarchy when generating
    	java classes from jsp files.  Set in properties like so:<p>
    	<pre><code>
*		org.apache.jasper.compiler.package_prefix = _
		</code></pre>
		Default value is "" (empty String).
    */
    public static final String PACKAGE_PREFIX_PROPERTY = 
    	"org.apache.jasper.compiler.package_prefix";
    
    /**
    	string used to prefix all package names generated by
        the mangler.
    */
    public static final String PACKAGE_PREFIX;
    
    static{
    	String s=null;
   		s=System.getProperty(JSP_PACKAGE_PROPERTY);
		if(s==null){
			s="jsp_servlet";
		}
		if(!s.equals("")){
			try{
				s = manglePackageName(s);
			}catch(IllegalArgumentException e){
				throw new Error(
					"Invalid property value setting for property="+JSP_PACKAGE_PROPERTY+
					" : value="+System.getProperty(JSP_PACKAGE_PROPERTY)+
					" is not allowed! Nested exception is: "+e);
			}
		}
		JSP_PACKAGE = s;
    	s=null;
    	s=System.getProperty(PACKAGE_PREFIX_PROPERTY);
		if(s==null){
			s="";
		}
		if(!s.equals("")){
			if(ALLOWED_FIRSTLETTERS.indexOf(s.charAt(0))==-1){
				s = "_"+s;
			}
		}
		PACKAGE_PREFIX = s;
    }

    private static char fs = File.separatorChar;

    private String jspUri;
    private String outputDir;
    private File jspFile;
    private String packageName;
    private String className;
    private String classFileName;
    private String javaFileName;
    
    /**
        default, no-argument constructor
    */
    public JspManglerImpl(){
    }
    
   /**
    	constructs a JspMangler for the jsp file indicated
        by <i>jspUri</i> and the output directory <i>outputDir</i>.
        @param <b>jspUri</b> URI pointing to the jsp file
        @param <b>outputDir</b> absolute path to Jasper scratchDir.
    */
    public JspManglerImpl(String jspUri, File outputDir){
        this(jspUri,outputDir.getAbsolutePath());
    }

    /**
    	constructs a JspMangler for the jsp file indicated
        by <i>jspUri</i> and the output directory <i>outputDir</i>.
        @param <b>jspUri</b> URI pointing to the jsp file
        @param <b>outputDir</b> absolute path to Jasper scratchDir.
    */
    public JspManglerImpl(String jspUri, String outputDir){
        setJspUri(jspUri);
        setOutputDir(outputDir);
    }
    
    public void setJspUri(String jspUri){
        this.jspUri = jspUri;
    }
    
    public String getJspUri(){
        return jspUri;
    }
    
    
    public void setOutputDir(String outputDir){
        this.outputDir = outputDir;
    }
    
    public String getOutputDir(){
        return outputDir;
    }
    
    /**
        resets all derived fields - allows object
        to be recycled.  Invoked whenever setJspUri()
        or setOutputDir() are invoked.
    */
    private void reset(){
        jspFile = null;
        packageName = null;
        className = null;
        classFileName = null;
        javaFileName = null;
    }
    
    /**
        returns a File object derived from the getJspUri()
        String.  File separators are normalized to the host
        platform.  Note - if the getJspUri() String begins
        with a file separator, the resulting File object
        returned from this method call may look like it is 
        an absolute path, but it is probably not since the URI
        is still likely to be context or serverroot-relative.
         
        @return a File object derived from the getJspUri()
                String.
    */
    public File getJspFile(){
        if(jspFile==null){
            jspFile = new File(getJspUri().replace('/',fs);
        }
        return jspFile;
    }
    
    /** 
        The package name. It is based on the .jsp URI, with
        all unsafe components mangled.
    */
	public String getPackageName(){
        if(packageName==null){
        	packageName = 
        		buildPackageName(getJspFile());
        }
        return packageName;
    }
    
    /** 
        The class name ( without package ) of the
        generated servlet
    */
	public String getClassName(){
        if(className==null){
        	className = 
        		buildClassName(getJspFile());
        }
        return className;
    }
    
     /**
		Utility method to get the full class name from the package and
		class name. 
     */
    public String getFullClassName(){
    	String fullName = getPackageName();
    	if(fullName==null||fullName.equals("")){
    		fullName = getClassName();
    	}else{
        	fullName = fullName+"."+getClassName();
		}
        return fullName;
    }

   
    
	/** 
	    The absolute path & name of the .class file
     */
	public String getClassFileName(){
        if(classFileName==null){
        	classFileName = 
        		buildClassFileName(getOutputDir(),getFullClassName());
        }
        return classFileName;
    }
    
    /** 
        The absolute path and name of the .java file
    */
	public String getJavaFileName(){
        if(javaFileName==null){
        	javaFileName = 
        		buildJavaFileName(getOutputDir(),getFullClassName());
        }
        return javaFileName;
    }
    
	/**
		<p>builds a java-style package name based on the
		path information in <i>file</i>.  Basically, it
		uses the name of each node in the path sequence
		up to but excluding the base name of <i>file</i>
		to build the package name in order.  In addition,
		if JspConstants.JSP_PACKAGE is not null, that string is used
		for the top-level package.  Further, each
		package node name is set to lowercase and prefixed
		with the value of JspConstants.PACKAGE_PREFIX.</p>
		<p>
		For example, let <i>file</i> correspond to the path
		"foo/somedir/myfile.jsp", JSP_PACKAGE="jsproot" and
		PACKAGE_PREFIX="x".  In that case the return value
		would be "jsproot.xfoo.xsomedir".</p>
		<p>
		Leading file-separators are ignored (i.e. it treats
		relative and absolute File paths equivalently).</p>

		@param <b>file</b> a File object.
        @return String name of a java class package.	
	*/
	public static String buildPackageName(File file){
		String name = file.getName();
		File parent = file.getParentFile();
		String key = parent.toString();
		if(packageNameCache.containsKey(key)){ //have we done this one before?
			return (String)packageNameCache.get(key);
		}
		LinkedList stack = new LinkedList();
		String pname;
		while(parent!=null && !(pname = parent.getName()).equals("")){
			stack.add(pname);
			parent = parent.getParentFile();
		}
		StringBuffer sb = new StringBuffer();
		if(JspConstants.JSP_PACKAGE!=null && !JspConstants.JSP_PACKAGE.equals("")){
			sb.append(JspConstants.JSP_PACKAGE).append(".");
		}
		while(!stack.isEmpty()){
			name=(String)stack.removeLast();
			name=manglePackageName(JspConstants.PACKAGE_PREFIX+name);
			sb.append(name).append(".");
		}
		sb.setLength(sb.length()-1);
		packageNameCache.put(key,sb.toString());//cache the result
		return sb.toString();
	}

	/**
		asserts that the String <i>name</i> conforms to the
		java package name specification.  First of all, <i>name</i>
		must have at least one alphanumeric lowercase letter.
		It is then rendered to lowercase.  Next, if <i>name</i> does
		not start with an allowed letter, it is prefixed with
		an underscore ('_').  Subsequently, if <i>name</i>
		contains any dissallowed letters, they are replaced with
		an underscore ('_').  The last test is if the resulting
		munged name is a disallowed keyword, then it is prefixed
		with a leading underscore (this won't happen if it is
		already prefixed).
		
		@param <b>name</b> package name to mangle
		@return a String mangled to be a valid package name
	*/
	protected static String manglePackageName(String name){
		if(name!=null){
			name = name.trim();
		}
		if(name==null||name.equals("")||name.equals("_")){
			throw new IllegalArgumentException(
				"JspMangler.manglePackageName() : "+
				"Illegal package name = "+name+" ! "+
				"Jsp Package names must be non-null and contain at"+
				" least one alphanumeric character!"
			);
		}
		String mangledName = mangleNameLetters(name.toLowerCase());
		if(KEYWORDS.indexOf(mangledName+":") != -1){
			mangledName = "_"+mangledName;
		}
		return mangledName;
	}
	
	/**
		asserts that the letters in <i>name</i> conform to the following
		rules:<br></br>
		<ol>
		<li>If <i>name</i> is null or an empty String, returns an empty String.</li>
		<li>If the first letter is not of the set ALLOWED_FIRSTLETTERS then <i>name</i>
		is prefixed with an underscore ('_').</li>
		<li>If any subsequent letters are not of the set ALLOWED_LETTERS, then
		they are replaced with an underscore ('_').</li>
		</ol>
		
		@param <b>name</b> a String
		@return a String mangled to have valid letters
	*/
	protected static String mangleNameLetters(String name){
		if(name==null || name.equals("")){
			return "";
		}
		if(ALLOWED_FIRSTLETTERS.indexOf(name.charAt(0)) == -1){
			name = "_"+name;
		}
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<name.length();i++){
			char ch = name.charAt(i);
			if(ALLOWED_LETTERS.indexOf(ch) == -1){
				sb.append('_');
			}else{
				sb.append(ch);
			}
		}
		name = sb.toString();
		if(name.startsWith("_")){
			String temp = name.replace('_',' ').trim(); //check for all '_'
			if(temp.equals("")){
				throw new IllegalArgumentException(
					"JspMangler.mangleNameLetters() : "+
					"Illegal package or class name = "+name+" ! "+
					"Jsp Package names must be non-null and contain at"+
					" least one alphanumeric character!"
				);
			}
		}
		return sb.toString();
	}

	/**
		calculates the base class name
		of the java class derived from the JSP file
		indicated by <i>jsp</i>. If JspConstants.PACKAGE_PREFIX
		is set, the base class name will be prefixed.
		The class name is mangled to remove any
		disallowed characters.
		
		@param <b>aJspFile</b> a File object for a JSP page
		@return the base class name for the derived java class
	*/
	public static String buildClassName(File aJspFile){
		String name = aJspFile.getName();
		String key = name;
		if(classNameCache.containsKey(key)){ //check cache
			return (String)classNameCache.get(key);
		}
		if(name.endsWith(".jsp")){
			name = name.substring(0,name.length()-4);
		}
		if(JspConstants.PACKAGE_PREFIX !=null){
			name = JspConstants.PACKAGE_PREFIX+name;
		}
		name = mangleNameLetters(name);
		classNameCache.put(key,name);//put in cache
		return name;
	}

	/**
		constructs an absolute filename to a .java file corresponding
		to the fully-qualified class name <i>clsName</i>, using
		the directory indicated by <i>srcDir()</i> as the root for
		the path.
		@param <b>srcDir</b> path to source code root directory
		@param <b>clsName</b> fully-qualified name of class
		@return filename of .java file
	*/
	public static String buildJavaFileName(String srcDir, String clsName){
		String key = srcDir+":"+clsName;
		if(javaFileNameCache.containsKey(key)){
			return (String)javaFileNameCache.get(key);
		}
		File javaFile = new File(srcDir);
		StringTokenizer st = new StringTokenizer(clsName,".");
		while(st.hasMoreTokens()){
			String fname = st.nextToken();
			if(!st.hasMoreTokens()){
				fname = fname+".java";
			}
			javaFile = new File(javaFile,fname);
		}
		String fname = javaFile.getAbsolutePath();
		javaFileNameCache.put(key,fname);
		return fname;
	}


	/**
		constructs an absolute filename to a .class file corresponding
		to the fully-qualified class name <i>clsName</i>, using
		the directory indicated by <i>clsDir()</i> as the root for
		the path.
	*/
	public static String buildClassFileName(String clsDir, String clsName){
		String key = clsDir+":"+clsName;
		if(classFileNameCache.containsKey(key)){
			return (String)classFileNameCache.get(key);
		}
		File javaFile = new File(clsDir);
		StringTokenizer st = new StringTokenizer(clsName,".");
		while(st.hasMoreTokens()){
			String fname = st.nextToken();
			if(!st.hasMoreTokens()){
				fname = fname+".class";
			}
			javaFile = new File(javaFile,fname);
		}
		String fname = javaFile.getAbsolutePath();
		classFileNameCache.put(key,fname);
		return fname;
	}
}
