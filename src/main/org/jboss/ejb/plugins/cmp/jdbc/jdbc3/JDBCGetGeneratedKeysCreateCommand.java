/*
 * JBoss, the OpenSource J2EE webOS
 *
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 */

package org.jboss.ejb.plugins.cmp.jdbc.jdbc3;

import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.ejb.CreateException;
import javax.ejb.DuplicateKeyException;
import javax.sql.DataSource;

import org.jboss.ejb.EntityEnterpriseContext;
import org.jboss.ejb.plugins.cmp.jdbc.bridge.JDBCFieldBridge;
import org.jboss.ejb.plugins.cmp.jdbc.bridge.JDBCCMPFieldBridge;
import org.jboss.ejb.plugins.cmp.jdbc.bridge.JDBCEntityBridge;
import org.jboss.ejb.plugins.cmp.jdbc.JDBCCreateEntityCommand;
import org.jboss.ejb.plugins.cmp.jdbc.JDBCStoreManager;
import org.jboss.ejb.plugins.cmp.jdbc.JDBCUtil;
import org.jboss.logging.Logger;

/**
 * JDBCGetGeneratedKeysCreateCommand executes an INSERT INTO query.
 * This command uses getGeneratedKeys method to fetch the generated
 * by database value of the primary key. Thus, it's not available only
 * in JDK version less than 1.4.
 *
 * @author <a href="mailto:loubyansky@hotmail.com">Alex Loubyansky</a>
 *
 * @version $Revision: 1.1 $
 */
public class JDBCGetGeneratedKeysCreateCommand
   extends JDBCCreateEntityCommand
{

   // JDBCCreateEntityCommand overrides ---------------------------

   /**
    * The method differs only in that, it has no entityExistsSQL
    */
   public void init(JDBCStoreManager manager)
   {
      this.manager = manager;
      entity = manager.getEntityBridge();

      // Create the Log
      log = Logger.getLogger( this.getClass().getName()
         + "." + manager.getMetaData().getName());

      // set create allowed
      createAllowed = true;
      List fields = entity.getFields();
      for( Iterator iter = fields.iterator(); iter.hasNext(); )
      {
         JDBCFieldBridge field = (JDBCFieldBridge)iter.next();
         if( field.isPrimaryKeyMember() && field.isReadOnly() )
         {
            createAllowed = false;
            break;
         }
      }
      
      if(createAllowed)
      {
         insertFields = getInsertFields();
         insertEntitySQL = createInsertEntitySQL();
         log.debug("Insert Entity SQL: " + insertEntitySQL);
      }
      else
      {
         log.debug("Create will not be allowed.");
      }
   }
  
   /**
    * The method adds to insert fields only non-primary key fields
    */
   protected List getInsertFields()
   {
      List fields = entity.getFields();
      List insertFields = new ArrayList(fields.size());

      for( Iterator iter = fields.iterator(); iter.hasNext(); )
      {
         JDBCFieldBridge field = (JDBCFieldBridge)iter.next();
         if( !field.isReadOnly() && !field.isPrimaryKeyMember() )
         {
            insertFields.add(field);
         } 
      }
      return insertFields;
   }

   protected String createEntityExistsSQL()
   {
      return null;
   }

   public Object execute( Method m,
                          Object[] args,
                          EntityEnterpriseContext ctx )
      throws CreateException
   {

      // primary key to return
      Object pk = null;

      if(!createAllowed)
      {
         throw new CreateException("Creation is not allowed because a " +
            "primary key field is read only.");
      }

      // the key is generated by the database
      insertEntity(ctx);
      pk = entity.extractPrimaryKeyFromInstance(ctx);
      log.debug("Created: pk="+pk);

      return pk;         
   }

   protected boolean entityExists(Object pk)
      throws CreateException
   {
      return false;
   }
   
   protected void insertEntity(EntityEnterpriseContext ctx)
         throws CreateException{

      Connection con = null;
      PreparedStatement ps = null;
      int rowsAffected  = 0;
      try
      {
         // get the connection
         DataSource dataSource = entity.getDataSource();
         con = dataSource.getConnection();
         
         // create the statement
         log.debug("Executing SQL: " + insertEntitySQL);
         ps = con.prepareStatement(insertEntitySQL,
                 PreparedStatement.RETURN_GENERATED_KEYS);

         // set the parameters
         int index = 1;
         for( Iterator iter = insertFields.iterator(); iter.hasNext(); )
         {
            JDBCFieldBridge field = (JDBCFieldBridge)iter.next();
            index = field.setInstanceParameters(ps, index, ctx);
         }

         // execute statement
         rowsAffected = ps.executeUpdate();
         // check results
         if(rowsAffected != 1)
         {
            throw new CreateException("Insertion failed. Expected one " +
               "affected row: rowsAffected=" + rowsAffected +
               "id=" + ctx.getId());
         }
         log.debug("Rows affected = " + rowsAffected);

         // fetch generated keys
         ResultSet rs = ps.getGeneratedKeys();
         Object pk = null;
         if( rs.next() ) pk = rs.getObject( 1 );

         if( pk == null )
         {
            throw new Exception( "Primary key isn't generated." );
         }

         // write pk fields to the context
         for( Iterator iter = entity.getPrimaryKeyFields().iterator();
            iter.hasNext(); )
         {
            JDBCCMPFieldBridge cmpField = (JDBCCMPFieldBridge) iter.next();
            cmpField.setInstanceValue( ctx, pk );
            break;
         }
      }
      catch( CreateException ce )
      {
         throw ce;
      }
      catch(Exception e)
      {
         log.error("Could not create entity", e);
         throw new CreateException("Could not create entity:" + e);
      } finally {
         JDBCUtil.safeClose(ps);
         JDBCUtil.safeClose(con);
      }

      // Mark the inserted fields as clean.
      for( Iterator iter = insertFields.iterator(); iter.hasNext(); )
      {
         JDBCFieldBridge field = (JDBCFieldBridge)iter.next();
         field.setClean(ctx);
      }
   }
}
