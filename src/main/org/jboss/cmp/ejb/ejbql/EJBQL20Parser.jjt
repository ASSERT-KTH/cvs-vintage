/***************************************
 *                                     *
 *  JBoss: The OpenSource J2EE WebOS   *
 *                                     *
 *  Distributable under LGPL license.  *
 *  See terms of license at gnu.org.   *
 *                                     *
 ***************************************/

options {
  STATIC=false;
  MULTI=true;
  NODE_DEFAULT_VOID=true;
  BUILD_NODE_FILES=false;
}
PARSER_BEGIN(EJBQL20Parser)
package org.jboss.cmp.ejb.ejbql;

public class EJBQL20Parser {
}

PARSER_END(EJBQL20Parser)

ASTEJBQL EJBQL() #EJBQL :
{}
{
  SelectClause() FromClause() [ WhereClause() ] <EOF>
  { return jjtThis; }
}

void SelectClause() #Select :
{}
{
  <SELECT> [ <DISTINCT> { jjtThis.distinct = true; } ]
  ( <OBJECT> "(" IdentificationVariable() ")"
  | PathExpression()
  )
}

void FromClause() #From :
{}
{
  <FROM> RangeVariableDeclaration() ( "," IdentificationVariableDeclaration() )*
}

void IdentificationVariableDeclaration() :
{}
{
  RangeVariableDeclaration() | CollectionMemberDeclaration()
}

void CollectionMemberDeclaration() #IdDeclaration :
{}
{
  <IN> "(" PathExpression() ")"  [<AS>] Identifier()
}

void RangeVariableDeclaration() #IdDeclaration :
{}
{
  Identifier() [<AS>] Identifier()
}

void WhereClause() #Where :
{}
{
  <WHERE> ConditionalExpression()
}

void ConditionalExpression():
{}
{
  ( ConditionalTerm() ( <OR> ConditionalTerm() )* ) #Or(>1)
}

void ConditionalTerm() :
{}
{
  ( ConditionalFactor() ( <AND> ConditionalFactor() )* ) #And(>1)
}

void ConditionalFactor() :
{boolean not = false;}
{
  ( [<NOT> {not=true;}] ConditionalPrimary() ) #Not(not)
}

void ConditionalPrimary() :
{}
{
  "(" ConditionalExpression() ")"
|
  SimpleCondExpression()
}

void SimpleCondExpression() #Condition :
{ Token t;}
{
  ( LOOKAHEAD(Identifier() ".") (
      ( PathExpression() (
          t=<COMPARISION_OPERATOR> Expression()
        | <IS> [<NOT> {jjtThis.not=true;} ] ( t=<NULL> | t=<EMPTY> )
        | [<NOT> {jjtThis.not=true;} ] (
            t=<IN> "(" <STRING_LITERAL> ( "," <STRING_LITERAL> )+ ")"
          | t=<LIKE> <STRING_LITERAL> [ <ESCAPE> <STRING_LITERAL> ]
          | t=<MEMBER> [<OF>] PathExpression()
          )
        )
      )
    )
  | (
    ( IdentificationVariable() | InputParameter() ) [<NOT> {jjtThis.not=true;} ] t=<MEMBER> [<OF>] PathExpression()
    )
  ) { jjtThis.token = t;}
}

void Expression() :
{}
{
  Term() ( ( "+" | "-" ) Term() )*
}

void Term() :
{}
{
  Factor() ( ( "*" | "/" ) Factor() )*
}

void Factor() :
{}
{
    Literal()
  | PathExpression()
  | InputParameter()
  | "(" Expression() ")"
  | <CONCAT> "(" Expression() "," Expression() ")"
  | <SUBSTRING> "(" Expression() "," Expression() "," Expression() ")"
  | <LENGTH> "(" Expression() ")"
  | <LOCATE> "(" Expression() "," Expression() [ "," Expression() ] ")"
  | <ABS> "(" Expression() ")"
  | <SQRT> "(" Expression() ")"
}

void PathExpression() #Path :
{}
{
  IdentificationVariable() ( "." Identifier() )+
}

void IdentificationVariable() :
{}
{
  Identifier()
}

void Identifier() #Identifier() :
{ Token t;}
{
  t=<IDENTIFIER> { jjtThis.setName(t.image); }
}

void InputParameter() #InputParameter:
{Token t;}
{
  "?" t=<INTEGER_LITERAL> { jjtThis.id = Integer.parseInt(t.image)-1; }
}

void Literal() #Literal :
{}
{
    jjtThis.token=<INTEGER_LITERAL>
  | jjtThis.token=<FLOATING_POINT_LITERAL>
  | jjtThis.token=<STRING_LITERAL>
  | jjtThis.token=<BOOLEAN_LITERAL>
}

TOKEN [IGNORE_CASE]:
{
    < ABS:        "ABS" >
  | < AND:        "AND" >
  | < AS:         "AS" >
  | < CONCAT:     "CONCAT" >
  | < DISTINCT:   "DISTINCT" >
  | < EMPTY:      "EMPTY" >
  | < ESCAPE:     "ESCAPE" >
  | < FROM:       "FROM" >
  | < IN:         "IN" >
  | < IS:         "IS" >
  | < LENGTH:     "LENGTH" >
  | < LIKE:       "LIKE" >
  | < LOCATE:     "LOCATE" >
  | < MEMBER:     "MEMBER" >
  | < NOT:        "NOT" >
  | < NULL:       "NULL" >
  | < OBJECT:     "OBJECT" >
  | < OF:         "OF" >
  | < OR:         "OR" >
  | < SELECT:     "SELECT" >
  | < SQRT:       "SQRT" >
  | < SUBSTRING:  "SUBSTRING" >
  | < WHERE:      "WHERE" >
  | < BOOLEAN_LITERAL: "FALSE" | "TRUE" >
}

TOKEN:
{
    < IDENTIFIER : (<LETTER>) (<LETTER> | <DIGIT> )* >
  | < #LETTER: ["a"-"z","A"-"Z","_"] >
  | < #DIGIT: ["0"-"9"] >
}

TOKEN:
{
  < COMPARISION_OPERATOR: "=" | "<>" | "<" | ">" | "<=" | ">=" >
}

TOKEN:
{
  < STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
}

TOKEN:
{
    < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
    >
  | < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
  | < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < #OCTAL_LITERAL: "0" (["0"-"7"])* >
  | < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
    >
  | < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}
