## Copyright (C) 2002-2003, Simon Nieuviarts
##
## This library is free software; you can redistribute it and/or
## modify it under the terms of the GNU Lesser General Public
## License as published by the Free Software Foundation; either
## version 2.1 of the License, or any later version.
## 
## This library is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## Lesser General Public License for more details.
## 
## You should have received a copy of the GNU Lesser General Public
## License along with this library; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
## USA
// This is a cluster stub implementation
// Generated by GenIC via Velocity. Do not edit directly this file.

#if ($pkgName != "")
package $pkgName;

#end
public class ${className}_Cluster implements org.objectweb.carol.cmi.ClusterStub, java.io.Externalizable, $classConf.getRemoteItfString() {
	private transient org.objectweb.carol.cmi.ClusterStubData csd;

	// lb choosers
#foreach ($c in $classConf.getRR())
	private transient org.objectweb.carol.cmi.StubLB $c;
#end
#foreach ($c in $classConf.getRandom())
	private transient org.objectweb.carol.cmi.StubLB $c;
#end

	// used by the DistributedEquivSystem
	public ${className}_Cluster(org.objectweb.carol.cmi.ClusterStubData csd) {
		this.csd = csd;
#foreach ($c in $classConf.getRR())
		$c = csd.getRoundRobin();
#end
#foreach ($c in $classConf.getRandom())
		$c = csd.getRandom();
#end
	}

	// used only by Externalizable
	public ${className}_Cluster() {
	}

	public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {
		csd.write(out);
	}

	public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {
		csd = org.objectweb.carol.cmi.ClusterStubData.read(in, this);
#foreach ($c in $classConf.getRR())
		$c = csd.getRoundRobin();
#end
#foreach ($c in $classConf.getRandom())
		$c = csd.getRandom();
#end
	}

#foreach ($mc in $classConf.getMethodConfs())
#set($lb = $mc.getBalancer())
	//$mc.getBalancer()
	public $mc.getReturnTypeName() $mc.getMthName()($mc.getParamString()) throws $mc.getThrowsString() {
		org.objectweb.carol.cmi.StubData sd = ${lb}.get();
		$mc.getDeclItfName() stub = ($mc.getDeclItfName()) sd.getStub();
		org.objectweb.carol.cmi.StubLBFilter filter = null;
		do {
			try {
				if (csd.isStubDebug()) {
					csd.debug("cluster invocation of " + "$mc.getMthName()()");
				}
#if ($mc.returnsVoid())
				stub.$mc.getMthName()($mc.getParamNamesString());
				return;
#else
				$mc.getReturnTypeName() result = stub.$mc.getMthName()($mc.getParamNamesString());
				return result;
#end
			} catch (java.rmi.RemoteException e) {
				if (!(e instanceof java.rmi.ConnectException)
					&& !(e instanceof java.rmi.ConnectIOException)) {
					throw e;
				}
				if (csd.isStubDebug()) {
					csd.debug("Connection refused, retry");
				}
				if (filter == null) {
					filter = new org.objectweb.carol.cmi.StubLBFilter();
				}
				filter.add(sd);
				sd = ${lb}.get(filter);
				stub = ($mc.getDeclItfName()) sd.getStub();
			}
		} while (true);
	}

#end
	public java.lang.String toString() {
		return this.getClass().getName() + csd.toContentsString();
	}
}
