## Copyright (C) 2002-2003, Simon Nieuviarts
##
## This library is free software; you can redistribute it and/or
## modify it under the terms of the GNU Lesser General Public
## License as published by the Free Software Foundation; either
## version 2.1 of the License, or any later version.
## 
## This library is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## Lesser General Public License for more details.
## 
## You should have received a copy of the GNU Lesser General Public
## License along with this library; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
## USA
// This is a cluster stub implementation
// Generated by GenIC via Velocity. Do not edit directly this file.

#if ($pkgName != "")
package $pkgName;

#end
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Externalizable;
import java.rmi.ConnectException;
import java.rmi.ConnectIOException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import org.objectweb.carol.cmi.ClusterId;
import org.objectweb.carol.cmi.ClusterStub;
import org.objectweb.carol.cmi.ClusterStubData;
import org.objectweb.carol.cmi.Random;
import org.objectweb.carol.cmi.RoundRobin;
import org.objectweb.carol.cmi.StubLB;
import org.objectweb.carol.cmi.StubLBFilter;
import org.objectweb.carol.cmi.Trace;

public class ${className}_Cluster implements ClusterStub, Externalizable, $classConf.getRemoteItfString() {
	private transient ClusterStubData csd;

	// lb choosers
#foreach ($c in $classConf.getRR())
	private transient StubLB $c;
#end
#foreach ($c in $classConf.getRandom())
	private transient StubLB $c;
#end

	// used by the DistributedEquivSystem
	public ${className}_Cluster(ClusterStubData csd) {
		this.csd = csd;
#foreach ($c in $classConf.getRR())
		$c = csd.getRoundRobin();
#end
#foreach ($c in $classConf.getRandom())
		$c = csd.getRandom();
#end
	}

	// used only by Externalizable
	public ${className}_Cluster() {
	}

	public void writeExternal(ObjectOutput out) throws IOException {
		csd.write(out);
	}

	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
		csd = ClusterStubData.read(in, this);
#foreach ($c in $classConf.getRR())
		$c = csd.getRoundRobin();
#end
#foreach ($c in $classConf.getRandom())
		$c = csd.getRandom();
#end
	}

#foreach ($mc in $classConf.getMethodConfs())
#set($lb = $mc.getBalancer())
	//$mc.getBalancer()
	public $mc.getReturnTypeName() $mc.getMthName()($mc.getParamString()) throws $mc.getThrowsString() {
		$mc.getDeclItfName() stub = ($mc.getDeclItfName()) ${lb}.get();
		StubLBFilter filter = null;
		do {
			try {
				if (Trace.CSTUB) {
					Trace.out("cluster invocation of " + "$mc.getMthName()()");
				}
#if ($mc.returnsVoid())
				stub.$mc.getMthName()($mc.getParamNamesString());
				return;
#else
				$mc.getReturnTypeName() result = stub.$mc.getMthName()($mc.getParamNamesString());
				return result;
#end
			} catch (RemoteException e) {
				if (!(e instanceof ConnectException)
					&& !(e instanceof ConnectIOException)) {
					throw e;
				}
				if (Trace.CSTUB) {
					Trace.out("CSTUB: Connection refused, retry");
				}
				if (filter == null) {
					filter = new StubLBFilter();
				}
				filter.add(stub);
				stub = ($mc.getDeclItfName()) ${lb}.get(filter);
			}
		} while (true);
	}

#end
}
