/*
 * Copyright (C) 2002-2003, Simon Nieuviarts
 */
/***
 * Jonathan: an Open Distributed Processing Environment
 * Copyright (C) 1999 France Telecom R&D
 * Copyright (C) 2002, Simon Nieuviarts
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Release: 2.0
 *
 * Contact: jonathan@objectweb.org
 *
 * Author: Kathleen Milsted
 *
 * with contributions from:
 *   Francois Horn
 *   Bruno Dumant
 *
 */
package org.objectweb.carol.cmi.compiler;

import java.util.Vector;
import java.io.File;

public class ClusterConfigCompiler {

    private ClassContext classctx;
    private String configClassName, configFileName, configFullFileName;
    private FileStream configFile;
    private Vector remItfs;
    private MethodContext[] remMths;
    private int nbMths;
    private CompilerContext cmpCtx;

    private static String pre1 = "\t";
    private static String pre2 = pre1 + "\t";
    private static String pre3 = pre2 + "\t";
    private static String pre4 = pre3 + "\t";

    ClusterConfigCompiler(CompilerContext cCtx) {
        cmpCtx = cCtx;
    }

    void run(String className, ClusterConf cconf) throws Exception {
        Utils.trace_header(cmpCtx);
        Utils.trace("generating a cluster config class for " + className, cmpCtx);
        prepare(className);
        try {
            writeConfig(cconf);
            if (cmpCtx.compile) {
                Utils.compileFile(cmpCtx, configFullFileName);
            }
            if (!cmpCtx.keep) {
                Utils.deleteFile(cmpCtx, configFullFileName);
            }
        } catch (Exception e) {
            if (!cmpCtx.keep)
                Utils.deleteFile(cmpCtx, configFullFileName);
            throw e;
        }
    }

    void prepare(String className) throws Exception {
        // First, get all the relevant information for the class
        // In particular, getting the remote interfaces of the class
        // includes checking if the class directly implements
        // (in the implements clause of its declaration) at least one
        // remote interface. If not, an error will be thrown.
        classctx = new ClassContext(cmpCtx, className);
        remItfs = classctx.getRemoteInterfaces();
        remMths = classctx.getRemoteMethodContexts();
        nbMths = remMths.length;
        // prepare for generating the config object
        configClassName = classctx.clName + "_ClusterConfig";
        configFileName = configClassName + ".java";
        configFullFileName =
            classctx.genDirName + File.separator + configFileName;
        Utils.trace("config object source file is " + configFullFileName, cmpCtx);
        configFile = new FileStream(classctx.genDirName, configFileName);
    }

    void writeConfig(ClusterConf cconf) throws Exception {
        writeConfigHeader();
        writeConfigConstructors();
        writeConfigMethods(cconf);
        writeConfigFoot();
    }

    void writeConfigHeader() throws Exception {
        configFile.write(
            "/***\n"
                + " * Config class generated by the cluster stub compiler "
                + CompilerContext.version
                + "\n"
                + " */\n\n");
        if (!classctx.inGlobalPkg) {
            Utils.trace("config file: writing package declaration", cmpCtx);
            configFile.write("package " + classctx.pkgName + ";\n");
            configFile.write("\n");
        }
        Utils.trace("config file: writing imports", cmpCtx);
        // imports
        configFile.write("import java.rmi.Remote;\n");
        configFile.write("import java.rmi.RemoteException;\n");

        configFile.write("\n");
        String itfStr = "";
        for (int i = 0; i < remItfs.size(); i++) {
            if (((Class) remItfs.elementAt(i)).equals(java.rmi.Remote.class))
                continue;
            if (i > 0)
                itfStr = itfStr + ", ";
            itfStr = itfStr + ((Class) remItfs.elementAt(i)).getName();
        }
        Utils.trace("config file: writing class declaration", cmpCtx);
        configFile.write("/**\n");
        configFile.write(
            " * Cluster config class for " + classctx.clName + "\n");
        configFile.write(" */\n");
        configFile.write(
            "public class "
                + configClassName
                + "\n"
                + "implements org.objectweb.carol.cmi.ClusterConfig {\n");
        configFile.write("\n");
    }

    void writeConfigConstructors() {
        Utils.trace("config file: writing constructors", cmpCtx);
        configFile.write(pre1 + "// constructors\n");
        configFile.write(pre1 + "public " + configClassName + "() {\n");
        configFile.write(pre1 + "}\n\n");

        configFile.write(
            pre1
                + "private static org.objectweb.carol.cmi.ClusterConfig instance = new "
                + configClassName
                + "();\n\n");
        configFile.write(pre1 + "// getter\n");
        configFile.write(
            pre1
                + "public static org.objectweb.carol.cmi.ClusterConfig getClusterConfig() {\n");
        configFile.write(pre2 + "return instance;\n");
        configFile.write(pre1 + "}\n\n");
    }

    void writeConfigMethods(ClusterConf cconf) throws Exception {
        configFile.write(pre1 + "public boolean isGlobalAtExport() {\n");
        configFile.write(pre2 + "return false;\n");
        configFile.write(pre1 + "}\n\n");
        configFile.write(pre1 + "public boolean isGlobalAtBind() {\n");
        configFile.write(pre2 + "return true;\n");
        configFile.write(pre1 + "}\n\n");
        /*
        	MethodContext mthctx;
        	ClusterMethodInfo cmi;
        	for (int i = 0; i < nbMths; i++) {
                    mthctx = (MethodContext) remMths[i];
        	    cmi = cconf.getMethodInfo(mthctx.mth.toString());
                    if (cmi == null) {
                	System.err.println("Cluster stub compiler error: no configuration found for method :\n" + mthctx.mth.toString());
                	System.exit(1);
                    }
                    Utils.trace("config file: writing method " + mthctx.mthName);
                    switch (cmi.getType()) {
                    case ClusterMethodInfo.REDO_CHOICE_RETRY:
                	writeConfigMethodRedoChoiceRetry(mthctx, cmi);
                	break;
                    default:
                	System.err.println("Cluster stub compiler error: type not supported for method :\n" + mthctx.mth.toString());
        		System.exit(1);
                    }
        	}
        */

    }

    void writeConfigFoot() {
        configFile.write("}\n");
        configFile.close();
        Utils.trace("successfully generated config class source", cmpCtx);
    }
}
