/**
 * Copyright (C) 2002-2005 - Bull S.A.
 *
 * CMI : Cluster Method Invocation
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 * USA
 *
 * --------------------------------------------------------------------------
 * $Id: ServerIdFactory.java,v 1.1 2005/07/27 11:49:22 pelletib Exp $
 * --------------------------------------------------------------------------
 */
package org.objectweb.carol.cmi;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;

/**
 * The aim of this class is to generate unique IDs to identify an instance of a
 * clustered server. The IDs generated by this class are guaranteed to be
 * unique on the whole network.
 * To generate an ID, time may be needed, because they can be generated by
 * locking a well know resource for a period of time.
 *
 * @author Simon Nieuviarts
 */
public class ServerIdFactory {

    /**
     * Local id
     */
    private ClusterId localId;

    /**
     * starting time
     */
    private long date;

    /**
     * Socket
     */
    private ServerSocket ss;

    /**
     * Constructs the factory
     * @throws ServerConfigException if an exception is encountered
     */
    public ServerIdFactory() throws ServerConfigException {
        start();
    }

    /**
     * Start the generation.
     * Generate a cluster id based on a IP address.
     * @throws ServerConfigException if an exception is encountered
     */
    private void start() throws ServerConfigException {
        InetAddress a;
        try {
            a = InetAddress.getLocalHost();
        } catch (UnknownHostException e) {
            throw new ServerConfigException("Error in getLocalHost() : "
                    + e.toString());
        }
        byte aa[] = a.getAddress();
        if (aa.length != 4) {
            throw new ServerConfigException("IP Address of size " + aa.length
                    + " not supported by ServerIdFactory");
        }
        if (aa[0] == 127) {
            throw new ServerConfigException(
                    "Loopback IP address not allowed in ServerIdFactory : fix /etc/hosts (or equivalent) so that java.net.InetAddress.getLocalHost() does not return 127.x.x.x");
        }
        try {
            ss = new java.net.ServerSocket(0, 1, a);
        } catch (Exception e) {
            throw new ServerConfigException(e.toString());
        }
        int p = ss.getLocalPort();
        if ((p & 0xffff) != p) {
            throw new ServerConfigException(
                    "Invalid port number (more than 16 bits) in ServerIdFactory");
        }
        date = System.currentTimeMillis() / 1000;
        if (date >= 128L << 24) {
            throw new ServerConfigException(
                    "Invalid date (too high) in ServerIdFactory");
        }
        byte[] localIdArray = new byte[10];
        localIdArray[0] = (byte) (p & 0xff);
        localIdArray[1] = (byte) (p >> 8);
        localIdArray[2] = aa[3];
        localIdArray[3] = aa[2];
        localIdArray[4] = aa[1];
        localIdArray[5] = aa[0];
        int n = 4;
        long d = date;
        while (n > 0) {
            n--;
            localIdArray[9 - n] = (byte) (d & 0xff);
            d >>= 8;
        }
        localId = new ClusterId(localIdArray);
        SecureRandom.setSeed(localIdArray);
    }

    /**
     * Get the local cluster Id.
     * @return the cluster Id
     */
    public synchronized ClusterId getLocalId() {
        if (ss == null) {
            return localId;
        }
        while (true) {
            long d = System.currentTimeMillis();
            // d / 1000 should not be lower than date
            if ((d / 1000) > date) {
                try {
                    ss.close();
                } catch (IOException e) {
                    // Can not close. Nothing to do...
                }
                ss = null;
                return localId;
            }
            try {
                synchronized (localId) {
                    localId.wait(1001 - (d % 1000));
                }
            } catch (InterruptedException e) {
                // Nothing to do
            }
        }
    }
}