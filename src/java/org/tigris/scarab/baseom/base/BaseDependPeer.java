package org.tigris.scarab.baseom.base;

// JDK classes
import java.util.*;
import java.math.*;

// Village classes
import com.workingdogs.village.*;

// Turbine classes
import org.apache.turbine.om.*;
import org.apache.turbine.om.peer.*;
import org.apache.turbine.util.*;
import org.apache.turbine.util.db.*;
import org.apache.turbine.util.db.map.*;
import org.apache.turbine.util.db.pool.DBConnection;


// Local classes
import org.tigris.scarab.baseom.map.*;
import org.tigris.scarab.baseom.peer.*;
import org.tigris.scarab.baseom.*;


/**
  * This class was autogenerated by Torque on:
  *
  * [Thu Feb 22 18:38:08 PST 2001]
  *
  */
public abstract class BaseDependPeer extends BasePeer
{
    /** the mapbuilder for this class */
    private static final DependMapBuilder mapBuilder = 
        (DependMapBuilder)getMapBuilder(DependMapBuilder.CLASS_NAME);

    /** the table name for this class */
    public static final String TABLE_NAME = mapBuilder.getTable();

    /** the column name for the OBSERVED_ID field */
    public static final String OBSERVED_ID = mapBuilder.getDepend_ObservedId();
    /** the column name for the OBSERVER_ID field */
    public static final String OBSERVER_ID = mapBuilder.getDepend_ObserverId();
    /** the column name for the DEPEND_TYPE_ID field */
    public static final String DEPEND_TYPE_ID = mapBuilder.getDepend_TypeId();
    /** the column name for the DELETED field */
    public static final String DELETED = mapBuilder.getDepend_Deleted();

    /** number of columns for this peer */
    public static final int numColumns =  4;

    /** A class that can be returned by this peer. */
    protected static final String CLASSNAME_DEFAULT = 
        "org.tigris.scarab.baseom.Depend";

    /** A class that can be returned by this peer. */
    protected static final Class CLASS_DEFAULT = initClass();

    /** Initialization method for static CLASS_DEFAULT attribute */
    private static Class initClass()
    {
        Class c = null;
        try
        { 
            c = Class.forName(CLASSNAME_DEFAULT);
        }
        catch (Exception e)
        {
            Log.error("A FATAL ERROR has occurred which should not" +
                "have happened under any circumstance.  Please notify" +
                "Turbine and give as many details as possible including the " +
                "error stacktrace.", e);
        }
        return c;
    }


    /** Method to do inserts */
    public static ObjectKey doInsert( Criteria criteria ) throws Exception
    {
        criteria.setDbName(mapBuilder.getDatabaseMap().getName());
                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                      return BasePeer.doInsert( criteria );
    }

    /** 
     * Method to do inserts.  This method is to be used during a transaction,
     * otherwise use the doInsert(Criteria) method.  It will take care of 
     * the connection details internally. 
     */
    public static ObjectKey doInsert( Criteria criteria, DBConnection dbCon ) 
        throws Exception
    {
        criteria.setDbName(mapBuilder.getDatabaseMap().getName());
                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                      return BasePeer.doInsert( criteria, dbCon );
    }

    /** Add all the columns needed to create a new object */
    public static void addSelectColumns (Criteria criteria) throws Exception
    {
            criteria.addSelectColumn( OBSERVED_ID );
            criteria.addSelectColumn( OBSERVER_ID );
            criteria.addSelectColumn( DEPEND_TYPE_ID );
            criteria.addSelectColumn( DELETED );
        }


    /** 
     * Create a new object of type cls from a resultset row starting
     * from a specified offset.  This is done so that you can select
     * other rows than just those needed for this object.  You may
     * for example want to create two objects from the same row.
     */
    public static Depend row2Object (Record row, 
                                              int offset, 
                                              Class cls ) 
        throws Exception
    {
        Depend obj = (Depend)cls.newInstance();
                                                        obj.setObservedId(
                new SimpleKey( row.getValue(offset+0).asString() ));
                                                                            obj.setObserverId(
                new SimpleKey( row.getValue(offset+1).asString() ));
                                                                            obj.setTypeId(
                new SimpleKey( row.getValue(offset+2).asString() ));
                                                            obj.setDeleted
                (1 == row.getValue(offset+3).asInt());
                                        obj.setModified(false);
                obj.setNew(false);

        return obj;
    }

    /** Method to do selects */
    public static Vector doSelect( Criteria criteria ) throws Exception
    {
        return populateObjects( doSelectVillageRecords(criteria) ); 
    }


    /** Method to do selects within a transaction */
    public static Vector doSelect( Criteria criteria, 
                                   DBConnection dbCon ) 
        throws Exception
    {
        return populateObjects( doSelectVillageRecords(criteria, dbCon) ); 
    }

    /** 
     * Grabs the raw Village records to be formed into objects.
     * This method handles connections internally 
     */
    public static Vector doSelectVillageRecords( Criteria criteria ) 
        throws Exception
    {
        criteria.setDbName(mapBuilder.getDatabaseMap().getName());
        if (criteria.getSelectColumns().size() == 0)
        {
            addSelectColumns ( criteria );
        }

                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
              
        // BasePeer returns a Vector of Value (Village) arrays.  The array
        // order follows the order columns were placed in the Select clause.
        return BasePeer.doSelect(criteria);
    }


    /** 
     * Grabs the raw Village records to be formed into objects.
     * This method should be used for transactions 
     */
    public static Vector doSelectVillageRecords( Criteria criteria, 
                                                 DBConnection dbCon ) 
        throws Exception
    {
        addSelectColumns ( criteria );

                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
              
        // BasePeer returns a Vector of Value (Village) arrays.  The array
        // order follows the order columns were placed in the Select clause.
        return BasePeer.doSelect(criteria, dbCon);
    }

    /** 
     * The returned vector will contain objects of the default type or
     * objects that inherit from the default.
     */
    public static Vector populateObjects(Vector records) 
        throws Exception
    {
        Vector results = new Vector(records.size());

        // populate the object(s)
        for ( int i=0; i<records.size(); i++ )
        {
            Record row = (Record)records.elementAt(i);
            results.add(row2Object( row,1, CLASS_DEFAULT ));
        }
        return results;
    }




    /**
     * Method to do updates. 
     *
     * @param Criteria object containing data that is used to create the UPDATE statement.
     */
    public static void doUpdate(Criteria criteria) throws Exception
    {
        criteria.setDbName(mapBuilder.getDatabaseMap().getName());
        Criteria selectCriteria = new
            Criteria(mapBuilder.getDatabaseMap().getName(), 2);
                                selectCriteria.put( OBSERVED_ID, criteria.remove(OBSERVED_ID) );
                                         selectCriteria.put( OBSERVER_ID, criteria.remove(OBSERVER_ID) );
                                                      // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) ) 
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                                BasePeer.doUpdate( selectCriteria, criteria );
    }

    /** 
     * Method to do updates.  This method is to be used during a transaction,
     * otherwise use the doUpdate(Criteria) method.  It will take care of 
     * the connection details internally. 
     *
     * @param Criteria object containing data that is used to create the UPDATE statement.
     */
    public static void doUpdate(Criteria criteria, DBConnection dbCon) throws Exception
    {
        criteria.setDbName(mapBuilder.getDatabaseMap().getName());
        Criteria selectCriteria = new
            Criteria(mapBuilder.getDatabaseMap().getName(), 2);
                                selectCriteria.put( OBSERVED_ID, criteria.remove(OBSERVED_ID) );
                                         selectCriteria.put( OBSERVER_ID, criteria.remove(OBSERVER_ID) );
                                                      // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                                BasePeer.doUpdate( selectCriteria, criteria, dbCon );
     }

    /** 
     * Method to do deletes.
     *
     * @param Criteria object containing data that is used DELETE from database.
     */
     public static void doDelete(Criteria criteria) throws Exception
     {
         criteria.setDbName(mapBuilder.getDatabaseMap().getName());
                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                       BasePeer.doDelete ( criteria );
     }

    /** 
     * Method to do deletes.  This method is to be used during a transaction,
     * otherwise use the doDelete(Criteria) method.  It will take care of 
     * the connection details internally. 
     *
     * @param Criteria object containing data that is used DELETE from database.
     */
     public static void doDelete(Criteria criteria, DBConnection dbCon) throws Exception
     {
         criteria.setDbName(mapBuilder.getDatabaseMap().getName());
                                                                // check for conversion from boolean to int
        if ( criteria.containsKey(DELETED) )
        {
            Object possibleBoolean = criteria.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    criteria.add(DELETED, 1);
                }
                else
                {   
                    criteria.add(DELETED, 0);
                }
            }                     
         }
                       BasePeer.doDelete ( criteria, dbCon );
     }

    /** Method to do inserts */
    public static void doInsert( Depend obj ) throws Exception
    {
                doInsert(buildCriteria(obj));
                obj.setNew(false);
    }

    /**
     * @param obj the data object to update in the database.
     */
    public static void doUpdate(Depend obj) throws Exception
    {
        doUpdate(buildCriteria(obj));
    }
    /**
     * @param obj the data object to delete in the database.
     */
    public static void doDelete(Depend obj) throws Exception
    {
        doDelete(buildCriteria(obj));
    }

    /** 
     * Method to do inserts.  This method is to be used during a transaction,
     * otherwise use the doInsert(Depend) method.  It will take 
     * care of the connection details internally. 
     *
     * @param obj the data object to insert into the database.
     */
    public static void doInsert( Depend obj, DBConnection dbCon) throws Exception
    {
                doInsert(buildCriteria(obj), dbCon);
                obj.setNew(false);
    }

    /**
     * Method to do update.  This method is to be used during a transaction,
     * otherwise use the doUpdate(Depend) method.  It will take 
     * care of the connection details internally. 
     *
     * @param obj the data object to update in the database.
     */
    public static void doUpdate(Depend obj, DBConnection dbCon) throws Exception
    {
        doUpdate(buildCriteria(obj), dbCon);
    }
    /**
     * Method to delete.  This method is to be used during a transaction,
     * otherwise use the doDelete(Depend) method.  It will take 
     * care of the connection details internally. 
     *
     * @param obj the data object to delete in the database.
     */
    public static void doDelete(Depend obj, DBConnection dbCon) throws Exception
    {
        doDelete(buildCriteria(obj), dbCon);
    }

    /** Build a Criteria object from the data object for this peer */
    public static Criteria buildCriteria( Depend obj )
    {
        Criteria criteria = new Criteria();
                                criteria.add( OBSERVED_ID, obj.getObservedId() );
                                criteria.add( OBSERVER_ID, obj.getObserverId() );
                                criteria.add( DEPEND_TYPE_ID, obj.getTypeId() );
                                criteria.add( DELETED, obj.getDeleted() );
                return criteria;
    }

    /** 
     * Retrieve a single object by pk
     *
     * @param ObjectKey pk
     */
    public static Depend retrieveByPK( ObjectKey pk )
        throws Exception
    {
        Criteria criteria = new Criteria();
        SimpleKey[] keys = (SimpleKey[])pk.getInternalObject();
                    criteria.add( OBSERVED_ID, keys[0] );
                        criteria.add( OBSERVER_ID, keys[1] );
                    Vector v = doSelect(criteria);
        if ( v.size() != 1)
        {
            throw new Exception("Failed to select one and only one row.");
        }
        else
        {
            return (Depend)v.firstElement();
        }
    }


    /** 
     * retrieve object using using pk values.
     *
     * @param SimpleKey observed_id
     * @param SimpleKey observer_id
     */
    public static Depend retrieveByPK(
     SimpleKey observed_id
            , SimpleKey observer_id
                ) throws Exception
    {
        Criteria criteria = new Criteria(5);
        criteria.add( OBSERVED_ID, observed_id );
        criteria.add( OBSERVER_ID, observer_id );
        Vector v = doSelect(criteria);
        if ( v.size() != 1)
        {
            throw new Exception("Failed to select one and only one row.");
        }
        else
        {
            return (Depend) v.firstElement();
        }
    }



       
        
                               
     
          


   /**
    * selects a collection of Depend objects pre-filled with their
    * Issue objects.
    */
    public static Vector doSelectJoinIssueRelatedByObservedId(Criteria c)
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset = numColumns + 1;
        IssuePeer.addSelectColumns(c);

                                                                // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
                      
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);

            Depend obj1 = row2Object( row,1, CLASS_DEFAULT );


            Issue obj2 = IssuePeer
                .row2Object(row, offset, 
                    IssuePeer.CLASS_DEFAULT);
            
            boolean newObject = true;
            for (int j=0; j<results.size(); j++)
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                Issue temp_obj2 = temp_obj1.getIssueRelatedByObservedId();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDependsRelatedByObservedId(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDependsRelatedByObservedId();
                obj2.addDependsRelatedByObservedId(obj1);
            }
            results.add(obj1);

        }

        return results;
    }
         
                               
     
          


   /**
    * selects a collection of Depend objects pre-filled with their
    * Issue objects.
    */
    public static Vector doSelectJoinIssueRelatedByObserverId(Criteria c)
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset = numColumns + 1;
        IssuePeer.addSelectColumns(c);

                                                                // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
                      
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);

            Depend obj1 = row2Object( row,1, CLASS_DEFAULT );


            Issue obj2 = IssuePeer
                .row2Object(row, offset, 
                    IssuePeer.CLASS_DEFAULT);
            
            boolean newObject = true;
            for (int j=0; j<results.size(); j++)
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                Issue temp_obj2 = temp_obj1.getIssueRelatedByObserverId();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDependsRelatedByObserverId(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDependsRelatedByObserverId();
                obj2.addDependsRelatedByObserverId(obj1);
            }
            results.add(obj1);

        }

        return results;
    }
         
                       
     
          


   /**
    * selects a collection of Depend objects pre-filled with their
    * DependType objects.
    */
    public static Vector doSelectJoinDependType(Criteria c)
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset = numColumns + 1;
        DependTypePeer.addSelectColumns(c);

                                                                // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
                      
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);

            Depend obj1 = row2Object( row,1, CLASS_DEFAULT );


            DependType obj2 = DependTypePeer
                .row2Object(row, offset, 
                    DependTypePeer.CLASS_DEFAULT);
            
            boolean newObject = true;
            for (int j=0; j<results.size(); j++)
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                DependType temp_obj2 = temp_obj1.getDependType();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDepends(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDepends();
                obj2.addDepends(obj1);
            }
            results.add(obj1);

        }

        return results;
    }
    

  
  
     
                               
          


   /**
    * selects a collection of Depend objects pre-filled with 
    * all related objects.
    */
    public static Vector doSelectJoinAllExceptIssueRelatedByObservedId(Criteria c) 
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset2 = numColumns + 1;
                    
                                      
                                      
                DependTypePeer.addSelectColumns(c);
        int offset3 = offset2 + DependTypePeer.numColumns;
                                                                                              // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
              
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);


                Depend obj1 = row2Object( row,1, CLASS_DEFAULT );
  
                    
                                  
                                  
                                                
                        
            

            DependType obj2 = DependTypePeer
                .row2Object(row, offset2, 
                    DependTypePeer.CLASS_DEFAULT);
            
             boolean  newObject = true;
            for (int j=0; j<results.size(); j++)    
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                DependType temp_obj2 = temp_obj1.getDependType();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDepends(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDepends();
                obj2.addDepends(obj1);
            }
                        results.add(obj1);

        }

        return results;
    }
 
     
                               
          


   /**
    * selects a collection of Depend objects pre-filled with 
    * all related objects.
    */
    public static Vector doSelectJoinAllExceptIssueRelatedByObserverId(Criteria c) 
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset2 = numColumns + 1;
                    
                                      
                                      
                DependTypePeer.addSelectColumns(c);
        int offset3 = offset2 + DependTypePeer.numColumns;
                                                                                              // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
              
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);


                Depend obj1 = row2Object( row,1, CLASS_DEFAULT );
  
                    
                                  
                                  
                                                
                        
            

            DependType obj2 = DependTypePeer
                .row2Object(row, offset2, 
                    DependTypePeer.CLASS_DEFAULT);
            
             boolean  newObject = true;
            for (int j=0; j<results.size(); j++)    
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                DependType temp_obj2 = temp_obj1.getDependType();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDepends(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDepends();
                obj2.addDepends(obj1);
            }
                        results.add(obj1);

        }

        return results;
    }
 
     
                       
          


   /**
    * selects a collection of Depend objects pre-filled with 
    * all related objects.
    */
    public static Vector doSelectJoinAllExceptDependType(Criteria c) 
        throws Exception
    {
         c.setDbName(mapBuilder.getDatabaseMap().getName());

        addSelectColumns(c);
        int offset2 = numColumns + 1;
                    
                IssuePeer.addSelectColumns(c);
        int offset3 = offset2 + IssuePeer.numColumns;
                                          
                IssuePeer.addSelectColumns(c);
        int offset4 = offset3 + IssuePeer.numColumns;
                                          
                                                                                          // check for conversion from boolean to int
        if ( c.containsKey(DELETED) )
        {
            Object possibleBoolean = c.get(DELETED);
            if ( possibleBoolean instanceof Boolean )
            {
                if ( ((Boolean)possibleBoolean).booleanValue() )
                {
                    c.add(DELETED, 1);
                }
                else
                {   
                    c.add(DELETED, 0);
                }
            }                     
         }
              
        Vector rows = BasePeer.doSelect(c);
        Vector results = new Vector();

        for (int i=0; i<rows.size(); i++)
        {
            Record row = (Record)rows.elementAt(i);


                Depend obj1 = row2Object( row,1, CLASS_DEFAULT );
  
                    
                                                                
                        
            

            Issue obj2 = IssuePeer
                .row2Object(row, offset2, 
                    IssuePeer.CLASS_DEFAULT);
            
             boolean  newObject = true;
            for (int j=0; j<results.size(); j++)    
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                Issue temp_obj2 = temp_obj1.getIssueRelatedByObservedId();
                if ( temp_obj2.getPrimaryKey().equals(obj2.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj2.addDependsRelatedByObservedId(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj2.initDependsRelatedByObservedId();
                obj2.addDependsRelatedByObservedId(obj1);
            }
                        
                                                                
                        
            

            Issue obj3 = IssuePeer
                .row2Object(row, offset3, 
                    IssuePeer.CLASS_DEFAULT);
            
             newObject = true;
            for (int j=0; j<results.size(); j++)    
            {
                Depend temp_obj1 = (Depend)results.elementAt(j);
                Issue temp_obj3 = temp_obj1.getIssueRelatedByObserverId();
                if ( temp_obj3.getPrimaryKey().equals(obj3.getPrimaryKey() ) )
                {
                    newObject = false;
                    temp_obj3.addDependsRelatedByObserverId(obj1);
                    break;
                }
            }
            if (newObject)
            {
                obj3.initDependsRelatedByObserverId();
                obj3.addDependsRelatedByObserverId(obj1);
            }
                        
                                  results.add(obj1);

        }

        return results;
    }
  




}

