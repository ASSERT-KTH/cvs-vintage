###############################################################################
# Copyright (c) 2000, 2003 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials 
# are made available under the terms of the Common Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/cpl-v10.html
# 
# Contributors:
#     IBM Corporation - initial API and implementation
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved or is not a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The type {0} is an incorrectly specified nested type; replace the ''$'' with ''.''
7 = The private type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}

20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
25 = Cannot refer to a non-final variable {0} inside an inner class defined in a different method
26 = The member interface {0} can only be defined inside a top-level class or interface
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
53 = An array of void is an invalid type for the variable {0}
54 = An array of void is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate argument {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment

60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The local variable {0} is never read
62 = The argument {0} is never read
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many arguments, parameter {0} is exceeding the limit of 255 words eligible for method arguments
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic arguments, emulated parameter {0} is exceeding the limit of 255 words eligible for method arguments
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The private field {0}.{1} is never used locally

80 = The final field {0}.{1} cannot be assigned. It must be blank in this context, not qualified and not in compound assignment
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned

100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The private method {1}({2}) from the type {0} is never used locally

130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
134 = The private constructor {0}({1}) is never used locally
135 = Cannot refer to an instance field {0} while explicitly invoking a constructor
136 = Cannot refer to an instance method while explicitly invoking a constructor
137 = Recursive constructor invocation {0}({1})
138 = Cannot refer to ''this'' nor ''super'' while explicitly invoking a constructor

140 = Implicit super constructor {0}({1}) is undefined for default constructor. Must define an explicit constructor
141 = Implicit super constructor {0}({1}) is not visible for default constructor. Must define an explicit constructor
142 = Implicit super constructor {0}({1}) is ambiguous for default constructor. Must define an explicit constructor
143 = Implicit super constructor {0}({1}) is undefined. Must explicitly invoke another constructor
144 = Implicit super constructor {0}({1}) is not visible. Must explicitly invoke another constructor
145 = Implicit super constructor {0}({1}) is ambiguous. Must explicitly invoke another constructor
146 = Default constructor cannot handle exception type {0} thrown by implicit super constructor. Must define an explicit constructor
147 = Unhandled exception type {0} thrown by implicit super constructor

150 = The type of the expression must be an array type but it resolved to {0}
151 = Must explicitly convert the char[] to a String
152 = String constant is exceeding the limit of 65535 bytes of UTF8 encoding
153 = case expressions must be constant expressions
154 = {0} is out of range 
156 = Cannot cast from {0} to {1}
157 = The type {0} cannot be instantiated
158 = Cannot define dimension expressions when an array initializer is provided
159 = Variable must provide either dimension expressions or an array initializer
160 = The operator {0} is undefined for the argument type(s) {1}
161 = Unreachable code
162 = Cannot return from within an initializer
163 = Initializer does not complete normally
164 = Expression must return a value
165 = Catch block is hidden by another one in the same try statement
166 = The default case is already defined
167 = Unreachable catch block
168 = Unhandled exception type {0}
169 = case constant must be a char, byte, short, or int instead of {0}
170 = Duplicate case {0}
171 = Duplicate label {0}
172 = break cannot be used outside of a loop or a switch
173 = continue cannot be used outside of a loop
174 = The label {0} is missing
175 = {0} is not a valid type''s argument for the synchronized statement
176 = null is not a valid argument for the synchronized statement
177 = Cannot throw null
178 = The assignment to variable {0} has no effect

190 = Read access to enclosing field {0}.{1} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
191 = Write access to enclosing field {0}.{1} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
192 = Access to enclosing method {1}({2}) from the type {0} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
193 = Access to enclosing constructor {0}({1}) is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
195 = The method {1} is defined in an inherited type and an enclosing scope
196 = The field {0} is defined in an inherited type and an enclosing scope 
197 = The type {0} is defined in an inherited type and an enclosing scope

200 = Cannot use {0} in a static context 
201 = The method {1}({2}) from the type {0} is not static
202 = Cannot specify an array dimension after an empty dimension
203 = Invalid cast type expression
204 = Syntax error on token "{0}", {1} expected
205 = Syntax error on token "{0}", no accurate correction available
206 = Invalid argument to operation ++/--
207 = Interfaces cannot have constructors
208 = Array constants can only be used in initializers
209 = Syntax error on keyword "{0}"; {1} expected
210 = Syntax error on keyword "{0}", no accurate correction available

220 = Unmatched bracket
221 = The primitive type {0} of {1} does not have a field {2}
222 = Invalid expression as statement
223 = The left-hand side of an assignment must be a variable
224 = Missing semicolon
225 = Invalid parenthesized expression

250 = Unexpected end of file
251 = Invalid hexa literal number
252 = Invalid octal literal number
253 = Invalid character constant
254 = Invalid escape sequence (valid ones are  \\b  \\t  \\n  \\f  \\r  \\"  \\''  \\\\ )
255 = Invalid input
256 = Invalid unicode
257 = Invalid float literal number
258 = Null source string
259 = String literal is not properly closed by a double-quote
260 = Unexpected end of comment
261 = Non-externalized string literal; it should be followed by //$NON-NLS-<n>$

300 = The interface {0} cannot define an initializer
301 = Duplicate modifier for the type {0}
302 = Illegal modifier for the class {0}; only public, abstract & final are permitted
303 = Illegal modifier for the interface {0}; only public & abstract are permitted
304 = Illegal modifier for the member class {0}; only public, protected, private, static, abstract & final are permitted
305 = Illegal modifier for the member interface {0}; only public, protected, private, static & abstract are permitted
306 = Illegal modifier for the local class {0}; only one of abstract or final is permitted
308 = The class {0} can be either abstract or final, not both
309 = The interface member type {0} can only be public
310 = The member type {0} can only set one of public / protected / private
311 = The member type {0} cannot be declared static; static types can only be declared in static or top level types
312 = The interface {0} cannot be the superclass of {1}; a superclass must be a class
313 = The type {1} cannot subclass the final class {0}
314 = Duplicate interface {0} for the type {1}
315 = The class {0} cannot be a superinterface of {1}; a superinterface must be an interface
316 = {1} causes a cycle - the type {0} cannot extend/implement itself or one of its own member types
317 = A cycle exists in the type hierarchy between {0} and {1}
318 = Nested type {0} hides an enclosing type
319 = Duplicate nested type {0}
320 = Cannot throw the type {0}
321 = The package {0} collides with a type
322 = The type {1} collides with a package
323 = The type {1} is already defined
324 = This compilation unit indirectly references the missing type {0} (typically some required class file is referencing a type outside the classpath)
325 = The public type {1} must be defined in its own file
326 = A package must be specified in {0} or a default package created
327 = The hierarchy of the type {0} is inconsistent
328 = The declared package does not match the expected package {0}
329 = The type java.lang.Object cannot have a superclass or superinterfaces

330 = {0} cannot be resolved or is not a valid superclass
331 = Superclass {0} is not visible
332 = Superclass {0} is ambiguous
333 = Superclass {0} is an incorrectly specified nested type; replace the ''$'' with ''.''
334 = Superclass {0} is defined in an inherited type and an enclosing scope
335 = {0} cannot be resolved or is not a valid superinterface
336 = Superinterface {0} is not visible
337 = Superinterface {0} is ambiguous
338 = Superinterface {0} is an incorrectly specified nested type; replace the ''$'' with ''.''
339 = Superinterface {0} is defined in an inherited type and an enclosing scope
340 = Duplicate field {0}.{1}
341 = Duplicate modifier for the field {0}
342 = Illegal modifier for the field {0}; only public, protected, private, static, final, transient & volatile are permitted
343 = Illegal modifier for the interface field {0}; only public, static & final are permitted
344 = The field {0} can only set one of public / protected / private
345 = The field {0} can be either final or volatile, not both
346 = The field {0} cannot be declared static; static fields can only be declared in static or top level types

350 = {2} cannot be resolved (or is not a valid type) for the field {1}.{0}
351 = The type {2} is not visible for the field {1}.{0}
352 = The type {2} is ambiguous for the field {1}.{0}
353 = The field type {2} is an incorrectly specified nested type; replace the ''$'' with ''.''
354 = The field type {2} is defined in an inherited type and an enclosing scope
355 = Duplicate method {0} in type {1}
356 = Illegal modifier for argument {0}; only final is permitted
357 = Duplicate modifier for the method {1} in type {0}
358 = Illegal modifier for the method {1} in type {0}
359 = Illegal modifier for the interface method {1} in type {0}; only public & abstract are permitted
360 = The method {1} in type {0} can only set one of public / protected / private
361 = The method {1} cannot be declared static; static methods can only be declared in a static or top level type
362 = The abstract method {1} in type {0} can only set a visibility modifier, one of public or protected
363 = The abstract method {1} in type {0} can only be defined by an abstract class
364 = void is an invalid type for the argument {1} of the method {0}
365 = An array of void is an invalid type for the argument {1} of the method {0}
366 = An array of void is an invalid return type for the method {0}
367 = The native method {1} cannot also be declared strictfp
368 = Duplicate modifier for argument {0}

370 = {2} cannot be resolved (or is not a valid type) for the argument {1} of the method {0}
371 = The type {2} is not visible for the argument {1} of the method {0}
372 = The type {2} is ambiguous for the argument {1} of the method {0}
373 = The argument type {2} is an incorrectly specified nested type; replace the ''$'' with ''.''
374 = The argument type {2} is defined in an inherited type and an enclosing scope
375 = {1} cannot be resolved (or is not an exception type) for the method {0}
376 = The exception type {1} is not visible for the method {0}
377 = The exception type {1} is ambiguous for the method {0}
378 = The exception type {1} is an incorrectly specified nested type; replace the ''$'' with ''.''
379 = The exception type {1} is defined in an inherited type and an enclosing scope
380 = {1} cannot be resolved (or is not a valid return type) for the method {0}
381 = The return type {1} is not visible for the method {0}
382 = The return type {1} is ambiguous for the method {0}
383 = The return type {1} is an incorrectly specified nested type; replace the ''$'' with ''.''
384 = The return type {1} is defined in an inherited type and an enclosing scope
385 = The import {0} conflicts with a type defined in the same file
386 = The import {0} collides with another imported type
387 = Only a type can be imported. {0} resolves to a package
388 = The import {0} is never used
390 = The import {0} cannot be resolved
391 = The imported type {0} is not visible
392 = The imported type {0} is ambiguous
393 = The type {0} is an incorrectly specified nested type; replace the ''$'' with ''.''
394 = The type {0} is defined in an inherited type and an enclosing scope
395 = Duplicate modifier for the variable {0}
396 = Illegal modifier for the variable {0}; only final is permitted

400 = Class must implement the inherited abstract method {0}
401 = Cannot override the final method from {0}
402 = Exception {0} is not compatible with throws clause in {1}
403 = Exception {0} in throws clause of {1} is not compatible with {2}
404 = The return type is incompatible with {0}
405 = The inherited method {0} cannot hide the public abstract method in {1}
406 = This instance method cannot override the static method from {0}
407 = This static method cannot hide the instance method from {0}
408 = The static method {0} conflicts with the abstract method in {1}
409 = Cannot reduce the visibility of the inherited method from {0}
410 = The method {0} does not override the inherited method from {1} since it is private to a different package.
411 = This class must implement the inherited abstract method {1}, but cannot override it since it is not visible from {0}. Either make the type abstract or make the inherited method visible.
412 = The method {0} overrides a deprecated method from {1}
413 = The return type is incompatible with {0}, thus this interface cannot be implemented
414 = Exception {0} is not compatible with throws clause in {1}, thus this interface cannot be implemented

420 = Code snippet support cannot find the class {0}
421 = Code snippet support cannot find the method {0}.{1}({2}) 
422 = super cannot be used in the code snippet code

430 = Too many constants, the constant pool for {0} would exceed 65536 entries
431 = The type generates a string that requires more than 65535 bytes to encode in Utf8 format in the constant pool

432 = Too many fields for type {0}. Maximum is 65535
433 = Too many methods for type {0}. Maximum is 65535

440 = ''assert'' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on

450 = {0} {1}
