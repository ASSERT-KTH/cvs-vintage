<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta http-equiv="Content-Language" content="en-us">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <meta name="ProgId" content="FrontPage.Editor.Document">
   <title>Class Path Container Enhancement</title>
</head>
<body>

<h1>Class Path Container Enhancement</h1>
<span style="FONT-SIZE: 10pt">Last Modified April 23, 2002</span>


<h2>
Background</h2>
JDT supports to switch the JDK that is used for building. It is currently
implemented as follows:
<ul>
<li>
org.eclipse.jdt.launching maintains the following JDK/VM information in
its plugin metadata:</li>

<ul>
<li>
a set of <i>VM install types</i>: a description of a VM install. It knows
how to find the location of the binary JAR and the source JARs.</li>

<li>
<i>VM installs: </i>the location/home of a VM install on the file system.
A VM install has an internal ID that is not visible to the user.</li>

<li>
one of the VM installs is marked as the <i>default VM install</i>.</li>
</ul>

<li>
org.eclipse.jdt.launching defines a JRE_LIB, JRE_SRC, JRE_SRCROOT variables
that binds to the default VM install:</li>

<ul>
<li>
JRE_LIB: the binary JAR (e.g. rt.jar)</li>

<li>
JRE_SRC: the source JAR/zip (e.g. src.jar)</li>

<li>
JRE_SRCROOT: the prefix in the source JAR (e.g. "src")</li>
</ul>

<li>
The Java project creation wizard adds a JRE_LIB classpath variable on a
project's build class path.</li>

<li>
org.eclipse.jdt.debug.ui contributes a preference page to define new VM
installs and to set the default VM install. When the default VM install
changes, then the bindings of the JRE_* variables are changed accordingly.</li>

<li>
org.eclipse.jdt.ui contributes a class path variable preference page. It
"knows" that the JRE_* variables are reserved and doesn't allow the user
to edit them.</li>

<li>
The packages view shows the resolved JRE_LIB contents as a referenced library.</li>
</ul>
Characteristics of the current implementation:
<ul>
<li>
Class path stability: changing the default JRE/VM install doesn't affect
the build class path since the JRE_LIB variable is not affected by this
change. In other words, when a user changes the JRE for building then the
.classpath file is not affected.</li>

<li>
JDK switching at the workspace level for all projects is straightforward
by the user, only the default VM install needs to be changed and all projects
in the workspace switch to use this VM install.</li>

<li>
Since class path variables can only bind to a single JAR, the JRE_LIB variable
can only bind to a single JAR (for the standard SUN JRE this is rt.jar).</li>

<li>
There is some magic involved with regard to the handling of JRE_* variables
that is not obvious to the user:</li>

<ul>
<li>
on the build class path the user sees JRE_LIB but when defining a launch
configuration then the user sees VM Installs. The user has to know that
JRE_LIB is indirectly bound to the VM install via the JRE installed preference
settings.</li>

<li>
The user also has to understand that the reserved variables cannot be edited
like the other class path variables, etc.</li>
</ul>

<li>
Build class path ordering - users can control the order of the build class
path in a simple way. For example, to do JCL development, to do so users
can put their source folders in front of the JRE_LIB class path entry.</li>

<li>
Java Core is not affected by the JDK switching support and is independent
of launching concerns.</li>
</ul>

<h2>
Motivation for enhancing the current implementation</h2>

<h3>
New Requirements</h3>
There are new requirements with regard to the handling of the JRE/JDK on
the build class path that need to be addressed by 2.0:
<ul>
<li>
Multiple JARs per JDK</li>

<br>The JRE_LIB class path variable can only bind to a single JAR file
typically the rt.jar. However, there are JDK installs that have split the
rt.jar into multiple JARs. For example, the JDK on the MacOS X has split
the rt.jar into: classes.jar and ui.jar (contains AWT and Swing).
<br>&nbsp;
<li>
Workspaces with a different JDK per project</li>

<br>WSDD needs support for having a workspace where different projects
build against different JDKs. The JRE_LIB variable is global and there
is no infrastructure and UI support to have different JDKs for different
projects. WSDD defined their own build description mechanism that bypasses
the JRE_LIB support. This results in a problematic user experience when&nbsp;
switching from WSAD or vanilla Eclipse Java development to WSDD.</ul>

<h3>
Existing characteristics to be preserved in the new implementation</h3>

<ul>
<li>
Class path stability, it has to be possible to switch a JDK locally in
a workspace without affecting the .classpath file.</li>

<li>
Easy JDK switching at the workspace level, i.e., a single setting can be
changed to change the build class path of all projects.</li>

<li>
Java Core is independent of the VM install infrastructure</li>
</ul>

<h2>
Proposal</h2>
The proposal affects core, launching, java debug UI, and the Java UI components.
<h3>
JavaCore</h3>
JavaCore provides a new type of classpath entry "CPE_CONTAINER",
which is just a named reference to a set of other classpath entries. 
A container entry refers to a container path, which will be resolved by
a <code>ClasspathContainerResolver</code> through an extension point.

The actual binding from the CPE_Container entry to
the target classpath entries is implemented in term of an extension point
to keep Java Core independent of VM install concerns:
<p><tt>&nbsp;&nbsp; &lt;!ELEMENT classpathContainerResolver
EMPTY></tt>
<br><tt>&nbsp;&nbsp; &lt;!ATTLIST classpathContainerResolver</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefix&nbsp;&nbsp;&nbsp;
CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class&nbsp;&nbsp;&nbsp;&nbsp;
CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp; ></tt>
<ul>
<li><b>prefix</b> - the prefix of container names for which this resolver will be activated.</li>
<li><b>class</b> - the class that implements this container resolver.
The class must implement a public subclass of <code>org.eclipse.jdt.core.ClasspathContainerResolver</code>
with a public 0-argument constructor.</li>
</ul>
<tt>&nbsp;&nbsp; abstract class ClasspathContainerResolver
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IClasspathEntry[] resolve(IPath containerPath, IJavaProject project) throws
CoreException;</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<p>The resolve call passes in a project, this enables
to resolve a class path in the context of a particular project.
The resolve method should only be called once to resolve the class path
entry (in case of failure, the container will not be considered as having been
resolved).

<p>It is possible to register a resolved per
container path prefix, the full container path being passed along to the resolver
so as to provide additional hints for the container expansion.
In case multiple resolvers are registered, the one with the longest prefix match
will be invoked to resolve a given container path (in case of ambiguity, the first
registered one will be used).

<p>JavaCore provides a method to signal JDT/Core that a container definition
was changed.
<ul>
<li><code>JavaCore#containerChanged(IPath containerPath, IJavaElement scope)</code>. 
</ul>
The scope can either refer to a particular project or the entire JavaModel. In reaction
to invoking this method, the JavaModel will be refreshed and corresponding Java element
changes will be notified.

<p><font color="#FF0000"><b>Issue</b>: The Mac OS X JDK install is
an interesting case. There the rt.jar is split into two binary JARs (classes.jar,
ui.jar), but there is still a single src.jar. This cases needs to be handled by </font><font color="#FF0000">the
source lookup. For example, when src.jar is attached to classes.jar then when
looking up java.awt.Frame out of ui.jar, the source attachment of classes.jar
needs to searched as well.</font>

<h2>
Example</h2>
The class path of a project will look as follows:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;classpath&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;classpathentry kind=&quot;src&quot; path=&quot;/src&quot;/&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;classpathentry kind="container" path="JDK/1.3"/>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;classpathentry kind="output" path="bin"/>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;/classpath&gt;
<p>In the case where the user didn't override the
VM install at the project level. Then the Java launching contributed container
resolver (registered for container prefixes: "JDK") would resolve "JDK/1.3" using the default
VM install, using "1.3" as an hint, and may expand it into the following:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;classpathentry kind="lib" path=&quot;d:/jdk/1.3.1/jre/lib/rt.jar&quot;
rootpath=&quot;d:/jdk1.3.1/lib/src.jar&quot; sourcepath=&quot;/src&quot;/&gt;

</body>
</html>
