<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Author" content="Build">
   <title>JDT - Pluggable JDKs</title>
</head>
<body>

<h2>
Pluggable JDKs</h2>
Last revised 11:40 Monday October 15, 2001
<p>Work item: pluggable JDKs
<p>Related work item: "Support for dealing with class files generated by
external Java compilers like javac and jikes from an Ant script."
<p>Related issue: remote builds
<p>Other IDEs can claim that when Sun or IBM releases a new JDK, a developer
can just "plug it in" to their IDE. We would like Eclipse to be similarly
flexible, and be able to make a similar claim.
<p>In practice, what does this mean? There are several different aspects.
<ol>
<li>
The ablility to run Java programs with the JDK's JRE.</li>

<li>
The ablility to compile Java source code against the JDK's class libraries.</li>

<li>
The ablility to compile Java source code with the JDK's javac compiler.</li>

<li>
The ablility to debug Java programs with the JDK's JDPA and JVM.</li>

<li>
The ablility to browse the JDK's class library API javadoc (or perhaps
other release doc).</li>

<li>
The ablility to run the JDK's utility programs like javap, javadoc, javah.</li>
</ol>
We will take the first four as the most important ones for Eclipse to address,
and look at each in turn.
<h3>
Pluggable JREs</h3>
[TBD]
<h3>
Pluggable JDK class libraries</h3>
[TBD]
<h3>
Pluggable Java compilers</h3>
Java compilers can differ along many axes:
<ul>
<li>
supported Java language level</li>

<li>
Java bytecode version</li>

<li>
quality of generated code</li>

<li>
helpfulness of error messages</li>

<li>
performance</li>

<li>
robustness</li>

<li>
product support for compiler</li>
</ul>
In the simple world of the command line compiler, it's easy to use whatever
Java compiler you choose to use. The command lines are substantially the
same, and the overt compiler behavior of translating .java source files
to .class files is utterly standard.
<p><i><font color="#FF0000">[pm: Each compiler can produce distinct bytecode
patterns, and may implement the specification in a subtle different way]</font></i>
<p>In addition to the basic compiler functionality, there are usually a
number of IDE features that also need to be "language aware" (to some extent),
including:
<ul>
<li>
source code editing (syntax highlighting)</li>

<li>
code assist (completion, selection)</li>

<li>
code reformatter</li>

<li>
search</li>
</ul>
The language aware features require either reimplementing those portions
of a compiler that are needed (e.g., a scanner), or using APIs implemented
by the compiler (e.g., its scanner API).
<p><i><font color="#FF0000">[pm: It should rather say that some functionalities
can be built on top of a compiler infrastructure. But the only task of
the compiler is to compile. It could have some APIs allowing to better
reuse its internals, but it should not comprise other pieces such as code
assist.]</font></i>
<p>The standard Sun Java compiler has no official APIs. This means that
Java IDEs have no choice but to reimplement those portions of the Java
compiler that they might need. Without standard Java compiler APIs, no
Java IDE can be truely pluggable in these regards. The best that a Java
IDE can do in the circumstances is to use a pluggable Java compiler for
its basic compiler functionality.
<p>In Eclipse 1.0, the IDE's basic Java compiler functionality is provided
by the built-in Eclipse compiler. What would it take to make this part
pluggable?
<p>In Eclipse, the basic Java compiler functionality is provided through
the Java builder. The Java builder is activated when its build method is
called. This happens when (a) an explicit Build commands requested by the
user, (b) the workspace performs an auto build, or (c) some plug-in instigated
a build programmatically.
<p>So the first idea is that the Java builder's build method should invoke
a pluggable Java compiler to do a build.
<h4>
Calling a pluggable javac from within the Java builder</h4>
For a full build, this is clearly doable. The source folders mentioned
on the build classpath can be walked to identify all Java source files.
The corresponding class files in the output folder are deleted, and Java
problem markers are removed. The names of these source files are then passed
to javac as the ones to compile (large file sets perhaps broken up into
reasonable sized batches); the classpath passed is computed from the project's
build classpath; the output folder is passed as the target for the generated
class files. The compiler will generate class files into the target folder
and print text error messages to its output stream. Depending on how "standard"
the format of the output stream was, the Java builder might be able to
analyze the stream of text error messages and convert these into Java problem
markers associated with the offending source files (the complete stream
could also be saved and made available to user through some other mechanism).
The net result should be almost indistinguishable from running the Eclipse
compiler; the one difference is that the Java builder would not be able
to produce anything resembling its current internal built state (i.e.,
no dependency graph).
<p><i><font color="#FF0000">[pm: Also, no error marker for free, no resource
change information for generated .class files - Javac is not Eclipse-compliant]</font></i>
<p>For an incremental build, it is impossible to do anything more than
a cursory job without proper dependency information. The Java builder is
passed a resource delta for the project showing which source files have
changed. The delta would also show that the build classpath had changed
(the Java builder could easily remember some classpaths between builds).
<p>How to do an incremental build:
<ul>
<li>
delete a source file => identify and delete the corresponding class files</li>

<li>
add a source file => identify and delete corresponding class files (just
in case); include source file in list to be recompiled</li>

<li>
change a source file => identify and delete corresponding class files;
include source file in list to be recompiled</li>
</ul>
The compiler is called to recompile the identified list of source files.
The Java builder would analyze the -verbose output stream to discover which
source files were actually compiled and update their Java problem markers.
<p><i><font color="#FF0000">[pm: -verbose may not produce a standard output.
We are just guessing at this point that we might figure something useful
in their information dumping. Do we still have the LF javac wrapper around
? This one was probably doing it, wasn't it ?]</font></i>
<p>This kind of simple-minded incremental build handles many simple cases
(e.g., changing the body of a method, fixing javadoc comments, reformatting).
The results would usually be less satisfactory when the principal structure
of class is changed because any dependent source files do not get recompiled.
The developer would need to be educated about when to be asking for a full
build. Many will already be familiar with these rules from using other
Java IDEs. With a Java compiler that does not produce dependency information,
it is hard for an IDE with pluggable Java compilers to do any better.
<p><i><font color="#FF0000">[pm: I wouldn't call this incremental compilation,
in the sense that this is expected to be smart, I would use partial recompilation
that may not guarantee binary compatibility]</font></i>
<p>Autobuild is just an incremental build that is triggered automatically.
Note that the user may find it intolerable to run with autobuild enabled
if the overhead for invoking the pluggable compiler is high (which it is
likely to be if a separate JVM would need to be launched).
<p>The conclusion is that this is feasible, although autobuilding may be
intolerable. As long as the pluggable Java compiler was very javac-like
in terms of command line options and format of generated error messages,
it should be possible to use it to build a Java project.
<h4>
Calling an Ant script instead of the Java builder</h4>
An even more flexible approach would be to allow a Java project to be configured
with a generic Ant-based incremental project builder instead of the standard
Java builder. The Ant-based builder is described in a separate 2.0 Platform
Core feature proposal.
<p>All of the above considerations would still apply; the only real difference
is that everything is implemented in Ant terms.
<h3>
Pluggable JDPA Debuggers</h3>
[TBD]
<br>&nbsp;
</body>
</html>
