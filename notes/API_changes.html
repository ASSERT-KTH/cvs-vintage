<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="IBM">
   <title>JDT/Core Breaking API changes</title>

</head>
<body>

<body text="#000000" bgcolor="#FFFFFF">
&nbsp;

<table border=0 cellspacing=5 cellpadding=2 width="100%" >
  <tr> 
    <td align=left width="72%">
      <font face="Verdana, Arial, Helvetica" size="+3"><b>jdt core - Breaking API changes from R2.1 to R3.0</b></font>
      <br><font face="Arial, Helvetica, sans-serif" size="-2" color="#8080ff">java development tooling core</font></td>
  </tr>
	<tr><td>&nbsp;</td></tr>
  <tr>
  	<td>
	  <font face="Arial, Helvetica, sans-serif" size="-1">
	  This document lists all API changes (breaking or not) that occured between R2.1 and R3.0 and how to migrate from the R2.1 API to
	  the R3.0 API.
	  </font>
	</td>
  </tr>
</table>

<p>
<ul>
<li>(in progress) <code>IWorkingCopy</code> now extends <code>ICompilationUnit</code>
	 (see <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=36987 ">bug 36987 </a>)
	  <p>
	  Historically, <code>IWorkingCopy</code> gathered all working copy concerns, 
	  and <code>ICompilationUnit</code> implement this interface, though only the 
	  factory method makes sense for them; thus their implementation of the working 
	  copy features do nothing relevant to clients. <code>IWorkingCopy</code> also 
	  implements the spec'ed factory method, but it doesn't work for these.
	  </p>
	  <p>
	  Clients using <code>IWorkingCopy</code> and <code>ICompilationUnit</code> can
	  adapt to this change by referencing <code>IWorkingCopy</code> instead of 
	  <code>ICompilationUnit</code> when a working copy is needed.
	  </p>
</li>
<li>(in progress) Factory methods that create <code>IWorkingCopies</code> (i.e. 
	  <code>getWorkingCopy</code> and <code>getSharedWorkingCopy</code>) now return
	  an <code>IWorkingCopy</code> instead of an <code>IJavaElement</code>.
	  <p>
	  Working copies were initialy designed to be editable elements on any <code>IJavaElement</code>.
	  Pratice showed that they were used only to edit <code>ICompilationUnit</code>. To avoid 
	  downcasting to <code>IWorkingCopy</code>, the factory methods now return an
	  <code>IWorkingCopy</code>.
	  </p>
	  <p>
	  Clients using factory methods to create working copies can now remove the cast from 
	  <code>IJavaElement</code> to <code>IWorkingCopy</code>.
	  </p>
</li>

<li>2003/06/11 (->M2)
<code>CharOperation.patchMatch(...)</code> no longer treat non absolute pattern <code>'foo'</code>
as <code>'**/foo'</code> for free. This was inconsistent with Ant patternset rules. This has no incidence on
source folder exclusion patterns which are implicitely concatenating exclusion patterns to source folder
paths when using them. Only direct clients to this <code>CharOperation</code> API will be affected.
</li>

<li>2003/06/11 (->M2)
Change in syntax error message ID. The new diagnose of syntax errors use new error messages.
	  <p>
		The following messages ID are added:
		<ul>
			<li>IProblem.ParsingErrorInsertTokenBefore</li>
			<li>IProblem.ParsingErrorInsertTokenAfter</li>
			<li>IProblem.ParsingErrorDeleteToken</li>
			<li>IProblem.ParsingErrorDeleteTokens</li>
			<li>IProblem.ParsingErrorMergeTokens</li>
			<li>IProblem.ParsingErrorInvalidToken</li>
			<li>IProblem.ParsingErrorMisplacedConstruct</li>
			<li>IProblem.ParsingErrorReplaceTokens</li>
			<li>IProblem.ParsingErrorNoSuggestionForTokens</li>
			<li>IProblem.ParsingErrorUnexpectedEOF</li>
			<li>IProblem.ParsingErrorInsertToComplete</li>
			<li>IProblem.ParsingErrorInsertToCompleteScope</li>
			<li>IProblem.ParsingErrorInsertToCompletePhrase</li>
		</ul>
	  </p>
	  <p>
		The following messages ID are removed:
		<ul>
			<li>IProblem.ParsingErrorNoSuggestion</li>
			<li>IProblem.ParsingErrorOnKeyword</li>
			<li>IProblem.ParsingErrorOnKeywordNoSuggestion</li>
			<li>IProblem.UnmatchedBracket</li>
			<li>IProblem.InvalidExpressionAsStatement</li>
		</ul>
	  </p>
</li>
<li>2003/06/12 (->M2)
Added API <code>IJavaProject#forceClasspathReload(IProgressMonitor)</code> to force reload of <code>.classpath</code> file
before next automatic update occurs.
<pre>
/**
 * Force the project to reload its <code>.classpath</code> file from disk and update the classpath accordingly.
 * Usually, a change to the <code>.classpath</code> file is automatically noticed and reconciled at the next 
 * resource change notification event. If required to consider such a change prior to the next automatic
 * refresh, then this functionnality should be used to trigger a refresh. In particular, if a change to the file is performed,
 * during an operation where this change needs to be reflected before the operation ends, then an explicit refresh is
 * necessary.
 * 
 * @param monitor a progress monitor for reporting operation progress
 * @exception JavaModelException if the classpath could not be updated. Reasons
 * include:
 *  - This Java element does not exist (ELEMENT_DOES_NOT_EXIST)</li>
 *  - Two or more entries specify source roots with the same or overlapping paths (NAME_COLLISION)
 *  - A entry of kind <code>CPE_PROJECT</code> refers to this project (INVALID_PATH)
 *  - This Java element does not exist (ELEMENT_DOES_NOT_EXIST)</li>
 *  - The output location path refers to a location not contained in this project (<code>PATH_OUTSIDE_PROJECT</code>)
 *  - The output location path is not an absolute path (<code>RELATIVE_PATH</code>)
 *  - The output location path is nested inside a package fragment root of this project (<code>INVALID_PATH</code>)
 *  - The classpath is being modified during resource change event notification (CORE_EXCEPTION)
 * @since 3.0
 */
</pre>
</li>

<li>2003/06/13 (->M2)
<code>JavaCore.newLibraryEntry(...)</li> will now allow an empty source attachment (new Path("")) to
be equivalent to no source attachment (i.e. <code>null</null>). This adjustment is made necessary for
library entries generated from classpath variables which cannot be set to <code>null</code>. Also see 
bug <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=38531">38531</a>.
<pre>
* @param sourceAttachmentPath the absolute path of the corresponding source archive or folder, 
*    or <code>null</code> if none. Note, since 3.0, an empty path is allowed to denote no source attachment.
*   and will be automatically converted to <code>null</code>.
</pre>
</li>
<li>2003/06/16 (->M2)
In the process of closing the gap between compilation units and working copies 
(see <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=36888 ">bug 36888</a>), the following new APIs 
are added to <code>ICompilationUnit</code>:
	<ul>
	<li><pre>
/**
 * Changes this compilation unit handle into a working copy. A new IBuffer is
 * created using this compilation unit handle's owner. Uses the primary owner is none was
 * specified when this compilation unit handle was created.
 *
 * When switching to working copy mode, problems are reported to given 
 * IProblemRequestor.
 *
 * Once in working copy mode, changes to this compilation unit or its children are done in memory.
 * Only the new buffer is affected. Using commitWorkingCopy(boolean, IProgressMonitor)
 * will bring the underlying resource in sync with this compilation unit.
 *
 * If this compilation unit was already in working copy mode, an internal counter is incremented and no
 * other action is taken on this compilation unit. To bring this compilation unit back into the original mode 
 * (where it reflects the underlying resource), discardWorkingCopy must be call as many 
 * times as becomeWorkingCopy.
 * 
 * @param problemRequestor a requestor which will get notified of problems detected during
 * 	reconciling as they are discovered. The requestor can be set to null indicating
 * 	that the client is not interested in problems.
 * @param monitor a progress monitor used to report progress while opening this compilation unit
 * 	or null if no progress should be reported 
 * @exception JavaModelException if this compilation unit could not become a working copy.
 * @see discardWorkingCopy
 * @since 3.0
 */
void becomeWorkingCopy(IProblemRequestor problemRequestor, IProgressMonitor monitor) throws JavaModelException;	
	</pre></li>
	<li><pre>
/**
 * Commits the contents of this working copy to its underlying resource.
 *
 * It is possible that the contents of the original resource have changed
 * since this working copy was created, in which case there is an update conflict.
 * The value of the force parameter effects the resolution of
 * such a conflict:
 * - true - in this case the contents of this working copy are applied to
 * 	the underlying resource even though this working copy was created 
 * 	before a subsequent change in the resource
 * - false - in this case a JavaModelException is thrown
 * 
 * Since 2.1, a working copy can be created on a not-yet existing compilation
 * unit. In particular, such a working copy can then be committed in order to create
 * the corresponding compilation unit.
 * 
 * @param force a flag to handle the cases when the contents of the original resource have changed
 * since this working copy was created
 * @param monitor the given progress monitor
 * @exception JavaModelException if this working copy could not commit. Reasons include:
 * - A CoreException occurred while updating an underlying resource
 * - This element is not a working copy (INVALID_ELEMENT_TYPES)
 * - A update conflict (described above) (UPDATE_CONFLICT)
 * @since 3.0
 */
void commitWorkingCopy(boolean force, IProgressMonitor monitor) throws JavaModelException;	
	</pre></li>
	<li><pre>
/**
 * Changes this compilation unit in working copy mode back to its original mode.
 *
 * This has no effect if this compilation unit was not in working copy mode.
 * 
 * If becomeWorkingCopy was called several times on this
 * compilation unit, discardWorkingCopy must be called as 
 * many times before it switches back to the original mode.
 * 
 * @see becomeWorkingCopy
 * @exception JavaModelException if this working copy could not return in its original mode.
 * @since 3.0
 */
void discardWorkingCopy() throws JavaModelException;
	</pre></li>
	<li><pre>
/**
 * Returns the working copy owner of this working copy.
 * Returns null if it is not a working copy or if it has no owner.
 * 
 * @return WorkingCopyOwner the owner of this working copy or null
 * @since 3.0
 */
WorkingCopyOwner getOwner();
	</pre></li>	
	<li><pre>
/**
 * Returns a new working copy of this element if this element is not
 * a working copy, or this element if this element is already a working copy.
 * 
 * Note: if intending to share a working copy amongst several clients, then 
 * getWorkingCopy(WorkingCopyOwner, IProblemRequestor, IProgressMonitor) 
 * should be used instead.
 * 
 * When the working copy instance is created, an ADDED IJavaElementDelta is 
 * reported on this working copy.
 * 
 * Since 2.1, a working copy can be created on a not-yet existing compilation
 * unit. In particular, such a working copy can then be committed in order to create
 * the corresponding compilation unit.
 * 
* @param monitor a progress monitor used to report progress while opening this compilation unit
 * 	or null if no progress should be reported 
 * @exception JavaModelException if the contents of this element can
 * 	not be determined. 
 * @return a new working copy of this element if this element is not
 * 	a working copy, or this element if this element is already a working copy
 * @since 3.0
 */
ICompilationUnit getWorkingCopy(IProgressMonitor monitor) throws JavaModelException;
	</pre></li>	
	<li><pre>
/**
 * Returns a shared working copy on this element using the given working copy owner to create
 * the buffer, or this element if this element is already a working copy.
 * This API can only answer an already existing working copy if it is based on the same
 * original compilation unit AND was using the same working copy owner (that is, as defined by Object.equals).	 
 * 
 * The life time of a shared working copy is as follows:
 * - The first call to getWorkingCopy(WorkingCopyOwner, IProblemRequestor, IProgressMonitor)
 *   creates a new working copy for this element
 * - Subsequent calls increment an internal counter.
 * - A call to discardWorkingCopy() decrements the internal counter.
 * - When this counter is 0, the working copy is discarded.
 * 
 * So users of this method must discard exactly once the working copy.
 *
 * Note that the working copy owner will be used for the life time of this working copy, that is if the 
 * working copy is closed then reopened, this owner will be used.
 * The buffer will be automatically initialized with the original's compilation unit content
 * upon creation.
 * 
 * When the shared working copy instance is created, an ADDED IJavaElementDelta is reported on this
 * working copy.
 * 
 * Since 2.1, a working copy can be created on a not-yet existing compilation
 * unit. In particular, such a working copy can then be committed in order to create
 * the corresponding compilation unit.
 * 
 * @param owner the working copy owner that creates a buffer that is used to get the content 
 *  	of the working copy
 * @param problemRequestor a requestor which will get notified of problems detected during
 * 	reconciling as they are discovered. The requestor can be set to null indicating
 * 	that the client is not interested in problems.
 * @param monitor a progress monitor used to report progress while opening this compilation unit
 * 	or null if no progress should be reported 
 * @exception JavaModelException if the contents of this element can
 *  	not be determined. 
 * @return a new working copy of this element using the given factory to create
 * the buffer, or this element if this element is already a working copy
 * @since 3.0
 */
ICompilationUnit getWorkingCopy(WorkingCopyOwner owner, IProblemRequestor problemRequestor, IProgressMonitor monitor) throws JavaModelException;	
	</pre></li>
	</ul>
And the following abstract class replaces <code>IBufferFactory</code>:
	<pre>
/**
 * The owner of an ICompilationUnit handle in working copy mode. 
 * An owner is used to identify a working copy and to create its buffer.
 * 
 * @see ICompilationUnit#becomeWorkingCopy
 * @see ICompilationUnit#discardWorkingCopy
 * @since 3.0
 */
public abstract class WorkingCopyOwner {
	/**
	 * Creates a buffer for the given working copy.
	 * The new buffer will be initialized with the contents of the underlying file
	 * if and only if it was not already initialized by the compilation owner (a buffer is 
	 * uninitialized if its content is null).
	 * 
	 * @param workingCopy the working copy of the buffer
	 * @return IBuffer the created buffer for the given working copy
	 * @see IBuffer
	 */
	public IBuffer createBuffer(ICompilationUnit workingCopy) {
		...
	}
}
	</pre>
</li>
<li>2003/06/18 (->M2)
<code>IJavaElement.getResource()</code> was specified to return <code>null</code> for working copies. This didn't make sense as
this is a handle-only operation and an <code>IResource</code> is also a handle. This restriction was removed and 
<code>IJavaElement.getResource()</code> now returns a non-<code>null</code> value for a working copy.
</li>
<li>2003/06/19 (->M2)
The 2.1 API <code>IWorkingCopy.getOriginalElement()</code> returns an <code>IJavaElement</code>. In practice 
the original element for a working copy is always an <code>ICompilationUnit</code>. So <code>getOriginal()</code> 
was added on <code>ICompilationUnit</code> to return an <code>ICompilationUnit</code>. This new API replaces
<code>getOriginalElement()</code>.
<pre>
/**
 * Returns the original compilation unit (whose owner is the primary owner)
 * this working copy was created from, or <code>null</code> if this is not a working copy.
 * 
 * @return the original compilation unit this working copy was created from,
 * or <code>null</code> if this is not a working copy
 * @since 3.0
 */
ICompilationUnit getOriginal();
</pre>
</li>
</ul>
</body>
</html>
